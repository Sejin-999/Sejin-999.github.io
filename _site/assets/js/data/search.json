[
  
  {
    "title": "test 해보기",
    "url": "/posts/testPage/",
    "categories": "Blog",
    "tags": "Blog, jekyll, Github, Git",
    "date": "2024-03-18 06:44:00 +0900",
    





    
    "snippet": "목차  링크  목록  코드 블록  인용문  이미지링크구글에 가보세요.목록  항목 1  항목 2          하위 항목 1      하위 항목 2      코드 블록public class Main {    public static void main(String[] args) {        System.out.println(\"Hello, world!...",
    "content": "목차  링크  목록  코드 블록  인용문  이미지링크구글에 가보세요.목록  항목 1  항목 2          하위 항목 1      하위 항목 2      코드 블록public class Main {    public static void main(String[] args) {        System.out.println(\"Hello, world!\");    }}인용문  인용문입니다. 이것은 어떤 작가나 발언자의 말을 인용할 때 사용됩니다.이미지"
  },
  
  {
    "title": "자바에 대하여 - 스레드",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%8A%A4%EB%A0%88%EB%93%9C/",
    "categories": "java",
    "tags": "java, thread, register",
    "date": "2024-01-08 06:44:00 +0900",
    





    
    "snippet": "5.JAVA-스레드들어가며이번 포스트에서는 스레드에 대한 포스트 입니다.사실 한번쯤은 모두 공부해본 내용이지만 , 정리도하고 java에서는 어떻게 활용할 수 있는지에 대한 이야기도 함께 하겠습니다.스레드?프로세스 내에서 실행되는 독립적인 작업 단위이며 여러 스레드가 하나의 프로세스에서 동작할 수 있습니다.그리고 스레드는 자체적인 흐름제어,스택,레지스터...",
    "content": "5.JAVA-스레드들어가며이번 포스트에서는 스레드에 대한 포스트 입니다.사실 한번쯤은 모두 공부해본 내용이지만 , 정리도하고 java에서는 어떻게 활용할 수 있는지에 대한 이야기도 함께 하겠습니다.스레드?프로세스 내에서 실행되는 독립적인 작업 단위이며 여러 스레드가 하나의 프로세스에서 동작할 수 있습니다.그리고 스레드는 자체적인 흐름제어,스택,레지스터를 가지고 있습니다.사용하는 가장 큰 이유는 여러 작업을 동시에 수행하여 효율성을 높이기 위해 사용합니다.자바에서 스레드 쓰기  Thread 클래스 상속: Thread 클래스를 상속받고 run() 메서드를 오버라이딩하여 스레드의 실행 코드를 구현합니다.  Runnable 인터페이스 구현: Runnable 인터페이스를 구현하고 run() 메서드를 오버라이딩하여 스레드의 실행 코드를 구현합니다.개발자가 스레드를 쓸 수 있는 방법은 크게 두 가지 입니다.public class ThreadExample {    public static void main(String[] args) {        // Thread 클래스 상속        Thread thread1 = new Thread() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    System.out.println(\"Thread 1: \" + i);                }            }        };        // Runnable 인터페이스 구현        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    System.out.println(\"Thread 2: \" + i);                }            }        });        thread1.start();        thread2.start();    }}코드를 보면 위 언급한 두가지 방법을 통해 구현했습니다.단순히 0 ~ 9 까지 출력하는 예제 입니다.실행 해보면 결과가 다음과 같습니다.순서대로 나오지 않고 , 섞여 있는 모습을 볼 수 있는데 스레드를 생성해 동시에 작업을 진행하였기 때문입니다.그럼 현실 , 즉 메모리에서는 어떻게 동작 하는지에 대해서도 궁금한데요스레드가 사용하는 메모리            영역      내용      공유 여부                  스택      스레드 실행 흐름, 로컬 변수, 메서드 호출 정보      X (각 스레드마다 독립적)              힙      스레드가 사용하는 객체      O (모든 스레드가 공유)              프로그램 카운터      현재 실행 중인 명령어      X (각 스레드마다 독립적)              레지스터      CPU 임시 저장 공간      X (각 스레드마다 독립적)      각 스레드는 독립된 개체로써 사용하기 때문에 각각의 제어,스택,레지스터를 가지고 있습니다.저는 이렇게 이해했는데요공간(레지스터)에 실행 중인 명령(프로그램 카운터)과  스레드 마다 가진 데이터(스택) 스레드가 공유하는 데이터-객체(힙)궁금증이 생긴 것은 static 영역은 그럼 스레드를 사용할 때는 사용하지 않는지에 대해 알아보고 싶어졌습니다. 그래서 찾아보니 다음과 같습니다.static은 안쓰니?일반적으로는 static 영역을 쓰지 않는다.왜? static 영역을 사용하면 모든 스레드가 공유되고 , 이는 독립성의 문제를 발생시킵니다.또한, 동기화 기술을 자체적으로 사용해야만 하며( 데이터 손상에 대한 고려) static영역은 전 포스트에서 이야기했던것처럼프로그램이 시작되고 종료될때까지 유지되기 때문에 메모리의 누수 즉, 굳이 안쓰는 공간을 비효율적으로 차지할 수 있습니다.정리하면 다음과 같습니다.  독립적인 실행 흐름: 스레드는 각자의 실행 흐름을 가지고 있어야 하며, static 영역은 모든 스레드가 공유하기 때문에 스레드 간의 독립성을 유지하기 어렵습니다.  변수의 동기화 문제: static 변수는 모든 스레드가 공유하기 때문에 동기화 기술을 사용하지 않으면 데이터 손상이 발생할 수 있습니다.  메모리 누수 가능성: static 영역은 프로그램 종료 시까지 메모리에 존재하기 때문에 스레드에서 사용하지 않는 static 변수가 메모리 누수를 유발할 수 있습니다.물론 무조건 쓰지 못하게 막은 것은 아닙니다.예를 들어 모든 스레드가 공유하는 상수값, 클래스 변수를 저장 할 때는 static영역을 활용할 수 있다고 합니다.다만 이 경우에도 동기화 기술을 사용해야 한다고 합니다.레지스터는 뭔데?레지스터는 CPU 내부에 있는 작고 빠른 메모리 공간입니다. CPU는 레지스터를 사용하여 계산, 데이터 비교, 논리 연산 등을 수행하는데 필요한 데이터와 명령어를 임시적으로 저장합니다.레지스터의 특징:  빠른 속도: 레지스터는 CPU 내부에 위치하기 때문에 메모리보다 훨씬 빠른 속도로 접근할 수 있습니다.  작은 크기: 레지스터는 메모리보다 훨씬 작은 크기입니다.  다양한 종류: 레지스터는 다양한 종류가 있으며, 각각 다른 용도로 사용됩니다.레지스터의 용도:  계산: 레지스터는 덧셈, 뺄셈, 곱셈, 나눗셈 등의 계산에 필요한 데이터를 저장합니다.  논리 연산: 레지스터는 AND, OR, NOT 등의 논리 연산에 필요한 데이터를 저장합니다.  명령어 저장: 레지스터는 다음에 실행할 명령어를 저장합니다.레지스터의 종류:  일반 레지스터: 일반적인 계산 및 데이터 저장에 사용됩니다.  특수 레지스터: 프로그램 카운터, 스택 포인터 등 특정 용도로 사용됩니다.레지스터의 중요성:레지스터는 CPU의 성능에 중요한 영향을 미칩니다. 레지스터의 크기와 속도가 클수록 CPU는 더 빠르게 프로그램을 실행할 수 있습니다.정리이번 포스트는 자바에서 스레드를 어떻게 쓰고 , 동작하는지에 대해 알아봤습니다.스레드 라는 개념은 자주 들어서 인지하고 있었는데 정리해보며 알아봤습니다.이번 포스트를 쓰며 @overriding 이라는 어노테이션을 사용하였는데오버로드와 오버 라이딩에 대해서도 정리해보자고 생각이 들어 다음은관련된 내용을 포스트하겠습니다.다음 포스트자바 에서의 오버로드와 오버 라이딩"
  },
  
  {
    "title": "알고리즘 - search - dfs&bfs",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-search/",
    "categories": "algorithm",
    "tags": "java, algorithm, dfs, bfs",
    "date": "2024-01-07 06:44:00 +0900",
    





    
    "snippet": "문제는 자바를 이용해 풀어보겠습니다!들어가며이번 포스트에서는 탐색 기법에 대한 이야기를 해보려고 합니다.알고리즘은 공부를 하면 할 수록 더욱 깊고 , 다양한 조합을 만들 수 있기 때문에 기본적이며 핵심적인 이야기들을 위주로 공부해본 내용을 정리하겠습니다.DFS - 깊이 우선 탐색DFS : depth first search 는 완전 탐색 기법 중 하나 ...",
    "content": "문제는 자바를 이용해 풀어보겠습니다!들어가며이번 포스트에서는 탐색 기법에 대한 이야기를 해보려고 합니다.알고리즘은 공부를 하면 할 수록 더욱 깊고 , 다양한 조합을 만들 수 있기 때문에 기본적이며 핵심적인 이야기들을 위주로 공부해본 내용을 정리하겠습니다.DFS - 깊이 우선 탐색DFS : depth first search 는 완전 탐색 기법 중 하나 입니다.완전 탐색 기법 (Exhaustive Search) 은 모든 경우의 수를 탐색해 해를 찾는 기법입니다.특징은 일관되고 , 간단하고 직관적입니다.당연히 모든 경우의 수를 탐색하는 만큼 경우의 수가 많아질 수 록 효율이 낮아집니다.            기능      특징      시간 복잡도                  그래프 완전 탐색      재귀 함수를 사용      O(V+E)                     스택 자료구조 이용      V : node의 수 , E : 에지 수      재귀 함수를 사용한다. (구현 할때  재귀함수 사용함)결국  자기 자신을 부르는 구조로 구현이 되기 때문에 스택 오버 플로우가 발생할 가능성이 존재합니다. 이점을 유의 하면서 코딩 해야 합니다.구현 하는 원리는 다음과 같습니다.처음 초기화를 하며 시작점을 선택합니다.또한, 방문한 기록을 저장하기 위한 배열을 생성 &amp; 그래프 데이터를 저장할 인접 리스트를 생성Stack의 시작점에 대한 노드를 삽입합니다.이후 노드를 꺼내고 해당 노드와 연결된 노드를 Stack에 삽입합니다.그리고 이것을 반복하면 DFS의 탐색 순서를 얻을 수 있고 , 구현이 가능합니다.BFS - 너비 우선 탐색BFS: breadth-frist-search 너비 우선 탐색시작 노드 기준으로 가까운 노드를 먼저 방문한다.BFS는 큐를 이용해 구현합니다.            기능      특징      시간 복잡도                  그래프 완전 탐색      FIFO를 사용      O(V+E)                     Queue 자료구조 이용      V : node의 수 , E : 에지 수      구현원리는 다음과 같습니다.  시작점을 선택하고 초기화 합니다. 여기서 데이터를 저장해둡니다.      큐에 삽입한 노드를 pull 하고 관련된 노드 즉,인접한 노드를 큐에삽입합니다    -여기서 유의할 점은 큐에 삽입했다고 아직 방문한 상태는아닙니다.    모든 경우의 수를 만족할때까지반복합니다.구현해보자잘 생각하면 dfs와 bfs 둘다 인접리스트와 방문배열을 사용합니다.그리고 구분점은 Stack의 LIFO , Queue의 FIFO를 활용하는지에 따라 두 방법의 구분이 가능합니다.그럼 자바로 예시코드를 보면서 이야기해보겠습니다.백준 -1260 문제입니다.위 언급하였듯이 두 search 알고리즘은 인접리스트와 방문배열을 사용합니다.static ArrayList&lt;Integer&gt;[] dataArr;static boolean[] visted;자바에서는 이런식으로 구현할 수 있습니다.ArrayList로 이루어진 배열을 선언함으로써 인접리스트를 구현할 수 있습니다.방문배열은 boolean형 배열을 선언함으로써 구현할 수 있습니다.ArrayList?자주 사용하는데 굳이 의미를 두고 쓰지 않아 설명해보려니 햇갈려서 정리하였습니다.ArrayList는 자바에서 제공하는 동적 배열(dynamic array)로, 크기가 가변적으로 자동으로 조절되는 배열입니다. 기존의 배열과는 달리, 요소를 추가하거나 삭제할 때 크기 조절이 자동으로 이루어져 편리하게 사용할 수 있습니다.특징  가변 크기: 배열의 크기를 동적으로 조절할 수 있습니다. 요소를 추가하면 자동으로 크기가 증가하고, 요소를 삭제하면 자동으로 크기가 감소합니다.  인덱스 기반 접근: 각 요소는 인덱스를 사용하여 접근할 수 있습니다. ArrayList는 내부적으로 배열을 사용하기 때문에 인덱스를 통한 접근이 빠릅니다.  제네릭 타입 지원: 제네릭 타입을 사용하여 저장될 요소의 타입을 명시할 수 있습니다. 이를 통해 타입 안정성을 보장하고 형 변환을 줄일 수 있습니다.  배열과 유사한 성능: 요소의 추가나 삭제 시 배열을 복사하는 과정이 필요하지만, ArrayList는 배열을 사용하기 때문에 배열과 유사한 성능을 보입니다.초기화하기dataArr = new ArrayList[n+1];visted = new boolean[n+1];for(int i=1; i&lt;n+1; i++){    dataArr[i] = new ArrayList&lt;&gt;();}공부하면서 +1이 왜필요할지에 대해서 생각을 해봤습니다.그래프에서 정점을 0을 안쓰니까 즉, 보통 정점을 1부터 시작하는 정수로 사용하기 때문에 0을 비워두고 쓰기 때문이다. 라고 생각 해봤는데 일단 bard도 이런식으로 답변해서 맞는 이유라고 생각합니다.방향에 대하여        for(int i =0; i&lt;m; i++){            st = new StringTokenizer(br.readLine());            int a = Integer.parseInt(st.nextToken());            int b = Integer.parseInt(st.nextToken());            dataArr[a].add(b);            dataArr[b].add(a);        }만약 양뱡향 , 무뱡향인 경우에는 양쪽 모두를 넣어줘야합니다.하지만 한쪽방향이 지정 된 경우에는 한쪽만 넣어주면 됩니다.DFS - 재귀함수를 이용해 구현하기    private static void _dfs(int node){        System.out.print(node + \" \");        visted[node] =true;        for(int i : dataArr[node]){            if(! visted[i]) bfs_01_dfs(i);        }    }위에 선언해 뒀던 인접리스트 배열에서 값을 뽑은다음방문 기록을 확인해 방문하지 않은 부분을 재귀 하면 됩니다.DFS - Stack으로 구현하기Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 스택 생성        stack.push(start); // 시작 정점을 스택에 넣음        visited[start] = true; // 시작 정점 방문 표시        System.out.println(\"DFS 결과:\");        while (!stack.isEmpty()) {            int current = stack.pop(); // 스택에서 정점을 꺼냄            System.out.print(current + \" \"); // 현재 정점 출력            // 현재 정점과 연결된 정점들 중 방문하지 않은 정점을 스택에 넣음            for (int next : dataArr[current]) {                if (!visited[next]) {                    stack.push(next);                    visited[next] = true;                }            }        }stack을 선언한 뒤  시작점을 push하고stack의 값이 없을때까지 pop하여 해당 값이  방문하지 않은경우 push 해주면 됩니다.BFS - Queue를 이용해 구현하기    private static void _bfs(int node){        visted[node] =true;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        queue.add(node);        while (!queue.isEmpty()){            int now = queue.poll();            System.out.print(now + \" \");            for(int i : dataArr[now]){                if(! visted[i]){                    visted[i] =true;                    queue.add(i);                }            }        }    }Queue를 선언하고 들어온 큐를 삽입합니다 .(시작점)Queue가 빌때까지 반복하며 현재 값을 poll합니다. 그리고 이 값이 방문하지 않은 경우에는Queue에 추가하면 됩니다.정리하며이번 포스트 에서는 DFS와 BFS에 대해 정리해봤습니다."
  },
  
  {
    "title": "JAVA에 대하여 - 메모리 & 가비지 컬렉션",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC/",
    "categories": "java",
    "tags": "java, 메모리, Heap, 메소드",
    "date": "2024-01-06 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 Java가 메모리를 어떤식으로 활용하는지에 대한 이야기를 정리해보려고 합니다.자세하게 생각하면 끝도 없는 영역이기 때문에 아 이런식으로 동작하는 구나 정도의 수준의 정리 내용입니다.언어들은 메모리를 어떻게 쓸가?Java와 같이 컴파일러를 통해 기계어를 만들어 사용하는 언어들은 아래 그림처럼코드를 실행하는 영역과 데이터를 저장하...",
    "content": "들어가며이번 포스트에서는 Java가 메모리를 어떤식으로 활용하는지에 대한 이야기를 정리해보려고 합니다.자세하게 생각하면 끝도 없는 영역이기 때문에 아 이런식으로 동작하는 구나 정도의 수준의 정리 내용입니다.언어들은 메모리를 어떻게 쓸가?Java와 같이 컴파일러를 통해 기계어를 만들어 사용하는 언어들은 아래 그림처럼코드를 실행하는 영역과 데이터를 저장하는 영역으로 나누어 메모리를 할당해 사용합니다.자바의 경우에 데이터를 저장하는 방법은 크게 3가지로 나누어 이야기할 수 있습니다.Java가 최초 저장할때는 해당영역을 사용합니다.더 정확히 구분하면Method Area 와 Static Area로 나눌 수 있습니다.Method Area vs Static Area?메서드 영역(Method Area):  모든 스레드가 공유하는 영역으로, 클래스 파일의 바이트 코드, 정적 변수(static variable), 상수(Constant), 메서드 코드 등이 저장됩니다.  클래스 로더(Class Loader)에 의해 클래스 파일이 로드되면 해당 클래스의 정보가 메서드 영역에 저장됩니다.스태틱 영역(static Area):  객체가 생성되기 전에 이미 메모리에 할당되는 영역으로, 모든 인스턴스가 공유하는 데이터를 저장합니다. 클래스 변수(static variable)가 static 영역에 저장됩니다결국 이전 포스트에서 이야기했던 .class를 저장하는 영역으로 보는지 혹은 객체 이전에 생성된 모든 인스턴스가 공유하는 저장 공간을 의미 하는지의 차이로 생각합니다.또한, 여기서 클래스변수 와 정적변수가 같은 영단어를 쓰는 걸 볼 수 있는데공부해본 바로는 다음과 같습니다.  클래스 변수(Class Variable): 클래스 변수는 객체 간에 공유되는 변수를 의미하며, 객체를 생성하지 않고도 클래스 이름을 통해 접근할 수 있습니다. 클래스 변수는 일반적으로 static 키워드로 선언됩니다.  정적 변수(Static Variable): 정적 변수는 객체에 속하지 않는 변수를 의미하며, 클래스 내부에서만 사용되는 변수를 일컫습니다. 따라서 객체를 생성하지 않고도 클래스 내부에서 직접 접근할 수 있습니다. 클래스 변수와 유사하지만, 클래스 변수가 반드시 static 키워드로 선언되어야 하는 반면, 정적 변수는 그렇지 않을 수 있습니다.정리하면 결국 같은 의미입니다. 특정 클래스의 변수다 라는 의미를 강조하기 위해 클래스 변수라는 개념을 사용하는 것인데 같은 의미로 두고 봐도 무방하다고 생각합니다.Stack Area &amp;&amp; Heap Area  힙 영역(Heap Area):          동적으로 생성된 객체와 배열이 저장되는 영역입니다.      힙 영역은 가비지 컬렉션(Garbage Collection)에 의해 관리되며, 더 이상 사용되지 않는 객체는 메모리에서 해제됩니다.        스택 영역(Stack Area):          각 스레드마다 별도로 할당되는 영역으로, 메서드 호출 시 생성되는 지역 변수(local variable), 매개변수(parameter), 메서드 호출 스택(method call stack) 등이 저장됩니다.      메서드 호출 시 해당 메서드의 스택 프레임이 스택 영역에 생성되며, 메서드 실행이 완료되면 스택 프레임이 제거됩니다.      정리하면 힙은 객체를 저장하는 공간 , 스택은 로컬 변수와 매개 변수 , 메서드를 호출하는 스택이 저장됩니다.정리해보면 이런식으로 볼 수 있습니다.변수나 메서드 조건문 등이 하나의 Stack의 들어와 작동하게 됩니다.하지만 항상 존재하는 것은 아니고 사용 후 에는 해당 메모리를 비워줍니다.이렇게 해서 메모리의 효율성을 보장할 수 있게 됩니다.그리고 계산된 결과 중 이후 사용이 있는 데이터들에 대해서는 캐시에 저장하여 더욱 높은 효율성을 볼 수 있게 합니다.이외에도 Pc레지스터와 네이티브 메서드 스택이 존재합니다.Pc레지스터 &amp;&amp; 네이티브 메서드  PC 레지스터(Program Counter Register):          스레드마다 별도로 할당되는 영역으로, 현재 실행 중인 명령어의 주소를 가리키는 포인터입니다.      JVM이 다음에 실행할 명령어의 주소를 가리키며, 스레드가 실행 중인 동안에만 유효합니다.        네이티브 메서드 스택(Native Method Stack):          자바 언어가 아닌 다른 언어로 작성된 네이티브 코드(native code)를 실행하기 위한 스택 영역입니다.      JNI(Java Native Interface)를 통해 자바 언어와 네이티브 언어 간의 상호 작용을 지원합니다.      이런 방법을 통해 자바가 메모리를 관리하고 있다는 것을 알 수 있습니다.Heap Area 에 대한 고찰힙 공간(Heap Space)은 동적으로 생성된 객체와 배열이 저장되는 메모리 영역입니다.자바에서는 new 키워드를 사용하여 객체를 생성할 때 힙 영역에 메모리를 할당하고,이 객체는 가비지 컬렉션(Garbage Collection)에 의해 관리됩니다.힙 영역은 JVM(Java Virtual Machine)이 시작될 때 생성되며, 프로그램이 종료될 때까지 유지됩니다만약 C로 동적 프로그래밍을 했다면? 포인터연산을 통해 지정하며 코딩해야 합니다.예시코드를 보며 설명해보자면public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}public class Main {    public static void main(String[] args) {        // 힙 영역에 Person 객체를 생성하여 메모리를 할당합니다.        Person person1 = new Person(\"Alice\", 25);        Person person2 = new Person(\"Bob\", 30);                // 생성된 객체의 메서드를 호출하여 정보를 출력합니다.        System.out.println(\"Person 1: \" + person1.getName() + \", \" + person1.getAge() + \" years old\");        System.out.println(\"Person 2: \" + person2.getName() + \", \" + person2.getAge() + \" years old\");    }}이런 식으로 힙 영역에 메모리를 할당해 새로운 객체 (동적으로 생성한 객체)를 저장하고 사용할 수 있습니다. 그런데 궁금한점이 생겼습니다. 자료구조들은 어떻게 저장할까?기본적으로 String 이라는 것 ,  문자열(String)은 불변(immutable) 객체로 취급되며, 메모리 상에 생성된 문자열은 변경할 수 없습니다.다른 자료구조들인 정수(int, long, short, byte), 부동 소수점(float, double), 문자(char), 논리(boolean) 등과는 차이점이 분명히 존재합니다.String에 대하여위 언급한 String은 문자”열” 입니다. 문자를 나열한 정보를 저장해두는 자료구조입니다.자바는 이전에 말씀드린 데이터를 객체로 만드는 것을 지향합니다.따라서 기본 데이터 유형(primitive data types)들 과 String(Object)은 분명한 차이점이 존재하게 됩니다.따라서 문자열을 생성하면 해당 문자열은 힙 영역에 저장되고, 이후에 변경되지 않습니다.public class StringExample {    public static void main(String[] args) {        // 문자열 리터럴을 사용하여 String 객체 생성        String str1 = \"Hello\";        // 새로운 String 객체 생성        String str2 = new String(\"World\");        // 문자열 연결 연산으로 새로운 String 객체 생성        String str3 = str1 + str2;        // 문자열 상수를 직접 가리키는 경우 동일한 문자열 리터럴은 동일한 메모리 주소를 참조        String str4 = \"Hello\";        // 문자열 내용이 같더라도 새로운 객체가 생성됨        String str5 = new String(\"Hello\");        // String 객체가 힙 영역에 저장되고 있는지 확인하기 위해 hashCode() 메서드 호출        System.out.println(\"str1 hashCode: \" + str1.hashCode());        System.out.println(\"str2 hashCode: \" + str2.hashCode());        System.out.println(\"str3 hashCode: \" + str3.hashCode());        System.out.println(\"str4 hashCode: \" + str4.hashCode());        System.out.println(\"str5 hashCode: \" + str5.hashCode());    }}실행시켜보면 모두 다른 주소를 사용하고 있다는 것을 확인할 수 있습니다.primitive data types 는 어디에 저장될까?기본 데이터 유형(primitive data types)은 일반적으로 스택(stack) 영역에 저장됩니다.기본 데이터 유형은 정수(int, long, short, byte), 부동 소수점(float, double), 문자(char), 논리(boolean) 등이 있습니다.스택 영역은 지역 변수(local variable) 및 메서드 호출 시 생성되는 프레임(frame)을 저장하는 영역으로, 메모리의 상대적으로 빠른 공간을 활용합니다.public class PrimitiveExample {    public static void main(String[] args) {        // 정수형 변수 선언 및 초기화        int intValue = 10;        // 부동 소수점 변수 선언 및 초기화        double doubleValue = 3.14;        // 문자 변수 선언 및 초기화        char charValue = 'A';        // 논리형 변수 선언 및 초기화        boolean booleanValue = true;        // 스택 영역에 저장된 변수 값 출력        System.out.println(\"intValue: \" + intValue);        System.out.println(\"doubleValue: \" + doubleValue);        System.out.println(\"charValue: \" + charValue);        System.out.println(\"booleanValue: \" + booleanValue);    }}위의 코드에서 intValue, doubleValue, charValue, booleanValue는 모두 스택 영역에 저장되는 변수입니다.이들 변수는 메서드 내에서 사용되는 지역 변수로써, 메모리가 할당된 스택 프레임에 저장됩니다.따라서 이들 변수는 해당 프레임이 소멸될 때 함께 소멸되며, 스택 프레임이 소멸되면 해당 변수가 사용되는 메모리 공간도 함께 해제됩니다.정리해보면Object 는 Heap Area 에서 관리한다. 그리고 이걸 관리하는 Garbage Collection이 있다.Garbage CollectionGarbage Collection(가비지 컬렉션)은 프로그램 실행 중에 더 이상 사용되지 않는 메모리를 자동으로 해제하는 자바의 기능입니다.이는 프로그래머가 명시적으로 메모리 관리를 수행할 필요가 없게 해줍니다.수행 방식에 대해 정리해보면  객체 생성: 프로그램에서 객체가 생성되면 힙(heap) 영역에 메모리가 할당됩니다. 객체는 생성될 때마다 힙 영역의 어딘가에 저장되고, 해당 객체를 참조하는 변수가 있다면 그 변수에 객체의 참조(주소)가 저장됩니다.  객체 사용: 프로그램이 실행되는 동안 객체는 사용되며, 해당 객체에 대한 참조가 계속 유지됩니다.  참조 해제: 객체를 참조하는 변수가 더 이상 존재하지 않으면 해당 객체에 대한 참조는 끊어지며, 이 때 객체는 가비지(garbage)로 간주됩니다.  가비지 컬렉션 실행: JVM은 주기적으로 또는 필요할 때마다 가비지 컬렉션을 실행하여 힙 영역에서 더 이상 사용되지 않는 객체를 탐지하고 제거합니다.  메모리 해제: 가비지 컬렉션에 의해 탐지된 가비지 객체들은 메모리에서 해제되고, 해당 메모리 공간은 다시 사용 가능한 상태가 됩니다.객체를 생성 , 사용 → 참조 해제 → 가비지 컬렉션이 돌아다니며 객체를 탐지 제거 → 메모리 해제이렇게 순서대로 이해할 수 있습니다.장점은 당연히 해야할 일이 적어지고 이전 포스트에서도 이야기 하였듯이사람이 메모리를 명시적으로 할당하다 발생하는 사고에 대해 미연의 방지하는메모리 누수를 막을 수 있습니다.단점은 가비지 컬렉션이 일단 실행되려면 프로그램을 일시적으로 일시정지해야합니다.왜냐면 아직 사용 중 인데 해제시키면 안되니까요즉, 프로그램이 동작하는데 소요되는 시간이 증가하게 됩니다.따라서 성능을 개선하기 위해 여러 기법들이 고려되어야 합니다.  메모리 할당 최적화: 객체를 생성할 때 메모리를 적게 사용하도록 최적화하는 것이 중요합니다. 이는 객체의 크기를 최소화하거나, 불필요한 객체 생성을 피하고, 객체 풀링(Object Pooling)과 같은 기술을 사용하여 객체의 재사용을 촉진하는 것을 의미합니다.  GC 튜닝: JVM에서 Garbage Collection 알고리즘 및 설정을 조정하여 성능을 최적화할 수 있습니다. 이는 Young Generation과 Old Generation의 비율 조정, GC 알고리즘 선택, GC 동작 주기 조절 등을 포함합니다. 예를 들어, GC 알고리즘을 G1GC로 변경하거나, GC 동작 주기를 조정하여 응용 프로그램의 요구에 맞게 설정할 수 있습니다.  메모리 누수 감지: 메모리 누수를 방지하고 탐지하는 것이 중요합니다. 메모리 누수는 가비지 컬렉션의 성능을 저하시킬 수 있습니다. 따라서 메모리 프로파일러(memory profiler) 및 메모리 분석 도구를 사용하여 메모리 누수를 식별하고 해결해야 합니다.  간접적인 참조 제거: 불필요한 객체에 대한 간접적인 참조를 제거하는 것이 중요합니다. 예를 들어, 캐시를 사용할 때 캐시에 저장된 객체에 대한 간접적인 참조를 정리하는 것이 필요합니다.  멀티 스레딩 및 병렬 처리: 가비지 컬렉션 작업을 멀티 스레드로 실행하거나 병렬로 처리하여 성능을 향상시킬 수 있습니다. 예를 들어, Parallel GC(병렬 GC) 또는 G1GC(Garbage First GC)와 같은 병렬 가비지 컬렉션 알고리즘을 사용하여 가비지 컬렉션 작업을 여러 CPU 코어에서 동시에 처리할 수 있습니다.보기만 해도 어려운 이야기가 많습니다만정리하면 그렇게 어렵지 않습니다.그냥 메모리 최적화를 위한 Polling , GC라는 알고리즘 , 누수 감지 , 간접참조 제거 , 멀티스레딩입니다. (알고리즘은 알고리즘 관련 포스트를 올릴 예정이라 거기서 다루어 보겠습니다.)Object Pooling여기서 객체 풀링(Object Pooling) 이란 컴퓨터관련 전공을 한사람들은 한번 쯤 어디선가 들어봤을법한  풀(pool)에 저장하고 필요할 때마다 풀에서 가져와서 쓰는 방법입니다.필자가 기억하기로는 SQL , Network에서 연결관리 할때 사용했던것으로 기억합니다.어쨋든 정말 많이 사용되는 기법인데여기서 객체 풀링이란 ,많은 객체를 반복적으로 생성하고 제거하는 대신, 객체를 미리 생성하여 풀(pool)에 저장하고 필요할 때마다 풀에서 객체를 가져와 사용하는 기법을 말합니다.(자세한 이야기는 다른 포스트에서 하겠습니다.)정리하며이번 포스트에서는 자바가 메모리를 어떻게 관리하는지에 대한 이야기를 정리해봤습니다.항상 느끼는거지만 이런 Low레벨에서 개발하시는 하드웨어나 OS개발자분들이 정말 대단한거 같습니다. 공부할때마다 어렵고 이해가 안되는 부분이 계속 나오는 걸 보면요.간단하게 자바 메모리 사용의 대한 정보를 정리하면서 또 공부해보고 싶은 이야기들도 생겨서 재미있었습니다. (Gc튜닝 같은 부분들..)다음 포스트에서는 자바의 스레드의 대한 이야기를  해보려고합니다.다음 포스트자바 스레드 &amp; 스레드의 대하여"
  },
  
  {
    "title": "JAVA에 대하여 - 동작",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%8F%99%EC%9E%91/",
    "categories": "java",
    "tags": "java, JDK, JVM, 인터프리터",
    "date": "2024-01-05 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 에서는 자바가 동작하는 구동 과정의 대해 정리해 보려고 합니다. 자바가 매력적인 이유 중 하나인 구동 과정에 대한 이야기는 매우 흥미롭습니다.자바는 어떻게 보여지나제가 정리하면 이미지를 보시면 크게 3가지의 소프트웨어를 통해 동작한다는 것을 볼 수 있습니다.JDK = 개발도구 , JRE = JVM용 OS , JVM = 자바 전용 가...",
    "content": "들어가며이번 포스트 에서는 자바가 동작하는 구동 과정의 대해 정리해 보려고 합니다. 자바가 매력적인 이유 중 하나인 구동 과정에 대한 이야기는 매우 흥미롭습니다.자바는 어떻게 보여지나제가 정리하면 이미지를 보시면 크게 3가지의 소프트웨어를 통해 동작한다는 것을 볼 수 있습니다.JDK = 개발도구 , JRE = JVM용 OS , JVM = 자바 전용 가상 컴퓨터이전 포스트에서 자바가 나온 이유에 대해 설명하며 다양한 플렛폼에서 사용이 가능하다는 의미가 바로 이런식으로 동작하기 때문에 가능합니다.이런 특성을 Write once Run Anywhere 이라고 하는데 한국어로 “한번 쓰면 계속 쓸 수 있음” 입니다.JVM의 특징을 정리해보면 다음 과 같습니다.  플랫폼 독립성: JVM은 플랫폼 독립적입니다. 즉, Java 프로그램은 한 번 작성되면 어떤 플랫폼에서도 실행될 수 있습니다. 이는 Java 언어가 컴파일된 바이트코드를 JVM이 해석하고 실행하기 때문에 가능합니다.  자동 메모리 관리: JVM은 가비지 컬렉션을 통해 메모리를 자동으로 관리합니다. 이는 프로그래머가 명시적으로 메모리 할당과 해제를 관리할 필요가 없게 해줍니다. 따라서 Java 프로그램에서 메모리 누수 및 다른 메모리 관련 오류를 방지할 수 있습니다.  보안: JVM은 강력한 보안 기능을 제공합니다. Java 애플리케이션은 샌드박스 환경에서 실행되어 악의적인 코드의 실행을 방지합니다. 또한 JVM은 바이트코드 검증과 같은 보안 기능을 내장하고 있어 안전한 실행을 보장합니다.  성능 최적화: JVM은 Just-In-Time (JIT) 컴파일러를 사용하여 프로그램의 성능을 최적화합니다. JIT 컴파일러는 프로그램이 실행될 때 바이트코드를 네이티브 코드로 변환하여 실행 속도를 향상시킵니다.  동적 로딩: JVM은 클래스 파일을 동적으로 로드하여 실행할 수 있습니다. 이는 애플리케이션의 유연성을 높이고, 프로그램의 실행 중에도 새로운 클래스를 동적으로 로드하여 실행할 수 있게 합니다.  멀티스레딩 지원: JVM은 멀티스레드를 지원하여 동시에 여러 작업을 수행할 수 있습니다. 이는 Java 프로그램이 병렬 및 동시성 작업을 수행하는 데 도움이 됩니다.  풍부한 표준 라이브러리: JVM은 Java 표준 라이브러리 (Java API)를 제공하여 다양한 작업을 수행하는 데 필요한 클래스와 메서드를 제공합니다. 이러한 표준 라이브러리는 개발 과정을 단순화하고 생산성을 향상시킵니다.읽다 보면 생각보다 처음보는 단어들도 보입니다.컴파일된 바이트코드우리가 작성한 코드는 고수준 프로그래밍 언어로 작성된 “소스코드” 라고부릅니다.위 사진에서 가장 처음에 시작하는 부분입니다.그리고 이것을 자바 번역기가 중간형태의 이진코드로 변환시킵니다.여기서 자바 번역기는 자바 컴파일러를 의미 합니다.그리고 이런 이진코드의 파일을 .class 라는 바이너리형식으로 저장합니다.이런 class파일을 컴파일된 바이트코드라고 합니다.그리고 이러한 class 파일을 JVM의 인터프리터 or JIT(just in time)컴파일러에 의해 실행됩니다.인터프리터? JIT?인터프리터는 생각보다 가까운 개념입니다.고수준 언어로 작성된 프로그램을 한 줄씩 읽고 해석하여 실행하는 프로그램입니다.이는 컴파일러와 대비되는 개념으로, 컴파일러가 전체 소스 코드를 기계어로 번역한 후 실행하는 것과는 다릅니다.즉, 전체코드를 읽는 컴파일러 보다 빠른 속도로 프로그램을 실행시킬 수 있습니다.대표로 Python , javaScript 가  사용하고 있습니다.그리고 이런 언어들은 스크립트 언어라고 부릅니다.이런 언어들은 컴파일 과정 즉, 기계어를 생성하는 과정을 스킵 하고 바로 메모리에 적재하기 시작합니다. 물론 이런 과정이 불안하기 때문에 각 언어마다 해결법들을 만들었는데 관련 포스트를 적으면 정리해보겠습니다.최근 웹에서도 Flask , Django 가 선호되고 Node js , 혹은 프론트엔드에서도 많이 사용되는 이유입니다.당연히 Java와 같은 언어들에 비해서 성능도 안정성도 떨어집니다.Python을 다루어 보면 실행 시작에서는 오류를 내지 않아도 올라가서 실행하다 보면 오류가 나는 경우가 많은 것처럼 강력한 검사를 하지 않기 때문입니다.최근 트렌드에 대한 생각하지만 개인적인 생각은 최근에는 관련 언어들의 발전이 계속 이루어지고대규모 시스템 구축을 하거나 정부 과제를 수행하지 않는 업체들에서는 이런 가벼운 언어로 빠르게 개발하고 레거시 하는 과정을 더욱 선호 하는 거로 보입니다.취업정보 사이트에 들어가 보면 생각보다 Node.js나 Python 개발자들을 많이 뽑는게 그런 이유여서 라고 생각합니다.특히 , 최근 트랜드인 MSA - 마이크로 서비스 아키텍처에서는 작은 어플리케이션을 여러개 만들어서 논리적으로 이어놓는것을 추구하고 있기 때문이기도 한 것 같습니다.JIT  (Just in Time)  바이트코드 해석: JVM(Java Virtual Machine)은 바이트코드를 인터프리터를 사용하여 한 줄씩 해석하고 실행합니다.  실행 주기 모니터링: JVM은 프로그램의 실행 중에 어떤 부분이 자주 실행되는지 모니터링합니다.  컴파일 결정: JIT 컴파일러는 실행 주기 모니터링을 기반으로 하여 자주 실행되는 부분이나 코드 루프 등을 선택하여 컴파일할지 결정합니다.  컴파일: JIT 컴파일러는 선택된 부분을 기계어로 변환하여 네이티브 코드로 생성합니다.  캐시 및 재사용: 생성된 네이티브 코드는 캐시에 저장되어 이후에 동일한 부분이 실행될 때 재사용됩니다.JIT 는 이런식으로 동작합니다.해석 → 자주 나타나는 부분 분석 → 컴파일 결정 → 기계어 생성 → 기계어를 캐시에 저장해두기여기서 인터프리터를 사용하는 과정이 나옵니다.그리고 이러한 JIT는 장점이 있는데 정리하면 다음과 같습니다.  실행 시간 최적화: JIT 컴파일러는 실행 중에 프로그램의 성능을 분석하고 최적화할 수 있습니다. 이는 실행 시간에 최적화된 코드를 생성하여 프로그램의 실행 속도를 향상시킵니다.  메모리 사용량 최적화: JIT 컴파일러는 프로그램의 실행 중에 필요한 부분만 컴파일하고 메모리에 저장합니다. 따라서 불필요한 코드를 메모리에 로드하지 않아 메모리 사용량을 최적화할 수 있습니다.  플랫폼 독립성 유지: JIT 컴파일러는 바이트코드를 실행 중에 네이티브 코드로 변환하기 때문에, 플랫폼 독립성을 유지하면서도 실행 시간에 최적화된 코드를 생성할 수 있습니다.참 재미있는 방식입니다. 지금 이 순간의 최적의 방법을 찾아 시간과 메모리를 최적화 시키는 방법은 자바를 더욱 매력적인 언어로 만든 장점이라고 보입니다.정리하며이번 포스트에서는 자바의 구동과정에 대해 정리해 봤습니다.“JVM은 가비지 컬렉션을 통해 메모리를 자동으로 관리합니다.”이부분을 보면 가비지 컬렉션이 뭐지? 라고생각해볼 수 있습니다. 그래서 다음 포스트 에서는자바가 메모리를 사용하는 이야기를 하며 가비지 컬렉션에 대한 이야기도 함께 해보겠습니다.다음 포스트자바의 메모리 사용과 가비지 컬렉션"
  },
  
  {
    "title": "JAVA에 대하여 - 객체",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4/",
    "categories": "java",
    "tags": "java, OOP, 객체, Object",
    "date": "2024-01-04 06:44:00 +0900",
    





    
    "snippet": "객체 와 동작에 대한 이야기이번 포스트에서는 객체에 대해 이야기 해보겠습니다.필자 개인적으로 객체는 이해했다고 생각하면 뭔가 틀리는 경우도 있어서 이번 포스트를 적어보며 정리하는 시간을 가져봅니다.객체?자바에서 객체지향은 매우 중요한 개념입니다.객체 지향 즉, 객체를 만들어서 사용하는것을 지향한다. 인데여기서 객체를 정리해보면 이렇습니다.객체(Obje...",
    "content": "객체 와 동작에 대한 이야기이번 포스트에서는 객체에 대해 이야기 해보겠습니다.필자 개인적으로 객체는 이해했다고 생각하면 뭔가 틀리는 경우도 있어서 이번 포스트를 적어보며 정리하는 시간을 가져봅니다.객체?자바에서 객체지향은 매우 중요한 개념입니다.객체 지향 즉, 객체를 만들어서 사용하는것을 지향한다. 인데여기서 객체를 정리해보면 이렇습니다.객체(Object)는 클래스(Class)의 인스턴스(Instance)클래스란, 객체와 행위가 합쳐진 공간입니다. 템플릿을 의미 합니다. 빗대어 표현하면 ‘틀’ 이라고 표현할 수 있습니다.인스턴스란, 클래스의 속하는 실제하는 객체 즉, 진짜 메모리에 할당 되어있는 객체를 말합니다.즉, 객체라는 것은 실제하는 메모리에 들어있는 데이터 그리고 함수의 집합입니다.자바에서는 함수를 메서드 라고 표현합니다.정리하면객체 = 데이터 + 메서드라고 표현해볼 수 있습니다.붕어빵틀과 붕어빵필자는 컴퓨터공학관련된 전공을 하여 자바를 배울 수 있는 수업이 있었습니다.객체와 Class의 관계를 이해하는 것이 자바를 배우는 첫번째 걸음인데여기서 교수님께서는 이렇게 빗대어 표현하시더군요Class는 붕어빵틀 , Object는 붕어빵그때는 Class가 하나의 틀 이니까 객체를 생성하는 의미로 받아들였습니다.그런데 관련 저서를 읽다 보니 좀 더 구체적인 표현으로는정확히 Class는 붕어빵 틀이 이 아닌 형상틀 이다.인상적인 표현이였습니다. 생각해보면 Class는 여러 방식과 종류로객체를 만들어 낼 수 있고 붕어빵틀과 붕어빵은 클래스와 객체의 개념을 제한한다는 이야기로 받아들여 지기 때문입니다.물론 교수님께서는 학생들에게 쉽게 이해 시키기 위한 표현 이였지만, Java 개발자로써 목표를 삼고 있는 사람에게는 꽤 생각해 볼 이야기였습니다.Class는 청사진 , Object는 결과물이렇게 표현해 보는 것이 더 정확하게 표현할 수 있다고 생각합니다.객체의 특징객체의 특징을 보면 이런 이야기를 하고 있습니다.  속성과 동작: 객체는 데이터를 나타내는 속성(또는 멤버 변수)과 데이터를 처리하는 동작(또는 메서드)을 가집니다. 예를 들어, 자동차 객체는 속성으로는 색상, 속도, 모델 등을 가지고 있고, 동작으로는 주행, 정차, 가속 등을 수행할 수 있습니다.  상태와 행위: 객체는 상태(State)와 행위(Behavior)를 가집니다. 상태는 객체의 속성을 나타내며, 행위는 객체가 수행하는 작업을 나타냅니다. 이를 통해 객체는 자체적으로 데이터를 저장하고 관리하며, 필요한 작업을 수행할 수 있습니다.  캡슐화: 객체는 데이터와 해당 데이터를 처리하는 메서드를 하나의 단위로 묶어 캡슐화(Encapsulation)됩니다. 이를 통해 객체의 내부 구현을 외부에 숨기고, 객체 간의 상호 작용을 쉽게 관리할 수 있습니다.  상속: 객체는 다른 객체로부터 상속을 받아 기능을 확장할 수 있습니다. 상속을 통해 기존 클래스의 속성과 메서드를 재사용하고, 새로운 기능을 추가하여 코드를 확장할 수 있습니다.  다형성: 객체는 같은 이름의 메서드를 호출할 때 다양한 동작을 수행할 수 있습니다. 이를 다형성(Polymorphism)이라고 하며, 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.정리하면, 객체는 속성과 동작 그리고 이것을 다루면서 상태와 행위로써 볼 수 있습니다.객체는 캡슐화하여 데이터를 숨기고 , 동작하며 상속 받고 다형성을 구현할 수 있다. **그리고 이것이 바로 객체 지향 (OOP)의 중요 개념으로써 이야기 됩니다.OOP의 대하여객체 지향 프로그래밍(Object-Oriented Programming, OOP) 는 아래와 같은 특징을 가집니다.잘 읽어보면 결국 객체를 잘 만들고, 활용하기 위해 이런 방식으로 지향해라 , 개발해라 라는 의미인 것을 알 수 있습니다.  캡슐화 (Encapsulation):          캡슐화는 객체의 속성(데이터)과 행위(메서드)를 하나로 묶고, 외부에서의 직접적인 접근을 제한하는 개념입니다.      객체의 내부 구현은 외부로부터 숨겨지고, 오직 공개된 인터페이스를 통해서만 접근할 수 있습니다.      이를 통해 객체의 내부 구현을 보호하고, 안정성과 유지보수성을 높일 수 있습니다.        상속 (Inheritance):          상속은 기존 클래스의 속성과 메서드를 재사용하여 새로운 클래스를 정의하는 개념입니다.      상속을 통해 코드의 재사용성을 높일 수 있으며, 기존 클래스의 기능을 확장하여 새로운 기능을 추가할 수 있습니다.      상속을 통해 코드의 중복을 줄이고, 유지보수성을 높일 수 있습니다.        다형성 (Polymorphism):          다형성은 같은 이름의 메서드나 연산자를 다양한 방식으로 동작하도록 하는 개념입니다.      다형성을 통해 여러 객체를 하나의 타입으로 다룰 수 있으며, 객체의 실제 타입에 따라 다른 동작을 수행할 수 있습니다.      다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.        추상화 (Abstraction):          추상화는 객체에서 공통된 특성을 추출하여 모델링하는 개념입니다.      객체 지향 프로그래밍에서는 추상 클래스나 인터페이스를 사용하여 추상화를 구현합니다.      추상화를 통해 복잡한 시스템을 단순화하고, 핵심적인 부분에 집중할 수 있습니다.      여기서 캡슐화 ,상속, 다형성은 자바를 통해 개발하다 보면 자주 접할 수 있습니다.예를 들어 캡슐화는 접근제어자를 통해 이야기 해볼 수 있습니다.접근제어자? 그게뭔데Publicpublic class MyClass {    public int publicVar;    public void publicMethod() {        // 모든 클래스에서 접근 가능합니다.    }}protectedpublic class MyClass {    protected int protectedVar;    protected void protectedMethod() {        // 동일 패키지 내의 클래스와 해당 클래스를         // 상속받은 외부 패키지의 클래스에서 접근 가능합니다.    }}privatepublic class MyClass {    private int privateVar;    private void privateMethod() {        // 해당 클래스 내에서만 접근 가능합니다.    }}함수 앞에 적거나 변수 앞에 적어서 Scope를 표현하는 자바의 기술 중 하나입니다.즉, 캡슐화라는 것은 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶고, 외부에서의 직접적인 접근을 제한하는 것을 의미합니다.만약 다른 Class에서 private으로 선언한 함수를 부른다면? 찾지 못하고 오류를 낼 것입니다.이런식으로 접근을 제어해 캡슐화 시켰다는 개념을 이해해 볼 수 있습니다.상속과 다형성일단, 상속은  말그대로 받아오는 것 입니다. 코드로 이해하는 것이 훨씬 편한데// 부모 클래스class Vehicle {    String brand;    int year;    void honk() {        System.out.println(\"Tuut, tuut!\");    }}// 자식 클래스class Car extends Vehicle {    int wheels;    void describe() {        System.out.println(\"This car is a \" + brand + \" manufactured in \" + year + \" with \" + wheels + \" wheels.\");    }}// 메인 클래스public class Main {    public static void main(String[] args) {        Car myCar = new Car();        myCar.brand = \"Toyota\";        myCar.year = 2022;        myCar.wheels = 4;        myCar.describe(); // 출력: This car is a Toyota manufactured in 2022 with 4 wheels.        myCar.honk();     // 출력: Tuut, tuut!    }}보시는 것처럼 부모 클래스에는 큰틀이 자식 클래스에서는 자세한 데이터를 담아 두고 표현한 다는 것이죠.사람으로 비유하면? 부모 클래스는 사람 자식 클래스는  양세진, 김연아, 손흥민 등으로 만들어 볼 수 있습니다.다형성(Polymorphism)은 동일한 이름의 메서드나 연산자가 여러 클래스에서 다양한 방식으로 동작하는 것을 의미합니다.자바에서 다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.여기에는 오버로딩은 같은 이름의 메서드가 매개변수의 개수나 타입에 따라 다르게 동작하는 것을 말하며, 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의하여 다양한 동작을 구현하는 것을 말합니다.말은 어려운데 쉽게 이해해서 위 상속의 개념에서 여러 클래스로 나누어 다양한 함수 , 변수를 담는다 라는 의미입니다.// 부모 클래스class Animal {    void makeSound() {        System.out.println(\"Some sound\");    }}// 자식 클래스 1class Dog extends Animal {    @Override    void makeSound() {        System.out.println(\"Bark\");    }}// 자식 클래스 2class Cat extends Animal {    @Override    void makeSound() {        System.out.println(\"Meow\");    }}// 메인 클래스public class Main {    public static void main(String[] args) {        Animal myDog = new Dog(); // 다형성을 활용하여 Dog 객체를 Animal 타입으로 선언        Animal myCat = new Cat(); // 다형성을 활용하여 Cat 객체를 Animal 타입으로 선언                myDog.makeSound(); // 출력: Bark        myCat.makeSound(); // 출력: Meow    }}코드로 보면 훨씬 직관적으로 이해 할 수 있습니다.추상화? 뭐지?추상화 (Abstraction)를 만약 개발자가 아닌 사람들에게 물어보면 어떻게 대답할까요?아마 피카소를 떠올리며 이상하게 생긴 그림? 정도로 생각할 것입니다.사전에서는 • 미술에서 추상화(抽象畫)는 대상의 구체적인 형상을 나타낸 것이 아니라 점, 선, 면, 색과 같은 순수한 조형 요소로 표현한 미술의 한가지 흐름이다.그럼 추상이란?“추상”이라는 용어의 사전적 의미는 “사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것” 이라 정의한다.라고 이야기합니다. 즉, 어떤 특징을 가져와서 부각 시켜 표현하는 것을 의미합니다.우리가 알아야하는 추상화도 같은 논리입니다.설계를 하며 공통된 특징을 찾아 추출해 이것을 인터페이스 혹은 추상 클래스 로써 만든다.결국  부각시킬 부분을 찾아내 이것을 표현한다 라고 이해 해볼 수 있습니다.정리하며오늘은 자바의 객체에 대해 공부하고 이해한 내용을 정리해봤습니다.특징에 대한 이해를 해보려 노력했는데 제 비유가 잘 이해 되실지 모르겠지만,다양한 블로그나 유튜브에서도 좋은 정보들이 많기 때문에 참고해보시면 도움이 될 거같습니다.다음 포스트자바 환경에 대한 이야기를 해보려고 합니다."
  },
  
  {
    "title": "JAVA에 대하여 - 서론",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%9C%EB%A1%A0/",
    "categories": "java",
    "tags": "java, OOP, 언어의 역사",
    "date": "2024-01-03 06:44:00 +0900",
    





    
    "snippet": "들어가며JAVA에 대해 공부하며 배운 것들을 정리하고 생각한 것들을 정리하는 포스트 입니다.개발자들이 많이 사용하는 언어가 궁금해 찾아보다 해당 사이트를 확인했습니다.https://www.tiobe.com/tiobe-index/Python , c 계열 , 자바 가 50 퍼센트 가량 비율을 차지하고 있습니다.특히, 대한민국에서는 정부 공식 프레임워크로 ...",
    "content": "들어가며JAVA에 대해 공부하며 배운 것들을 정리하고 생각한 것들을 정리하는 포스트 입니다.개발자들이 많이 사용하는 언어가 궁금해 찾아보다 해당 사이트를 확인했습니다.https://www.tiobe.com/tiobe-index/Python , c 계열 , 자바 가 50 퍼센트 가량 비율을 차지하고 있습니다.특히, 대한민국에서는 정부 공식 프레임워크로 Spring기반을 사용하기 때문에 비중도가 높습니다.Python 의 경우 웹개발자 뿐만 아니라 AI , IOT등 차세대 분야에서도 많이 사용되고 있고 , 처음 언어를 공부할 때 편리하게 접근할 수 있어 높은 Ratings를 보여줍니다. 또한, 컴퓨터 공학을 전공하지는 않았지만 많은 관련업의 종사하시는 분들이 개발 언어로써 사용하고 있고, 그만큼 많은 라이브러리가 있다는점도 장점으로 들 수 있어 1위를 할 수 있는 것 같습니다.미국 정부에서는 C계열언어보다 Rust를 사용하라는 지침이 나오고 있어 Rust의 비중도 50위권 안으로 들어온 점이 인상적 입니다.왜 자바를 사용할까?자바는 C 보다는 늦게 나왔지만 꽤 나 오래된 언어입니다. 그럼에도 현재까지 많은 개발자들이 애용하고 있습니다. 많은 이유가 있겠지만 개인적인 생각을 적어보려고 합니다. 일단 Java가 나온 이유가 상당히 재밌기 때문에 소개하겠습니다.언어의 역사초창기 C 언어는 어셈블리어를 수학적으로 프로그래밍하기 위해 나왔습니다.그리고 JAVA는 C 에서 부족한 부분을 업그레이드 하기 위해 나온 언어입니다.어셈블리어는 실제로 다루어보면 꽤 나 직관적으로 이해할 수 있습니다.section .data    A dd 10       ; A 변수에 10 할당    B dd 20       ; B 변수에 20 할당    C dd 0        ; C 변수 초기화section .textglobal _start_start:    ; A와 B 값을 더하여 C에 저장    mov eax, dword [A]  ; A 변수의 값을 레지스터 eax로 로드    add eax, dword [B]  ; B 변수의 값을 더함    mov dword [C], eax  ; 결과를 C 변수에 저장    ; 프로그램 종료    mov eax, 1          ; 시스템 콜 번호 1 (프로그램 종료)    xor ebx, ebx        ; 종료 코드 0    int 0x80            ; 시스템 콜 호출    흔히 사용하는 고수준 프로그래밍 언어 (자바 , 파이썬등) 만 배워본 사람이라면 엥? 이라는 생각이 듭니다. 하지만 잘 보면 수도 코드를 규칙에 맞게 적어 놨다는 느낌을 받을 수 있습니다.A ,B , C 변수를 선언하고 함수로 저장 하는 과정을 만들어 놓은 것입니다.필자 또한 18학번이기 때문에 굳이? 어셈블리어를 따로 공부해본 경험은 없고 네트워크 수업을 들으며 어떤 식으로 되는지 이해한 정도가 전부입니다.하지만, 이해하기 어려운 이유는 어셈블리어는 저수준 프로그래밍 언어입니다.여기서 수준의 의미는 사람이 더 쉽게 이해할 수 있느냐 즉, 자연어로 이해하기 쉽냐는 의미입니다.메모리 위치나 명령어를 직접 코딩해서 동작 과정을 만들어 내야 하는 일이기 때문에 매우 귀찮지만 천천히 생각해보면 단순히, A를 저장 B를 더함 결과 C에 저장 하는 일을 하고 있습니다.만약 해당 코드를 자바로 코딩하면 어떨까요?public class Main {    public static void main(String[] args) {        int A = 10; // A 변수에 10 할당        int B = 20; // B 변수에 20 할당        int C;      // C 변수 선언        // A와 B를 더하여 C에 저장        C = A + B;        // 결과 출력        System.out.println(\"A + B = \" + C);    }}이렇게나 쉽고 빠르게 이해할 수 있습니다.이것이 수학적 프로그래밍이 필요한 이유라고 생각합니다. 하나하나 글로 설명하는 것보다 수식으로 딱 정리하면 훨씬 간단하니까요C에 대하여컴퓨터가 발명되고 얼마 안된 초창기 개발자들은 기계어 자체를 다루었고 (천공판)이후 개발자들은 어셈블리어로 처리 하였습니다.이때 당시에는 가능했던게 하드웨어의 발전이 아직 부족했기 때문에 큰 메모리를 가지기 어렵고 비쌌기 때문에 지금으로 치면 펌웨어가 동작하는 수준에 코드면 만족스러웠습니다. 즉, 어셈블리어로도 충분히 시간내에 개발이 가능하였습니다.하지만 하드웨어가 발달하고 시장이 커지면서 여러 기능들을 더욱 많이 탑재 해야했고, 어셈블리어로 작업하는 것은 매우 매우 고된 일 이였을 겁니다. (마치 Linux에서 vim 편집기를 쓰는 듯한)그래서 나온게 C 라는 언어입니다.  추상화 수준:          어셈블리어: 어셈블리어는 기계어에 가깝고, 컴퓨터의 하드웨어와 직접적으로 상호작용합니다. 명령어와 레지스터, 메모리 주소 등을 직접 다루기 때문에 하드웨어의 세부 사항을 명확하게 이해해야 합니다.      C: C는 어셈블리어에 비해 더 고수준의 언어입니다. 추상화 수준이 높아서, 개발자가 하드웨어의 세부 사항을 몰라도 프로그래밍할 수 있습니다. 또한, 포인터와 같은 고급 기능을 제공하여 메모리와의 상호작용을 추상화합니다.        가독성 및 이식성:          어셈블리어: 어셈블리어 코드는 기계어에 가까워서 읽기 어렵고 이해하기 어렵습니다. 또한, 어셈블리어 코드는 특정 CPU 아키텍처에 종속적이기 때문에 다른 아키텍처로 이식하기 어렵습니다.      C: C는 읽기 쉽고 이해하기 쉬운 문법을 가지고 있어서 가독성이 뛰어납니다. 또한, C는 플랫폼 독립적이기 때문에 다양한 운영체제와 하드웨어에서 실행될 수 있습니다.        개발 생산성:          어셈블리어: 어셈블리어는 하드웨어의 세부 사항을 직접 다루어야 하므로 개발 생산성이 낮습니다. 또한, 고급 작업을 수행하기 위해서는 많은 코드와 복잡한 로직이 필요합니다.      C: C는 저수준 프로그래밍 언어 중에서는 상당히 높은 개발 생산성을 제공합니다. 고급 작업을 수행하기 위한 라이브러리와 함께 사용되며, 하드웨어와의 상호작용을 추상화하여 개발자가 더 빠르게 프로그램을 작성할 수 있습니다.      정리하면 혁명이 일어났다고 해도 과언이 아닙니다.그럼 자바는 왜 필요한가?  플랫폼의 종속성                  지금은 플랫폼 시장이 많이 정리되었습니다. 큰 회사가 작은회사들을 인수하며 특정 좋은 부분들을 뽑아 자신의 것들과 합쳐 업데이트 했으니까요.        하지만 C 가 나온 시점은 많은 플랫폼들이 춘추 전국시대 처럼 꿈을 안고 도전하고 있었습니다. 하지만 C는 개발했던 플랫폼의 종속되기 때문에 모든 플랫폼에 맞춰 개발해야하는 문제점이 발생하게 됩니다.        예를 들어 윈도우에서 개발한 C 제품은 MAC OS에서는 동작하지 않는 것과 같은 이유입니다.        그래서 자바가 등장한 이유 입니다.        자바는 JVM , JAVA vaulture Machine을 사용합니다. 자바 가상 기계라고 하는데 책을 읽어보면 한세월 걸리지만 간단하게 설명하면 실생활에 있는 하드웨어와 같은 이치입니다.        자바를 위한 , 자바 만을 위한 플랫폼을 가상의 기계에서 만들어 내는 겁니다.              안전성과 보안                  필자는 C언어를 군대를 제대한 후 2학년 때 처음 배웠습니다. 열심히 살아야 된다는 생각때문인지 학점도 열심히 관리하고 공부도 하며 지냈을 때 입니다. 처음 강의를 들을 때는        ‘음 따라갈 만 하네’ 라고 생각하다 포인터라는 놈이 등장하면서 정신이 아늑해졌습니다.        포인터는 말 그대로 가르키는 녀석입니다. 어떤 변수의 값이 저장 되어 있는 메모리의 위치 주소를 가르킨다. 가 핵심인데 문제는 조건도 많고, 포인터 연산이라는 개념 때문에  많은 친구들이 전과를 심각하게 고려하는 시기였기도 합니다.        ### 어려워도 잘 쓰면? 좋은거 아님?        맞습니다. C는 직접 메모리 접근을 허용하기 때문에 수준 높은 개발자가 충분한 이해도를 가지고 개발을 하면 매우 성능 좋은 제품을 개발할 수 있습니다.        다른 이야긴 하지만 슈퍼마리오 개발지를 유튜브에서 본적 있는데 저는 이걸 보고 포인터가 생각이 났습니다.                아주 오래된 게임인 슈퍼마리오를 개발 할 때 매우 적은 메모리에 많은 내용을 담기 위해 개발자들이 고군분투하여 대단한 성능을 구현해 낼 수 있었습니다.        하지만 하드웨어가 매우 빠르게 발전함에 따라 드는 의문이 발생합니다.        “그거 고민할 시간에 좀 더 좋은 사양쓰고 , 코드 한줄 더 적는게 이득아님?”        그래서 JAVA는 포인터와 해당 연산의 개념을 지우고 자동으로 메모리를 관리할 수 있게 하였습니다.        또한, 아주 고급 개발자가 아닌 이상 사람이기 때문에 실수 하고 결국 이는 메모리 누수로 이루어 지기 때문에 JAVA 버전이 올라감에 따라 더욱 이유가 부각되고 있습니다.        즉 정리하면, 하드웨어가 발전함에 따라 예전보다는 치밀한 관리가 필요하지 않기 때문에 기계에게 자동으로 맡겨 두는게 이득이다! 라고 자바 개발자는 생각했던 것 같습니다.              객체 지향 프로그래밍                  자바의 꽃 , 핵심 객체 지향입니다. 약어로 OOP 라고도 부릅니다.        사실 C 도 C++을 쓰거나 지금의 C는 객체 지향적으로 프로그래밍이 충분히 가능합니다.        하지만 자바는 객체 지향적으로  프로그래밍을 할 수 있도록 유도합니다.        가장 대표적으로 자바의 4원칙 (다른 포스팅에서 이야기할 것입니다.)        Class와 객체 입니다.        자바의 모든 것은 객체이고 객체가 아니면 존재할 수 없도록 해놨습니다.        처음 이런 개념을 접했을때 필자는 이렇게 생각했습니다.        “그럼 다른 언어는 왜쓰냐? 업그레이드 버전이있는데?”        그럼 자바는 이전 프로그래밍 방식을 완전히 벗어나 혁명적인 업그레이드 이냐? 아닙니다. 이전 개발 방식은 절차적/구조적 프로그래밍 입니다.        그럼 그게 뭐냐? 개념적으로 설명하려면 한 세월이지만 필자 개인적인 생각으로는        “함.수.써.라”입니다. 왜? 중복코드 관리해야하니까        이것이 절차적/구조적 프로그래밍의 핵심이라고 생각합니다.        그럼 자바는 함수 안쓰냐? 씁니다. 이외에도 정말 많은 개념이 녹아있습니다.        즉, 자바가 강조하는 객체 지향은 기존 방식의 업그레이드 버전입니다.        객체지향에 대한 이야기도 다음 포스트에서 다루고 이런게 있다 정도로 마무리하겠습니다.            다음포스트java가 동작하는 방식에 대해 설명해보겠습니다 !"
  },
  
  {
    "title": "Git 사용법 - 세팅",
    "url": "/posts/Git%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95/",
    "categories": "Git",
    "tags": "Git, Github, git",
    "date": "2024-01-02 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 에서는 설정을 할것입니다.레포지토리를 만들어 업로드하는 과정들은 워낙 정보가 많으니 실제로 사용하는 법을 보여드리겠습니다.예를들어 git add -A , git commit -m “first” 이런 코드들을 주는 것은 대체 블로그가 많습니다.저는 이렇게 사용합니다.최근 IDE 가 발달하고 Git을 대부분 지원하기 때문에 딸깍 몇번 ...",
    "content": "들어가며이번 포스트 에서는 설정을 할것입니다.레포지토리를 만들어 업로드하는 과정들은 워낙 정보가 많으니 실제로 사용하는 법을 보여드리겠습니다.예를들어 git add -A , git commit -m “first” 이런 코드들을 주는 것은 대체 블로그가 많습니다.저는 이렇게 사용합니다.최근 IDE 가 발달하고 Git을 대부분 지원하기 때문에 딸깍 몇번 이면 알아서 해줍니다.그래서 굳이? shell명령어를 입력 해야하나? 라고 생각해볼 수도 있습니다.그렇지만 필자는 클라우드 서버환경 예로, AWS ,GCP 에서 서버를 만들고 입력할 때는 알고 있어야 편하게 작업할 수 있어서 공부하였습니다.그래서 로컬말고 클라우드 서버에서 진행해보겠습니다!로컬에서 사용중인(개발자 개인컴퓨터) IDE 와 서버를 연결하는 방법이 다양합니다. 이후에 관련된 포스트를 적어보겠습니다.다음 머릿말 전까지는 GCP 설정에 대한 이야기 입니다.일단 우분투 서버를 하나 준비해보겠습니다.최근에 GCP에 대해 공부하고 있어서 무료 크래딧이 많은 관계로 GCP에서 서버를 하나 가져와보겠습니다.일단 GCP에 들어가서 서버를 하나 무료로 만들어보겠습니다.여러가지 설정을 할 수 있는데  이후에 GCP에 대해 포스트 할때 더 자세히 이야기 해보겠습니다.일단은 우분투로 서버 이미지를 선택해서 하나 만들어보겠습니다.이름을 지정하고 서버 이미지를 선택합니다.실제로 서버에서 사용해보겠습니다.일단 GCP는 브라우저 창에서 SSH로 바로 연결해주는 서비스가 매우 잘되어있어서 클릭후 들어와 보겠습니다. (AWS 도 있습니다.)이런 환경에서는 Git 명령어를 잘 알아야 쓸 수 있겠죠일단 관리자 권한과 업데이트를 진행합니다.sudo su #관리자권한 -&gt; 실제 사용하는 서버는 비밀번호를 설정해둡니다.sudo apt update #업데이트Git 을 다운받아줍니다.apt install git # 인스톨해주고git --version #확인해줍니다.그러면 git 을 연결해 봅시다.먼저 포함된 레포지토리를 하나 작성해줍니다.그다음 https 가 포함된 URL을 복사해줍시다.이제 서버에서 아래처럼 입력하면 됩니다.git clone &lt;레포지토리 주소&gt;잘 들어온 것을 확인할 수 있습니다. 이것을 clone 즉, 복사해오는 방법입니다.전 포스트에서 설명하였는데 , git을 쓰는 목적중 분산저장소 라는 개념이 이런 식으로 사용됩니다.Repository에 아무것도 없는 환경에서 git 사용설정들을 여러가지 해야 하고 , 보통 로컬 환경에서 코딩 및 검수를 끝내고 Demo 정도가 되었을 때 서버에 Setting해서 개인적으로 자주 사용하는 방법은 아닙니다.사실 비용 때문에 최대한 늦게 합니다..zz(서버에 올릴때는 코드가 이미 존재하고 , 개발하면서 서버에 올려두면 서버 비용이 나가서..)하지만 생각보다 어렵지 않습니다. 아래 방법을 설명해보겠습니다.      사용자 정보 설정:Git을 사용하기 위해 사용자 이름과 이메일 주소를 설정해야 합니다. 이 정보는 커밋할 때 사용됩니다.     git config --global user.name \"Your Name\" git config --global user.email \"your_email@example.com\"            Your Name에는 사용자의 실제 이름을, your_email@example.com에는 사용자의 이메일 주소를 넣어주세요.        설정 확인:설정이 올바르게 되었는지 확인하기 위해 설정을 출력할 수 있습니다.     git config --list        이 명령어는 현재 Git의 전역 설정을 모두 보여줍니다.        초기화:Git 저장소를 초기화하려면 해당 디렉토리로 이동한 후 아래 명령어를 실행하세요.     git init        이 명령어는 현재 디렉토리에 새로운 Git 저장소를 만듭니다.  이제 이 명령어들을 사용하여 Git을 설정하고 초기화할 수 있습니다. 설정 후에는 파일을 추적하고 커밋할 수 있습니다. 필요에 따라 Git의 추가적인 설정도 있을 수 있습니다.추가 사항.. 3월 중순에 테스트해본 결과 비밀번호를 지원하지 않습니다.SSH 방법은 추후에 다시 작성 하겠습니다.다음 포스트설정을 완료 하였습니다. 다음 포스트 에서는 개념을 정리해보며 실제 사용법을 익혀보겠습니다."
  },
  
  {
    "title": "Git 사용법 - 서론&설치",
    "url": "/posts/Git%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%9C%EB%A1%A0&%EC%84%A4%EC%B9%98/",
    "categories": "Git",
    "tags": "Git, Github, git",
    "date": "2024-01-01 06:44:00 +0900",
    





    
    "snippet": "들어가며깃 , 깃허브는 개발자가 반드시 알아야 되는 필수 기술 중 하나라고 생각합니다.현재 개발자들이 애용하고 있고, 기업에서도 사용하고 있습니다.또한 , 많은 기능이 있어서 한 사이트 , 기술 스택에서 다양한 활동을 진행할 수 도 있습니다.포스트를 하며 여러 기술들에 대해 공부한 내용을 공유해 보려고 합니다.그래서 Git이 뭔데?Git 이란 버전관리...",
    "content": "들어가며깃 , 깃허브는 개발자가 반드시 알아야 되는 필수 기술 중 하나라고 생각합니다.현재 개발자들이 애용하고 있고, 기업에서도 사용하고 있습니다.또한 , 많은 기능이 있어서 한 사이트 , 기술 스택에서 다양한 활동을 진행할 수 도 있습니다.포스트를 하며 여러 기술들에 대해 공부한 내용을 공유해 보려고 합니다.그래서 Git이 뭔데?Git 이란 버전관리 시스템 (VCS,Version Control System) 중 하나입니다.즉 , 버전을 관리하는 시스템 → 변경사항을 저장하고 , 메시지와함께 기록해둘 수 있습니다.왜 쓸까?여러 이유가 있지만 가장 근본적인 이유는 위 설명한 코드를 기록하는데 있습니다.그 외에도 여러 기능이 있는데 필자가 생각했을 때 가장 핵심적인 요소들로 정리해봤습니다.  분산 시스템: Git은 분산 버전 관리 시스템입니다. 이는 모든 개발자가 로컬 저장소를 가지고 있고, 변경 사항을 서버에 반영하는 대신 로컬에서 변경 사항을 커밋할 수 있다는 것을 의미합니다.  브랜치: Git은 브랜치를 사용하여 개발 작업을 분리하고 병합할 수 있습니다. 이를 통해 여러 개발자가 동시에 작업할 수 있고, 기능을 개발하거나 버그를 수정하는 데 사용할 수 있습니다.  원격 저장소: Git은 원격 저장소를 사용하여 여러 사용자가 함께 작업하고 변경 사항을 공유할 수 있습니다. GitHub, GitLab, Bitbucket 등의 호스팅 서비스를 통해 원격 저장소를 만들고 관리할 수 있습니다.  병합: Git은 브랜치에서 작업한 변경 사항을 다른 브랜치로 병합할 수 있습니다. 이를 통해 여러 개발자가 작업한 변경 사항을 통합하고, 충돌을 해결할 수 있습니다.  추적: Git은 파일의 변경 이력을 추적하고, 누가 언제 어떤 변경 사항을 만들었는지 추적할 수 있습니다. 이를 통해 개발자는 변경 사항을 추적하고 필요한 경우 이전 상태로 돌아갈 수 있습니다.정리하면 로컬 , 원격 저장소에 저장 , 여러 가지로 저장 , 저장된 내용을 병합 추적이렇게 정리해볼 수 있습니다. **더 자세한 개념은 이후 포스트에서 사용할 때 함께 설명하겠습니다.진짜 왜 쓸까?위 내용은 개념적인 내용이고 GIT을 쓰기 시작한 이유를 체득한 이야기입니다.대학교 1학년 시절 진정한 코린이로써 과제를 풀기에도 급급할 때 입니다.수업 전까지 완성해야 제출할 수 있는데 술과 친구들이 너무 좋아 벼락 코딩을 하고 있습니다.열심히 코딩을 하며 한단계 두단계 나아가다 어느 순간 코드가 꼬였습니다.다시 찾으려 애를 쓰지만 마구잡이로 써놓은 코드들 덕분에 어디서 부터 문제인지 찾을 수가 없어..30분동안 돌려보며 찾아보지만 어디서 부터 문제인지 못 찾아 처음부터 다시 코딩을 시작합니다.이때 Git을 알고 있었다면 어땠을까요?커밋된 내용들을 쓱 보며 타임라인에서 제대로 된 코드부터 다시 시작해보거나 , 문제점을 바로 찾을 수 있을 겁니다.이게 제가 GIT을 알게된 후 열심히 사용하고 있는 이유입니다.또한, 팀과 일할 때는 여러 코드들이 꼬이고 병합하는 과정에서 코드끼리 기능상 문제가 생기는 경우도 많습니다. 이럴때는 잘 만들어둔 코드를 살리고 문제가 있는부분을 찾아내 고치는게 훨씬 빠르고, 쉽습니다.어떻게 쓸까?일단 깃을 설치해야 합니다. 설치 방법은 다음과 같습니다.필자는 windows 와 mac 환경에서 개발을 합니다.하지만 서버를 구성하는데는 ubuntu , Linux를 자주 사용하기 때문에 4가지 방법을 제시합니다.Windows:  공식 웹사이트에서 설치하기:          Git의 Windows 용 설치 프로그램은 Git 공식 웹사이트(https://git-scm.com/)에서 다운로드할 수 있습니다.      다운로드 및 설치 프로세스를 따라가면 됩니다.        Chocolatey를 사용하여 설치하기:                  Chocolatey를 설치한 후, 명령 프롬프트나 PowerShell에서 다음 명령어를 실행하여 Git을 설치할 수 있습니다:          Copy code  choco install git                    Linux:  패키지 관리자를 사용하여 설치하기:                  대부분의 Linux 배포판은 패키지 관리자를 통해 Git을 설치할 수 있습니다.                    예를 들어, Ubuntu/Debian에서는 다음 명령어를 사용합니다:          sudo apt update  sudo apt install git                    Ubuntu:  패키지 관리자를 사용하여 설치하기:                  Ubuntu에서도 패키지 관리자를 사용하여 Git을 설치할 수 있습니다.                    터미널에서 다음 명령어를 실행합니다:          sudo apt update  sudo apt install git                    macOS:  Homebrew를 사용하여 설치하기:                  Homebrew를 사용하여 macOS에 Git을 설치할 수 있습니다.                    터미널에서 다음 명령어를 실행합니다:          brew install git                    다음 포스팅설치가 완료되었다면 실제로 사용하는 법을 보여드리며 테스트를 진행해보겠습니다."
  }
  
]


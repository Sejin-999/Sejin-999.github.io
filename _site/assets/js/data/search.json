[
  
  {
    "title": "test 해보기",
    "url": "/posts/testPage/",
    "categories": "Blog",
    "tags": "Blog, jekyll, Github, Git",
    "date": "2024-03-18 06:44:00 +0900",
    





    
    "snippet": "목차  링크  목록  코드 블록  인용문  이미지링크구글에 가보세요.목록  항목 1  항목 2          하위 항목 1      하위 항목 2      코드 블록public class Main {    public static void main(String[] args) {        System.out.println(\"Hello, world!...",
    "content": "목차  링크  목록  코드 블록  인용문  이미지링크구글에 가보세요.목록  항목 1  항목 2          하위 항목 1      하위 항목 2      코드 블록public class Main {    public static void main(String[] args) {        System.out.println(\"Hello, world!\");    }}인용문  인용문입니다. 이것은 어떤 작가나 발언자의 말을 인용할 때 사용됩니다.이미지"
  },
  
  {
    "title": "자바에 대하여 - Hash에 대하여",
    "url": "/posts/Java-Hash/",
    "categories": "java",
    "tags": "java, Hash, HashNap",
    "date": "2024-01-31 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 에서는 Hash에 대하여 공부해볼 것입니다.Hash?고정된 크기로 값을 바꾸는 함수 or 알고리즘java에서 hash키와 값의 쌍을 저장하는 데이터 구조입니다.키는 고유한 식별자이며 값은 키와 연관된 데이터입니다.해시 테이블이라고도 불리는 해시 구조는 데이터 검색 및 삽입 속도가 매우 빠르다는 장점이 있습니다.어떤 키값을 통해 해시...",
    "content": "들어가며이번 포스트 에서는 Hash에 대하여 공부해볼 것입니다.Hash?고정된 크기로 값을 바꾸는 함수 or 알고리즘java에서 hash키와 값의 쌍을 저장하는 데이터 구조입니다.키는 고유한 식별자이며 값은 키와 연관된 데이터입니다.해시 테이블이라고도 불리는 해시 구조는 데이터 검색 및 삽입 속도가 매우 빠르다는 장점이 있습니다.어떤 키값을 통해 해시함수로 고정된 크기의 해시 값을 만들고 이 값으로 배열의 인덱스 , 위치 , 데이터 값을 저장하거나 검색할 때 활용합니다.해시 코드는 고정된 길이의 정수 값이며, 일반적으로 키의 일부 비트를 추출하거나 키를 제곱한 후 일부 비트를 추출하는 방식으로 계산됩니다.해쉬함수임의의 데이터를 고정된 길이의 값으로 리턴해주는 함수Array쓰면 되는거 아닌가?다른 블로그에서 hash에 대해 조사하다 보니 목차를 예시로 드는 경우가 있었습니다.사실 목차라는게 index이고 index 방식으로 자료를 정렬해서 찾아 내는건 Array도 유사하게 동작하는 방식이고 ,  array의 단점인 데이터 변경에 어려운점이 있다면 LinkedList 로 구현할 수 있기 때문입니다.그래서 굳이? hash가 필요한지에 대해 생각해봤습니다.HashMap의 내부구조는 배열로 되어 있고, Key는 직접 내부 배열의 인덱스가 될 수 있으며, 이를 버킷이라 한다. 키 값은 해사함수의 의해 생성된다.즉, 배열의 장점인 인덱스를 통한 빠르게 검색할 수 있다는 점과 가변 키를 사용해 수정/삽입이 용의한 자료구조이다.완전 탐색이 필요하지 않고 , 특정 부분의 변경을 저장할 때 용의하다.예를 들어 String 값을 기반으로 한 어떤 문제를 해결하려고 한다면 어떨까1. A B C2. A C두 개의 리스트값을 받아서 2번 리스트의 값들 중 1번에 없는 애들만 골라내는 방법을 구현하라고 생각해보겠습니다.boolean checkList [] = new boolean[1.length()]; for 0 -&gt; i i&lt;checkList.length(); i++ // 1번 리스트에 대한 for \t\tcheckList[i] = false;for 0 -&gt; i i&lt;1.length(); i++\t\tfor 0-&gt; j j&lt;2.length(); j++\t\t\t\tif(i == j){\t\t\t\t\tcheckList[i] = true;\t\t\t\t}int cnt = 0;for 0 -&gt; i i&lt;checkList.length(); i++\t\tif(checkList[i] == false)\t\t\t\tcnt++;\t\t\t\tchar resultList = new Chareters[cnt];int flag = 0;for 0 -&gt; i i&lt;checkList.length(); i++\t\tif(checkList[i] == false)\t\t\t\tresultList[flag++] = 1[i] ; 수도 코드로 간단하게 생각해보면 이런식으로 풀어낼 수 있을 것입니다.문제를 풀기 위해 상당히 많은 소요가 필요하고 코드도 비효율적으로 보일 수 밖에 없겠죠자바에서의 HashMap을 통해 풀어보면 다음과 같습니다.public static List&lt;Character&gt; findUniqueCharacters(List&lt;Character&gt; list1, List&lt;Character&gt; list2) {        if (list1 == null || list2 == null || list1.isEmpty() || list2.isEmpty()) {            throw new IllegalArgumentException(\"Input lists cannot be null or empty\");        }                HashMap&lt;Character, Integer&gt; charCounts = new HashMap&lt;&gt;();        for (Character ch : list1) {            charCounts.put(ch, 1);        }        List&lt;Character&gt; uniqueChars = new ArrayList&lt;&gt;();        for (Character ch : list2) {            if (!charCounts.containsKey(ch)) {                uniqueChars.add(ch);            }        }        return uniqueChars;    }딱 봐도 이해하기도 편하고 반복문이 많지 않기 때문에 쉽게 확인 할 수 있습니다.이런식으로 String값으로 표현된 경우 (위에는 편의상 charcter로 함) 훨씬 쉽게 문제를 풀어볼 수 있습니다.즉, 순서가 중요하지 않고 값이 중요한 경우에는 이런식으로 문제를 해결하는 것이 더욱 좋은 방법일 것입니다.해쉬의 장단점장점:  빠른 검색 및 삽입: 해시 테이블은 키 기반 데이터 검색 및 삽입 속도가 매우 빠릅니다. 평균적으로 O(1)의 시간 복잡도를 가지고 있습니다. 이는 다른 데이터 구조(예: 트리, 연결 리스트)에 비해 훨씬 빠릅니다. → 단, 모든 경우에서 충돌이 날 경우 O(n)임  효율적인 메모리 사용: 해시 테이블은 데이터를 밀집하게 저장하기 때문에 메모리 사용 효율이 높습니다.단점:  해시 충돌: 서로 다른 키가 동일한 해시 코드를 가질 경우 발생합니다. 해시 충돌을 해결하기 위해 다양한 방법들이 사용됩니다. 가장 일반적인 방법은 분리 연결법으로, 해시 코드가 동일한 키들을 연결 리스트에 저장하는 방식입니다. 해시 충돌이 발생하면 검색 및 삽입 성능이 저하될 수 있습니다.  해시 함수 의존성: 해시 테이블의 성능은 해시 함수의 질에 크게 의존합니다. 좋은 해시 함수는 키를 고르게 분산시키고 해시 충돌을 최소화해야 합니다.해쉬충돌 해결법1. 분리 연결법 (Separate Chaining)  동일한 해시 코드를 가진 키들을 연결 리스트에 저장합니다. → LinkedList  장점: 간단한 구현, 해시 충돌 발생 시 영향 범위 제한  단점: 연결 리스트 길이 증가 시 검색 성능 저하분리 연결법은 해시 충돌 발생 시 연결 리스트에 키-값 쌍을 추가하여 해결합니다. 연결 리스트는 동일한 해시 코드를 가진 키들을 순서대로 저장하는 구조입니다.이런식으로 충돌된 부분에 대해서 연결 리스트를 통해 값들을 저장하는 방법을 사용해 볼 수 있습니다.2. 오픈 주소법 (Open Addressing)  충돌 발생 시 다른 해시 버킷을 탐색하여 빈 공간을 찾습니다.  일반적인 오픈 주소법으로는 선형 탐색, 이중 해시, 재해시 등이 있습니다.  장점: 연결 리스트 사용에 비해 빠른 검색 성능  단점: 해시 충돌 발생 시 탐색 과정 필요, 일부 해시 버킷 집중될 수 있음오픈 주소법은 충돌 발생 시 다른 해시 버킷을 탐색하여 빈 공간을 찾아 키-값 쌍을 저장합니다. 탐색 방법은 다양하며, 일반적인 방법으로는 선형 탐색, 이중 해시, 재해시 등이 있습니다.둘다 해결법이지만 일반적으로 데이터양과 충돌횟수에 따라 구분해서 사용됩니다.데이터 와 충돌 횟수가 적은 경우 분리 연결법을 활용하는 것이 좋은 방법이지만,반대인 경우 오픈 주소법을 통해 새롭게 위치를 재 선택해주는 것이 선호됩니다.Hash Map - hash table일반적으로 hash 를 활용하는 기술 중 Hash Map 을 많이 사용하게 됩니다. 여기서 hash table을 통해 저장 방법을 선택합니다.여기서 동작원리에 대해 간단히 이해해 보겠습니다.어떤 값을 넣어주고 → 함수를 통해 해쉬값을 만들면 이값을 모드연산을 통해 인덱스로사용하는 것을 hashTable이라고 합니다.따라서 hashMap은 array자료구조를 가지게 되어서 자료를 찾는데 빠르게 접근할 수 있게 되는 것입니다."
  },
  
  {
    "title": "Spring - DI 에 대하여 간단 이해",
    "url": "/posts/Spring-DI/",
    "categories": "spring",
    "tags": "java, spring, ioc, DI",
    "date": "2024-01-30 06:44:00 +0900",
    





    
    "snippet": "들어가며이번포스트에서는 DI - Dependency Injection 에 대해서 알아보겠습니다.DI 는 의존성 주입으로 객체를 만들 때 객체를 통해 객체를 생성하는 것이아닌외부에서 객체를 생성해 사용한다는 개념에서 부터 시작합니다.객체를 사용하는 방법결국 차이점은 내부에서 만들어 하냐 - 외부에서 만들어서 주입을 받느냐의 차이점입니다.중요한 점은 왼쪽...",
    "content": "들어가며이번포스트에서는 DI - Dependency Injection 에 대해서 알아보겠습니다.DI 는 의존성 주입으로 객체를 만들 때 객체를 통해 객체를 생성하는 것이아닌외부에서 객체를 생성해 사용한다는 개념에서 부터 시작합니다.객체를 사용하는 방법결국 차이점은 내부에서 만들어 하냐 - 외부에서 만들어서 주입을 받느냐의 차이점입니다.중요한 점은 왼쪽과 같이 만들게 된다면 A 는 B 와 C 의 기능의 종속되게 되고,이러면 개발자가 해당 하는 객체에 라이프 사이클을 모두 신경써서 개발 해야합니다.만약 A에서 B , C 가 문제가 생기거나 수정 사항이 생기면 이를 제어하기 위해 A 객체 자체가 정상적으로 작동하지 않을 것입니다.예를 들어 객체 A를 결제프로세스 전체 라고 하고, B를 결제 , C를 로깅하는 메서드를 담고 있다고 가정해보겠습니다.만약 , C가 동작하는 중 장애가 발생하거나 소요시간이 오래 걸리게 되면 정상적으로 결제 자체가 정상적으로 동작하지 않을 것 입니다. - 일반적으로 nonException인 경우 장애가 발생하여도 선제처리가 되어있지 않다면 일단 올라는 가는데 동작이 원활히 되지 않을 것 입니다.이런 경우를 강한 결합 - 강결합 이라고 표현합니다. b,c에 의해 a가 종속되었다고 이야기할 수 있습니다.반대로 오른쪽에 경우 문제가 발생하여도 트랜잭션의 전파가 잘 처리되어 있다면 결제 자체는 정상적으로 작동하게 될 것입니다.이렇게 의존성을 줄일 수 있는데 이것을 약결합이라고 부릅니다.Spring이 관리해주는 약결합이런식으로 관리가 되어서 라이프 사이클을 직접 관리하지 않아도 되게 됩니다.그래서 이런식으로 코드를 작성하게 되는 것 입니다.private final PostReposioty postRepository = new PostRepository();이런 식으로 만드는 것이 아니라private final PostReposioty postRepository이렇게 주입 받아 만드는 것을 DI라고 하는데 이때 우리가 자주 보는 생성자를 통해 의존성을 주입하여 사용하게 됩니다.public PostService(PostRepository postRepository){\tthis.postRepository = postRepository;}변경사항이 있는 경우에는 강한 결합으로 작성 된 코드의 문제점이 발생되어 컴파일러에서 에러를 내줍니다."
  },
  
  {
    "title": "자바에 대하여 - String",
    "url": "/posts/Java-String-%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/",
    "categories": "java",
    "tags": "java, String, final, 불변객체",
    "date": "2024-01-28 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 자바에서 String 에 대해 이해해 보려고합니다.String은 기본적으로 제공되는 변수 - 원시타입들과는 다릅니다.원시타입기본적으로 제공 하는 변수형 들을 말합니다.정수 : btye short int long - 1 , 2 , 4 , 8 바이트로 이루어져있습니다.사용저는  특별한 제약조건이 있는 경우가 아니라면  int 와 ...",
    "content": "들어가며이번 포스트에서는 자바에서 String 에 대해 이해해 보려고합니다.String은 기본적으로 제공되는 변수 - 원시타입들과는 다릅니다.원시타입기본적으로 제공 하는 변수형 들을 말합니다.정수 : btye short int long - 1 , 2 , 4 , 8 바이트로 이루어져있습니다.사용저는  특별한 제약조건이 있는 경우가 아니라면  int 와 long을 사용하고 있습니다.int의 경우 21억 정도 까지의 값들을 저장할 수 있는데 만약 저장 될 값이20억이 넘어갈 것같은 경우에는 long으로 아닌 경우에는 int를 사용하고 있습니다.실수 : float Double  - 4 ,8문자 : char - 2논리 : boolean - 1이렇게 원시타입이 이루어져 있습니다.그리고 String은 불변하는 객체입니다.즉, 객체에 담기는 원시타입의 변수형 , 객체 자체인 String이 있게 됩니다.불변객체불변 객체는 객체 생성 이후에 내부 상태가 변하지 않습니다.일단 메모리를 할당 받고 나면 그 크기를 유지하게 되는데 새롭게 선언된 String의 경우힙 메모리의 StringPool이라는 공간에 저장되게 됩니다.만약 원시타입 , 혹은 참조되는 클래스의 더이상의 상속 , 변화를 금지하겠다는 의미를 넣고 싶으면final 키워드를 통해 만들 수 있습니다.예를 들어 스프링에서 서비스코드에서 레포지토리 클래스를 불러서 선언하면 이 이후에 서비스를 이용해 레포지토리를 직접 부르는 것을 금지하기 위해 final을 붙여서 참조하게 됩니다.이걸 왜쓰냐 라고 하면 사실 멀티 쓰레딩을 하게되거나 동기화 , 비동기화 과정 중 공유되는 자원으로 써 선택된 경우 이 값이 변화하는 것을 주의 깊게 생각해야합니다.만약, 값이 없어져 버리면 null 예외가 값이 넘어가면 indexOfArray 에러가 나는 것처럼 처리에 대한 깊은 고민이 필요한데 꼭 이런 생각이 필요하지 않은 부분이 있다면 final 키워드를 통해 동일한 값으로 반환되도록 하면 되기 때문입니다.따라서 이걸 통해 예외가 발생해도 다음 메서드 실행때는 동일한 기능을 수행 시킬 수 있습니다.근본적인 이유는 아닌데 GC - 가비지 컬렉션이 읽어야하는 객체의 수가 줄 기때문에 GC 수행시 소요시간이 줄어든다는 장점도 있습니다.그럼 String은 왜 불변객체임?1. 캐싱 기능에 의한 메모리 절약과 속도 향상- Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.2. thread-safe- String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.3. 보안기능- 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다.출처:https://dev-coco.tistory.com/153[슬기로운 개발생활:티스토리]String의 저장String을 선언하고 사용하는 방법은 크게 두가지가 있습니다.  new String 을 통한 선언  “” - 리터럴을 통한 선언두가지 방식 모두 장단점이 있는데 일단 비교하면서 생각해 보겠습니다.어디에 저장하냐new String - 객체로 생성 - 힙 영역에 만들어짐 - GC 에 의해 관리됨“” - Stirng pool 이라는 메모리 영역 (힙 안에 있음) 여기에 저장됩니다.어떻게 저장하냐new String - 새로 계속 객체를 만들어서 저장하게 됩니다.“” - String pool 에 있는 메모리에 기존 값이 있다면 불러주고 , 없다면 저장합니다.→ 결국 메모리를 할당하는 것이 아닌 이미 할당 되어 있는 String pool 공간에 값을 저장한다는 의미입니다.변경이 가능한가둘다 불변 객체로써  생성되기 때문에 new String의 경우 새로운 객체를 생성하고 , “”의 경우 새로운 문자열 객체로 변환하여 조작합니다.String str1 = new String(\"hello\");str1 = str1 + \" world\";System.out.println(str1); // hello worldString str2 = \"hello\";str2 = str2 + \" world\";System.out.println(str2); // 오류 발생 (불변 객체)이렇게 볼 수 있습니다. str1 이라는 공간을 새로운 객체로 생성해서 사용하기 때문에 가능하지만str2 의 경우 기존에 저장된 String pool에 저장이 안되기 때문에 에러가 발생합니다.동일성당연하게도 new String은 새로운 객체를 만드는 것이기 때문에 다른 메모리 주소를 가지고 객체로써의 의미 에서는 다른 값으로 처리됩니다.“” 로 선언된 경우에는 같은 주소로 볼 수 있습니다.String str1 = new String(\"hello\");String str2 = new String(\"hello\");String str3 = \"\";String str4 = \"\";System.out.println(str1 == str2); // false (서로 다른 객체)System.out.println(str3 == str4); // true (동일한 객체)예를 들어 이런 식으로 하면 str1 과 str2의 메모리 주소값을 통해 비교하기 때문에 서로 다른 객체라는 것을 볼 수 있습니다.String str1 = new String(\"hello\");String str2 = new String(\"hello\");System.out.println(str1.equals(str2)); // true (서로 같은 값)이렇게 보면 equals는 그 값 자체를 비교하기 때문에 결과 값이 같다는 것을 볼 수 있습니다.어떨 때 써야하는가?new String : 문자열을 생성후 변경해야하는 경우, 혹은 String 풀에 저장되지 않는 특수한 문자열인 경우“” : 자주 사용되는 경우 - 메모리를 추가로 할당하지 않기 때문에  효율적  &amp;&amp;  문자열값 변경이 필요없는 경우추가 - 특수한 문자열?그냥 궁금해서 찾아봤습니다.특수 문자열 유형 분류  공백 문자열:          하나 이상의 공백 문자 (, \\t, \\n, \\r, \\f)로 구성된 문자열      예시: “ “, “ \\t”, “\\n\\n”, “\\r\\n\\f”        동적 문자열:          변수 값, 표현식 또는 함수 호출 결과를 포함하는 문자열      예시: String str = “Hello “ + name + “!”;        형식 문자열:          printf()와 같은 서식화 함수에 사용되는 문자열      예시: “%d-%02d-%04d”        특수 문자 포함 문자열:          따옴표 (“), 역슬래시 (), 백스페이스 (\\b) 등 특수 문자를 포함하는 문자열      예시: “This is a “special” string.”        대규모 문자열:          메모리 할당 오류를 초래할 수 있는 매우 긴 문자열      예시: 1MB 이상 크기의 문자열      "
  },
  
  {
    "title": "CS - 동기화와 비동기화",
    "url": "/posts/CS-%EB%8F%99%EA%B8%B0%ED%99%94%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%ED%99%94/",
    "categories": "cs",
    "tags": "cs, Synchronous, Asynchronous, java",
    "date": "2024-01-27 06:44:00 +0900",
    





    
    "snippet": "여러 프로세스/스레드를 동시에 실행해도 공유데이터의 일관성을 유지하는 것을 말한다.동기화 (Synchronous)한 작업이 완료될 때까지 다음 작업이 시작되지 않습니다.예를 들어 줄을 서는 것과 동일합니다. A작업을 수행하고 이를 바탕으로 B작업을 할때 이를 동기방식 이라고 합니다.프로세스, 스레드의 관점에서는 공유자원에 접근할 때 서로의 작업의 영향...",
    "content": "여러 프로세스/스레드를 동시에 실행해도 공유데이터의 일관성을 유지하는 것을 말한다.동기화 (Synchronous)한 작업이 완료될 때까지 다음 작업이 시작되지 않습니다.예를 들어 줄을 서는 것과 동일합니다. A작업을 수행하고 이를 바탕으로 B작업을 할때 이를 동기방식 이라고 합니다.프로세스, 스레드의 관점에서는 공유자원에 접근할 때 서로의 작업의 영향일 미치지 않으면서 공유하는 자원의 접근을 조절해 경쟁상태가 되지 않도록 하는 것을 말합니다.장단점은 코드 이해가 좋고, 명확하게 제어하며 데이터 손상 위험이 적습니다. 반대로 처리 속도가 느려질 수 있고, 블로킹 현상이 발생해 작업이 중단 될 수 있습니다.비동기화 (Asynchronous)한 작업이 완료되기를 기다리지 않고 다른 작업을 수행할 수 있습니다여러 작업을 동시에 처리하거나, 응답 속도가 중요한 작업을 수행할 때 유용합니다.예를 들어, 웹사이트에서 버튼을 클릭하면, 서버에 데이터를 요청하고 결과를 기다리는 동안 다른 작업을 수행할 수 있습니다.장단점은 처리, 응답속도가 빨라지고 여러 작업을 효율적으로 처리할 수 있습니다. 다만 데이터 손상의 위험이 있기 때문에 이를 잘 고려해야 합니다.결국 여러일이 동시에 발생하는 데 만약 루프문 처럼 긴 실행시간을 가진 함수가 돌아가도 이것이 흐름을 막지않고 프로그램을 계속실행한다는 의미입니다.따라서 의미있는 비동기화를 구축하기 위해서는 시간 소요가 긴 메서드 외에 다른 작업들도 실행이 되도록 하는 것이 의미를 가집니다.대표적으로 메일을 보내주는 서비스는 시간이 길게 되겠죠? 그런데 메일이 보내지는 것을 기다린다고 웹사이트 자체가 멈추게 되면 사용자 입장에서는 답답할 것입니다. 만약 처리가 초단위로 끝난다고 해도 메시지를 보낸 smtp 서버가 처리가 늦게 끝나면 계속 기다려야 할 것입니다.혹은 ai가 어떤 작업을 수행하고 이런 결과를 보여주는 서비스를 하는데 이때, ai가 작업이 종료될 때까지 백엔드 서버가 기다리고 있으면 효율성이 많이 떨어지겠죠. 이런것을 비동기화 방식으로 처리하는 것입니다.자바에서 구현하는 법동기화public synchronized void someMethod() {  // 동기화 처리가 필요한 코드}동기화를 처리할 코드를 키워드를 통해 선언하면 됩니다.비동기화new Thread(() -&gt; {  // 비동기 작업을 수행하는 코드}).start();쓰레드를 새로만드는 방법이 가장 기본적인 방법입니다.someAsyncMethod(new Callback() {  @Override  public void onSuccess(Object result) {    // 비동기 작업 결과 처리 코드  }  @Override  public void onFailure(Throwable t) {    // 오류 처리 코드  }});콜백함수를 통해 만드는 방법도 있습니다.그러면 이런 생각이 듭니다. 결국 비동기화라는 게 결국 여러개의 작업단위를 만들어서 따로 따로 실행시키는 쓰레드가 여러개 있는 것과 같은건가?비동기화 = 멀티쓰레드? 저도 이런식으로 되는 것이라고 이해했는데요궁금해서 더 찾아본 결과 둘의 차이점이 있었습니다.비동기 vs 멀티 스레딩결국 여러 작업을 동시에 처리하는 것은 동일합니다. 하지만 작동 방식과 활용되는 것의 차이가 있습니다.비동기란 , 결국 다른 작업을 방해하지 않는다. 가 메인이고 작업을 동시에 처리하는 것처럼 보이지만, 실제로는 하나의 CPU 코어를 순차적으로 사용하며, I/O 작업을 기다리는 동안 다른 작업을 처리합니다.멀티 스레딩이란 , 여러개의 스레드가 생성해 실제로 동시 실행을 하는 방법입니다.  CPU 코어가 여러 개 존재하는 경우, 각 코어에 하나씩 스레드를 할당하여 병렬 처리를 수행합니다.더 쉽게 접근해보면 멀티 스레딩은 작업자 - 스레드의 대한 것이고 비동기화는 작업 - 테스크에 대한 이야기 입니다. 만약 비동기화를 더 큰 범위에서 본다면 프로세스 자체에도 적용 시켜볼 수 있겠죠."
  },
  
  {
    "title": "CS - 뮤텍스와 세마포어",
    "url": "/posts/CS-%EB%AE%A4%ED%85%8D%EC%8A%A4%EC%99%80-%EC%84%B8%EB%A7%88%ED%8F%AC%EC%96%B4/",
    "categories": "cs",
    "tags": "cs, mutex, semaphore, 모니터",
    "date": "2024-01-26 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 뮤텍스와 세마포어에 대해 이해해 보겠습니다.프로세스 혹은 스레드가 동시에 같은 공유 자원에 접근할 때 문제가 생기지 않도록 하는 방법이 필요한데요. 이때 동기화 방식으로 접근해볼 수 있습니다.뮤텍스와 세마포어는 동기화 도구 입니다. 하나의 방법 정도로 이해하면 됩니다.먼저 이해할 용어공유자원공유자원은 말그대로 공유하는 자원입니...",
    "content": "들어가며이번 포스트에서는 뮤텍스와 세마포어에 대해 이해해 보겠습니다.프로세스 혹은 스레드가 동시에 같은 공유 자원에 접근할 때 문제가 생기지 않도록 하는 방법이 필요한데요. 이때 동기화 방식으로 접근해볼 수 있습니다.뮤텍스와 세마포어는 동기화 도구 입니다. 하나의 방법 정도로 이해하면 됩니다.먼저 이해할 용어공유자원공유자원은 말그대로 공유하는 자원입니다. 예를 들어 2개의 프로세스가 동시에 접근하는 메모리가 있다면 공유 메모리 라고 하며 이것이 공유 자원입니다. OS 에서는 메모리를 하드웨어 자원이라면 파일을 DB에서도 공유하는 자원이 있을 수 있습니다. 이런 작업들을 효율적으로 처리하기 위한 방법입니다.경쟁상태두개 이상의 프로세스가 동시에 공유 자원에 접근하여 의도와 다른 결과를 가지고 오는 것을 말하는데 대표적으로 은행원알고리즘에서 해결하는 동일한 시간에 은행계좌에 접근해 돈을 입금하고 출금하는 동안 의도치 않은 결과를 가지고 와서 옳바른 값이 저장 되지 않는 경우가 있습니다.임계영역공유 자원에 접근하는 순서에 따라 결과가 달라질 수 있는 코드 영역을 의미합니다.임계 영역에서 실행되는 코드는 다른 프로세스의 방해를 받지 않도록 해야 합니다.즉, 한 프로세스가 임계 영역에 진입하면 다른 프로세스는 그 영역에 들어갈 수 없어야 합니다.예를 들어 변기가 공유자원이라면 임계영역은 화장실 같은 것이죠Mutex뮤텍스는 한 번에 하나의 프로세스만 임계 영역에 진입하도록 하는 메커니즘입니다뮤텍스 객체는 잠금 및 해제 메서드를 제공하며, 임계 영역에 진입하려는 프로세스는 먼저 뮤텍스를 잠가야 합니다.뮤텍스가 잠겨있는 경우 다른 프로세스는 대기 상태에 들어가 뮤텍스가 해제될 때까지 기다려야 합니다.뮤텍스는 Key를 기반으로 한 상호배제 기법입니다. 키를 가진 어떤 객체가 있고 이를 소유한 프로세스 , 스레드가 이 공유 자원에 접근할 수 있도록 하는 방법입니다.Semaphore세마포어는 뮤텍스와 유사하지만, 동시에 임계 영역에 진입할 수 있는 프로세스의 수를 제한하는 데 사용할 수 있습니다.세마포어 객체는 카운터와 연산 메서드를 제공하며, 임계 영역에 진입하려는 프로세스는 카운터를 감소시켜야 합니다.카운터 값이 0이면 임계 영역이 사용 중이며, 프로세스는 대기 상태에 들어가 카운터 값이 1 이상이 될 때까지 기다려야 합니다.여러개의 프로세스 , 스레드가 접근할 수 있고 , 이것을 연산하는 카운터가 존재하여서 0이면 못들어가고 양수값이 될때만 사용할 수 있도록 하는 기법입니다.차이점정리하면 뮤텍스는 하나 , 세마포어는 여러개의 동기화 대상을 가집니다.결국 뮤텍스는 키를 통해 자원을 소유한다는 개념에서 시작하는 것이고 , 반대로 세마포어는 자원을 소유하지는 않습니다.쉽게 생각해서 뮤텍스는 boolean 형과 유사하고 세마포어는 array에 카운터를 세서 접근 가능여부를 확인 시켜주는 기법이라고 생각하면 됩니다.추가 - 모니터모니터 라는 기법도 존재합니다. 모니터는 공유 변수와 프로세스 간의 동기화를 위한 고급 동기화 메커니즘입니다. 모니터는 조건 변수와 같은 추가 기능을 제공하며, 복잡한 동기화 문제를 해결하는 데 유용합니다.모니터의 구성 요소모니터는 다음과 같은 세 가지 주요 구성 요소로 구성됩니다.  공유 변수: 모니터 내부에 선언되는 변수로, 여러 프로세스가 동시에 접근하고 변경할 수 있습니다.  조건 변수: 프로세스가 특정 조건을 만족할 때까지 대기하도록 하는 메커니즘입니다.  진입 절차: 프로세스가 모니터에 진입하고 공유 변수에 접근하기 위한 규칙을 정의합니다.모니터의 동작 방식모니터는 다음과 같은 방식으로 동작합니다.  프로세스가 모니터에 진입하기 위해서는 wait() 연산을 수행해야 합니다. wait() 연산은 조건 변수와 함께 사용될 수 있으며, 조건이 충족되지 않을 경우 프로세스는 대기 상태에 들어갑니다.  대기 상태에 있는 프로세스는 signal() 또는 broadcast() 연산을 통해 다른 프로세스에 의해 다시 활성화될 수 있습니다. signal() 연산은 대기 상태에 있는 프로세스 중 하나를 선택하여 활성화하는 반면, broadcast() 연산은 모든 대기 상태에 있는 프로세스를 활성화합니다.  프로세스가 모니터를 떠나기 전에 signal() 또는 broadcast() 연산을 수행하여 다른 프로세스가 진입하도록 해야 합니다."
  },
  
  {
    "title": "Spring - IOC 컨테이너의 대한 이해",
    "url": "/posts/Spring-IOC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%9D%98-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4/",
    "categories": "spring",
    "tags": "java, spring, ioc, bean",
    "date": "2024-01-25 06:44:00 +0900",
    





    
    "snippet": "들어가며IOC란 Iversion of Control : 의존 관계 주입 - (DI) 와 밀집한 관계를 가지고 있습니다.객체가 사용하는 의존 객체를 직접 만드는 것이 아닌 주입 받아 사용하는 것을 말합니다.private final PostReposioty postRepository = new PostRepository();이런 식으로 만드는 것이 아니라...",
    "content": "들어가며IOC란 Iversion of Control : 의존 관계 주입 - (DI) 와 밀집한 관계를 가지고 있습니다.객체가 사용하는 의존 객체를 직접 만드는 것이 아닌 주입 받아 사용하는 것을 말합니다.private final PostReposioty postRepository = new PostRepository();이런 식으로 만드는 것이 아니라private final PostReposioty postRepository이렇게 주입 받아 만드는 것을 DI라고 하는데 이때 우리가 자주 보는 생성자를 통해 의존성을 주입하여 사용하게 됩니다.public PostService(PostRepository postRepository){\tthis.postRepository = postRepository;}당연히 위에 방법에서 정의하는 방식으로도 설정이 가능해 postRepository를 불러와서 메서드를 만들고 새롭게 만들어낸 서비스 객체에 레포지토리를 매개변수로 주입시키는 방법도 가능합니다.다만, 이런 방법은 아주 오래전부터 개발자들 사이에 논의를 통해 정의 된 방법인 아래 방법을 통해 구축하는 것이 안전하고 효과적입니다.굳이? 하지 않아도 되는 것을 할 이유는 없습니다. (특별한 경우를 제외하면)저는 이렇게 씁니다.저는 주로 @RequiredArgsConstructor 어노테이션을 통해 사용하는데요@RequiredArgsConstructor 란,Lombok에서 제공하는 애노테이션 중 하나로, 클래스의 필수 인자에 대한 생성자를 자동으로 생성해줍니다. 이 애노테이션을 사용하면 필드에 final 키워드가 붙은 경우에 대해서만 생성자가 자동으로 생성됩니다.일반적으로 레포지토리를 불러다 쓰는 서비스 , 서비스를 부르는 컨트롤러에서는 더 이상 수정을 하지 않는 다는의미의 final 키워드를 붙이기 때문에 코드 가독성이 높아지는 것이 사실입니다.final 이라는 것이 변수의 붙이며 ‘초기화 - 최초값을 넣고 나면 변경 X 상수’ , 메서드의 붙이면 하위 클래스에서 해당 메서드를 재정의 - 오버라이딩 할 수 없다는 의미입니다.오버로딩과 오버라이딩은 다른 포스트에서 정리하였으니 참고해주시길 바랍니다.즉, 내 의도 이상으로 변경이 되는것을 방지해주는 역할을 합니다.Bean빈은 자바에서 관리하는 객체 - 스프링에서 관리하는 객체 라는 의미인데 정확한 구분을 해야합니다.자바에서 관리하는 객체는 클래스를 통해 구축되었다면 모두 자바 빈이라고 부를 수 있습니다.그리고 스프링 빈 - 이라면 스프링 컨테이너에서 관리하는 빈 - 객체 라는 것을 이해해야 합니다.우리가 흔히 사용하는 @Service , @Repository , @Configuration 이렇게 객체를 컨테이너에 알려두고 등록시켜 둔 애들만 스프링 빈이라고 해야합니다.빈 등록하는 방법스프링 빈을 주입시키는 방법이 3가지있는데요. xml , 자바코드 ,어노테이션이 있습니다.xml을 예전에는 많이 썼다고 하는데 개발자들이 어노테이션 방향으로 주입시키는 방법을 의도하였다고 합니다.이렇게 했는데 사실 불편한 건 사실입니다, 그래서 어노테이션은 미리 지정된 @Service , @Repository 이런 애들을 통해서 정의를 합니다.@Servicepublic class UserServiceImpl implements UserService {    // Implementation...}@Repositorypublic class UserRepositoryImpl implements UserRepository {    // Implementation...}그런데 외부에서 온 라이브러리 같이 주입을 시킬 때 사용자가 커스터 마이징해서 정의를 한 다음 스프링에 빈으로 등록 해야하는 경우가 있습니다. 이럴 때는 자바 코드를 통해 정의하고 등록을 하는데요대표적으로 @Configuration 을 통해 만듭니다. 저는 S3나 SpringSecurity를 쓸 때 사용했던 경험이 있습니다.@Configurationpublic class AppConfig {    @Bean    public UserService userService() {        return new UserServiceImpl();    }    @Bean    public UserRepository userRepository() {        return new UserRepositoryImpl();    }}그럼 왜 등록을 하는 가?DI - 의존성을 주입 받기 위해서는 스프링 IOC컨테이너에 등록이 되어야 하는 이유가 가장 큽니다.앞서 선언하는 방법에 대해 이야기했던 부분이죠.또한 , 빈 관리가 유용합니다. 의존성을 관리하는 부분과 스코프 - 싱글톤 패턴으로 만드는 거라면다른 설정 없이 곧바로 사용할 수 있게 됩니다. 예를 들어 postService가 다른 곳에서 불려서 재 정의를 통해 계속 변경되지 않는 스코프 - 즉, 범위를 가지고 있다면 , 하나만 있어도 충분합니다.굳이 여러개의 객체를 생성하는 것이 아니라 생성을 미리 해놓고 사용하면 자원관리가 효율적이게 관리하는 것이 더 좋은 선택일 것입니다.그럼 의존성 주입은 왜 하는 가?DI를 따로 포스트 할려고 정리 중 이긴한데 말이 나온김에 간단하게 생각해보면테스트를 하는데 용의하게 작성을 하려고 입니다.만약 new - 를 통해 새로운 객체를 생성하는 방법으로 짠다면 Mock프레임워크를 통해가짜 객체를 만드는 것이 안되겠죠.그러면 의도대로 코드는 작성을 했는데 반대되는 결과값이 있어 테스트가 어려울 때 상당히 난감할 것입니다. 그래서 의존성을 주입 받으면 실제 생성되는 것은 돌아갈 때  만들어 지니까 Mock을 통해구현하여도 문제가 없어집니다."
  },
  
  {
    "title": "알고리즘 - 삽입정렬",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-insertion-sort/",
    "categories": "algorithm",
    "tags": "java, algorithm, sort, insertion sort",
    "date": "2024-01-24 06:44:00 +0900",
    





    
    "snippet": "이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방법입니다.촤악의 경우 ,- O(n^2)으로 느립니다.동작방식  주어진 리스트에서 가장 작은(또는 가장 큰) 요소를 찾습니다.  해당 요소를 리스트의 맨 앞 요소와 위치를 교환합니다.  정렬된 부분 리스트와 정렬되지 않은 부분 리스트로 나눕니다. 정렬된 부분 리스트는 계...",
    "content": "이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방법입니다.촤악의 경우 ,- O(n^2)으로 느립니다.동작방식  주어진 리스트에서 가장 작은(또는 가장 큰) 요소를 찾습니다.  해당 요소를 리스트의 맨 앞 요소와 위치를 교환합니다.  정렬된 부분 리스트와 정렬되지 않은 부분 리스트로 나눕니다. 정렬된 부분 리스트는 계속해서 증가하고, 정렬되지 않은 부분 리스트는 감소합니다.  위의 과정을 반복하여 정렬이 완료될 때까지 진행합니다.Sudoprocedure selectionSort(A : list of sortable items)    n = length(A)    for i = 0 to n - 2 do        minIndex = i        for j = i + 1 to n - 1 do            if A[j] &lt; A[minIndex] then                minIndex = j        end for        swap A[i] with A[minIndex]    end forend procedure예시코드 - 자바public class SelectionSort {    public static void selectionSort(int[] arr) {        int n = arr.length;        // 배열을 순회하면서 가장 작은 값을 찾아서 알맞은 위치로 이동시킴        for (int i = 0; i &lt; n - 1; i++) {            int minIndex = i; // 현재까지의 최소값의 인덱스를 저장            // 현재 위치부터 배열 끝까지 순회하면서 최소값의 인덱스를 찾음            for (int j = i + 1; j &lt; n; j++) {                if (arr[j] &lt; arr[minIndex]) {                    minIndex = j;                }            }            // 최소값을 현재 위치로 이동            int temp = arr[minIndex];            arr[minIndex] = arr[i];            arr[i] = temp;        }    }    public static void main(String[] args) {        int[] arr = {64, 25, 12, 22, 11};        selectionSort(arr);        System.out.println(\"Sorted array:\");        for (int num : arr) {            System.out.print(num + \" \");        }    }}"
  },
  
  {
    "title": "알고리즘 - 선택정렬",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-selection-Sort/",
    "categories": "algorithm",
    "tags": "java, algorithm, sort, selection sort",
    "date": "2024-01-23 06:44:00 +0900",
    





    
    "snippet": "선택 정렬은 리스트를 순회하면서 가장 작은(또는 가장 큰) 원소를 선택하여 알맞은 위치로 이동시키는 방식으로 동작합니다.핵심남은 정렬부분에서 최솟값 또는 최댓값을 찾는다남은 정렬 부분에서 가장 앞에있는 데이터와 선택된 데이터를 swap한다.가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분을 축소한다.전체 데이터 크기만큼 인덱스가 커질때 까지 즉,...",
    "content": "선택 정렬은 리스트를 순회하면서 가장 작은(또는 가장 큰) 원소를 선택하여 알맞은 위치로 이동시키는 방식으로 동작합니다.핵심남은 정렬부분에서 최솟값 또는 최댓값을 찾는다남은 정렬 부분에서 가장 앞에있는 데이터와 선택된 데이터를 swap한다.가장 앞에 있는 데이터의 위치를 변경해 남은 정렬 부분을 축소한다.전체 데이터 크기만큼 인덱스가 커질때 까지 즉, 남은 부분이 없을 때까지 반복한다.예시코드public class SelectionSort {    public static void selectionSort(int[] arr) {        int n = arr.length;        // 배열을 순회하면서 최소값의 인덱스를 찾아서 알맞은 위치로 이동시킴        for (int i = 0; i &lt; n - 1; i++) {            int minIndex = i; // 현재까지의 최소값의 인덱스를 저장            // 현재 위치부터 배열 끝까지 순회하면서 최소값의 인덱스를 찾음            for (int j = i + 1; j &lt; n; j++) {                if (arr[j] &lt; arr[minIndex]) {                    minIndex = j;                }            }            // 최소값을 현재 위치로 이동            int temp = arr[minIndex];            arr[minIndex] = arr[i];            arr[i] = temp;        }    }    public static void main(String[] args) {        int[] arr = {64, 25, 12, 22, 11};        selectionSort(arr);        System.out.println(\"Sorted array:\");        for (int num : arr) {            System.out.print(num + \" \");        }    }}예제코드 - 백준1427 private static void test() throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st = new StringTokenizer(br.readLine());        int n = Integer.parseInt(st.nextToken());        String s = String.valueOf(n);        int [] arrN = new int[s.length()];        for(int i=0; i&lt;s.length(); i++){            arrN[i] = Integer.parseInt(s.substring(i,i+1));        }        for (int i = 0; i &lt; arrN.length - 1; i++) {            int maxIndex = i;            for (int j = i + 1; j &lt; arrN.length; j++) {                if (arrN[j] &gt; arrN[maxIndex]) {                    maxIndex = j;                }            }            if (maxIndex != i) {                // Swap                int temp = arrN[i];                arrN[i] = arrN[maxIndex];                arrN[maxIndex] = temp;            }        }        for (int a : arrN) {            System.out.println(a);        }    }"
  },
  
  {
    "title": "알고리즘 - 버블소트",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-bubbleSort/",
    "categories": "algorithm",
    "tags": "java, algorithm, sort, bubble sort",
    "date": "2024-01-22 06:44:00 +0900",
    





    
    "snippet": "버블 정렬(Bubble Sort)은 간단하면서도 비효율적인 정렬 알고리즘 중 하나입니다. 이 알고리즘은 인접한 두 요소를 비교하여 필요한 경우 위치를 교환하는 방식으로 동작합니다.여기서 각 패스(반복)마다 가장 큰 요소가 맨 끝으로 이동하므로, “거품이 물 위로 떠오르는 것과 같다”는 개념에서 유래하여 “버블(Bubble)”이라는 이름이 붙여졌습니다....",
    "content": "버블 정렬(Bubble Sort)은 간단하면서도 비효율적인 정렬 알고리즘 중 하나입니다. 이 알고리즘은 인접한 두 요소를 비교하여 필요한 경우 위치를 교환하는 방식으로 동작합니다.여기서 각 패스(반복)마다 가장 큰 요소가 맨 끝으로 이동하므로, “거품이 물 위로 떠오르는 것과 같다”는 개념에서 유래하여 “버블(Bubble)”이라는 이름이 붙여졌습니다.예시 코드public class BubbleSort {    public static void bubbleSort(int[] arr) {        int n = arr.length;        for (int i = 0; i &lt; n - 1; i++) {            for (int j = 0; j &lt; n - i - 1; j++) {                if (arr[j] &gt; arr[j + 1]) {                    // 인접한 두 요소의 값이 순서대로 되어 있지 않으면 교환                    int temp = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = temp;                }            }        }    }    public static void main(String[] args) {        int[] arr = {64, 34, 25, 12, 22, 11, 90};        bubbleSort(arr);        System.out.println(\"Sorted array:\");        for (int i = 0; i &lt; arr.length; i++) {            System.out.print(arr[i] + \" \");        }    }}내가 만든 코드    private static void test() throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st= new StringTokenizer(br.readLine());        int n = Integer.parseInt(st.nextToken());        int [] arrN = new int[n];        for(int i=0; i&lt;n; i++){            int a = Integer.parseInt(br.readLine());            arrN[i] = a;        }        for(int i=0; i&lt;n-1; i++){            for(int j=0; j&lt;n-1; j++){                if(arrN[j] &gt; arrN[j+1]){                    int temp = arrN[j];                    arrN[j] = arrN[j+1];                    arrN[j+1] = temp;                }            }        }        for(int a : arrN){            System.out.println(a);        }    }핵심두개 비교하기 위해 2중 중첩문을 통해 구현한다.비교조건에 따라 Swap문을 만든다.예제문제 private static void test() throws IOException {        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        StringTokenizer st= new StringTokenizer(br.readLine());        int n = Integer.parseInt(st.nextToken());        int [] arrN = new int[n];        int [] arrS = new int[n];        for(int i=0; i&lt;n; i++){            int a = Integer.parseInt(br.readLine());            arrN[i] = a;            arrS[i] = a;        }        Arrays.sort(arrS);        HashMap&lt;Integer, Integer&gt; hashMap1 = new HashMap&lt;&gt;();        HashMap&lt;Integer, Integer&gt; hashMap2 = new HashMap&lt;&gt;();        for(int i =0; i&lt;n; i++){            hashMap1.put(arrN[i],i);            hashMap2.put(arrS[i],i);        }        int maxDiff = Integer.MIN_VALUE;        for (Integer key : hashMap1.keySet()) {            if (hashMap2.containsKey(key)) {                int diff = hashMap1.get(key) - hashMap2.get(key);                maxDiff = Math.max(maxDiff, diff);            }        }        System.out.println(maxDiff + 1);    }    public static void main(String[] args) throws IOException {        test();    }"
  },
  
  {
    "title": "CS - 프로세스와 스레드에 대하여",
    "url": "/posts/CS%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%93%B0%EB%A0%88%EB%93%9C/",
    "categories": "cs",
    "tags": "cs, process, thread, multi-thraed",
    "date": "2024-01-21 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 Process와 Thread에 대해 정리해봅니다.Process?프로세스는 하나의 작업을 의미합니다. 프로그램이 동작하는 것을 프로세스라고 부르기도합니다.예를 들어 밥을 먹는 일련의 과정 , 게임을 하는 일련의 과정 등 작업들을 의미합니다.이런 식으로 표현해 볼 수 있습니다.그리고 하나의 컴퓨터에서 동시에 프로세스가 여러개 올라...",
    "content": "들어가며이번 포스트에서는 Process와 Thread에 대해 정리해봅니다.Process?프로세스는 하나의 작업을 의미합니다. 프로그램이 동작하는 것을 프로세스라고 부르기도합니다.예를 들어 밥을 먹는 일련의 과정 , 게임을 하는 일련의 과정 등 작업들을 의미합니다.이런 식으로 표현해 볼 수 있습니다.그리고 하나의 컴퓨터에서 동시에 프로세스가 여러개 올라오면Multi process라고 합니다.그리고 이런 작업을 동시에 처리하게 되면 멀티 테스킹을 한다라고 표현합니다.그리고 여기에는 정보가 포함되어야 합니다.어떤 메모리를 쓰고 있고, 어디에 저장되고 있고, 어떤 환경과 연결되어있는지해당 프로그램- 프로세스를 개발한 개발자의 의도대로 포함된 정보가 함께 들어가 있어야컴퓨터가 이를 찾아서 연결해줄 테니까요그리고 이런걸 PCB - Process Control Block이를 통해 운영체제가 프로세스들을 관리하고 멀티 테스킹 - 즉 여러개의 프로세스가 동시에 실행될때 프로세스의 상태, 프로그램 카운터, 레지스터 상태, 할당된 리소스, 우선순위, 스케줄링 정보 등을 활용하게 됩니다.Thread?쓰레드는 프로세스의 과정중 작업의 단위를 의미합니다.하나의 프로세스에는 최소 하나의 쓰레드가 존재하게됩니다.각 쓰레드는 알아서 작업을 하게 됩니다. (외부 요건에 의해 동시 작업이 걸린 경우가 아니라면)이때 쓰레드는 작업의 최소단위를 말하는데예를 들어 밥을 먹는 과정에서 수저를 들고 , 젓가락을 들고  이런식의 최소작업단위를 말합니다.만약 덮밥을 먹는다면 수저를 드는 작업만 해도 되고, 백반을 먹는다면 여러 작업이 필요하겠죠그래서 이런 작업을 동시에 처리하게 된다면이를 Multi-thread →작업 중 멀티 쓰레딩 이라고 합니다.정리정리하면 다음과 같습니다.프로세스란 하나의 작업이며 프로그램이 실행중일때 운영체제로 부터 할당받고 있는 작업단위를 의마한다.그리고 이런 프로세스가 여러개 있으면 멀티 프로세스 - 이를 동시에 실행시키며 작업하면 멀티 캐스팅 이라고 한다.이런 멀티 캐스팅을 하기 위해서는 정보가 필요한데 이런 정보를 PCB - 프로세스 컨트롤 블록단위로 취합하여 관리한다.그리고 프로세스의 가장 작은 작업 단위는 쓰레드 이며 최소 하나의 쓰레드가 있다.그리고 이런 쓰레드가 여러개 있고 동시에 작업하는 경우, 멀티 쓰레드 - 작업중이면 멀티 쓰레딩이라고 표현한다.스프링을 사용해보면 스프링 풀 이라는 개념이 나오는데 이때 쓰레드를 적용시켜 들어오는 트래픽을 관리하는 기법이 있습니다. 생각보다 자주 나오는 개념이 이여서 정리를 해봤습니다.여기서 더 나아가 컴퓨터 환경에서도 알아볼 수 있는데요이것은 다음 포스트에서 다루겠습니다."
  },
  
  {
    "title": "JAVA - 디자인 패턴에 대하여",
    "url": "/posts/JAVA%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90/",
    "categories": "java",
    "tags": "java, design, 패턴",
    "date": "2024-01-20 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 디자인 패턴에 대해서 알아보겠습니다.글이 길어 패턴의 자세한 내용은 다음 포스트에서 다룹니다.디자인 패턴이란?소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반적인 해결책입니다.개발자들이 반복적으로 발생하는 설계 문제들을 해결하기 위해 미리 만들어 놓은 청사진과 같다고 생각하면 됩니다.에초에 디자인 - 설계 라는 의...",
    "content": "들어가며이번 포스트에서는 디자인 패턴에 대해서 알아보겠습니다.글이 길어 패턴의 자세한 내용은 다음 포스트에서 다룹니다.디자인 패턴이란?소프트웨어 설계에서 자주 발생하는 문제들을 해결하기 위한 일반적인 해결책입니다.개발자들이 반복적으로 발생하는 설계 문제들을 해결하기 위해 미리 만들어 놓은 청사진과 같다고 생각하면 됩니다.에초에 디자인 - 설계 라는 의미로 사용되니까요.이전에 포스팅한 내용들과도 연관되어 설명해볼 수 있습니다.자바란? 객체지향을 잘 하기 위한 언어이런 자바를 잘 만들기 위한 도구 : OOP의 4대 특성 , 캡슐화 , 상속, 추상화 , 다형성그리고 이런 도구를 잘 다루기 위한 사용법 : SOLID - 단일 책임, 오픈 클로즈 , 리스코프 치환 , 인터페이스 분리 , 의존 역전 원칙그리고 이런 사용법을 활용 할 수 있는 레시피 : 디자인 패턴이렇게 정리해보면 연결 관계가 보입니다.디자인 패턴을 비유해보면 마치 음식의 레시피 와도 같습니다.예로 떡볶이를 만든다고 가정하면 앞서 다양한 사람들이 떡볶이를 만들기 위해 수많은 레시피를 만들었고, 이 중 좋은 레시피만 남겨 많은 사람들이 사용합니다.디자인 패턴도 앞서 다양한 개발자들의 수많은 수행 착오 끝에 어떤 문제점을 해결하는 방법을 정리해둔 것이라고 말할 수 있습니다.디자인 패턴은 정말 다양해서 우선 종류부터 구분하고 시작해보겠습니다.디자인 패턴의 종류  생성 패턴: 객체 생성 방식을 정의하는 패턴입니다.  구조 패턴: 객체 간의 관계를 정의하는 패턴입니다.  행동 패턴: 객체 간의 상호 작용 방식을 정의하는 패턴입니다.디자인 패턴을 자바에 적용해보면 결국 객체 지향을 하는 방법 중 일부를 사용하는데상속 , 인터페이스 , 합성 을 이용합니다.합성이란 , 객체를 속성으로 사용하는 것을 말합니다.따라서 각 패턴마다 유사한 점이 많이 보이는데요.일단 개념적인 부분을 정리해보겠습니다.생성패턴객체 생성 방식을 정의하는 디자인 패턴입니다.이는 객체 생성 과정을 추상화 하여 코드의 재사용성, 유지 관리성, 확장성을 향상시키는 데 도움을 줍니다.우리가 앞서 다루었던 인터페이스 또한 추상화와 관련이 있죠  싱글톤 패턴: 시스템 전체에서 유일한 객체를 생성해야 하는 경우 사용합니다. 예를 들어, 데이터베이스 연결 객체, 로그 관리 객체 등에 활용될 수 있습니다.  팩토리 메서드 패턴: 구체적인 객체 생성 방식을 캡슐화하고 클라이언트 코드에서 분리해야 하는 경우 사용합니다. 예를 들어, 데이터베이스 연결 객체, 문서 처리 객체 등을 생성하는 데 활용될 수 있습니다.  추상 팩토리 패턴: 객체 생성에 대한 인터페이스를 제공하고, 플랫폼 또는 환경에 따라 구체적인 객체 생성 방식을 변경할 수 있도록 하는 패턴입니다. 예를 들어, 운영 체제에 따라 GUI 컴포넌트를 생성하는 데 활용될 수 있습니다.  빌더 패턴: 복잡한 객체를 단계별로 생성해야 하는 경우 사용합니다. 예를 들어, 문서, 메시지, 쿼리 등을 단계별로 구성하여 생성하는 데 활용될 수 있습니다.  프로토타입 패턴: 기존 객체를 복제하여 새로운 객체를 생성해야 하는 경우 사용합니다. 예를 들어, 게임 캐릭터, 문서 템플릿 등을 복제하여 새로운 객체를 생성하는 데 활용될 수 있습니다.구조 패턴구조 패턴은 클래스와 객체를 조합하여 더 큰 구조를 만드는 데 사용하는 디자인 패턴입니다.  어댑터 패턴: 서로 다른 인터페이스를 가진 객체들을 연결하여 함께 사용할 수 있도록 하는 패턴입니다. 예를 들어, 다른 API를 사용하는 두 라이브러리를 함께 사용해야 하는 경우 어댑터 패턴을 사용할 수 있습니다.  브릿지 패턴: 추상화와 구현을 분리하여 추상화 부분을 변경하지 않고 구현 부분을 변경할 수 있도록 하는 패턴입니다. 예를 들어, GUI 컴포넌트의 외관과 기능을 분리하여 외관만 변경하면서 기능은 유지할 수 있습니다.  컴포지트 패턴: 0개 이상의 객체를 묶어 하나의 객체처럼 사용할 수 있도록 하는 패턴입니다. 예를 들어, 메뉴 트리를 구성하는 데 컴포지트 패턴을 사용할 수 있습니다.  데코레이터 패턴: 기존 객체의 기능을 추가하거나 변경하지 않고 새로운 기능을 추가할 수 있도록 하는 패턴입니다. 예를 들어, 로그 기능을 추가하거나 테마를 변경하는 데 데코레이터 패턴을 사용할 수 있습니다.  퍼사드 패턴: 복잡한 시스템의 인터페이스를 단순화하여 사용하기 쉽게 만드는 패턴입니다. 예를 들어, 여러 API를 사용하는 시스템을 하나의 간단한 인터페이스로 제공하는 데 퍼사드 패턴을 사용할 수 있습니다.  프록시 패턴: 실제 객체에 대한 접근을 제어하고, 접근 비용을 줄이고, 보안을 강화하는 데 사용하는 패턴입니다. 예를 들어, 원격 객체에 대한 접근을 제어하거나 이미지를 로딩하는 데 프록시 패턴을 사용할 수 있습니다.행위패턴행위 패턴은 객체 간의 상호 작용 방식을 정의하는 디자인 패턴입니다.객체들이 서로 어떻게 통신하고 협력 하는지를 정의합니다.  옵저버 패턴: 객체의 상태 변화를 관찰하고 관찰자에게 알리는 패턴입니다. 예를 들어, GUI 컴포넌트의 상태 변화를 관찰하거나, 데이터베이스의 변화를 관찰하는 데 활용될 수 있습니다.  이터레이터 패턴: 컬렉션의 항목을 순회하는 방법을 추상화하여 컬렉션 구현 방식에 의존하지 않고 순회할 수 있도록 하는 패턴입니다. 예를 들어, 리스트, 배열, 맵 등의 항목을 순회하는 데 활용될 수 있습니다.  메멘토 패턴: 객체의 상태를 저장하고 이전 상태로 복원할 수 있도록 하는 패턴입니다. 예를 들어, 문서 편집 작업에서 이전 버전으로 복원하거나, 게임에서 이전 상태로 복원하는 데 활용될 수 있습니다.  전략 패턴: 알고리즘을 객체로 표현하여 알고리즘을 쉽게 변경하고 확장할 수 있도록 하는 패턴입니다. 예를 들어, 정렬 알고리즘, 검색 알고리즘 등을 변경하는 데 활용될 수 있습니다.  템플릿 메서드 패턴: 알고리즘의 뼈대를 정의하고, 일부 부분은 하위 클래스에서 구현하도록 하는 패턴입니다. 예를 들어, 데이터 처리 과정, GUI 컴포넌트의 렌더링 과정 등에 활용될 수 있습니다.이렇게 많은 패턴들이 존재하는데요.제가 부족한 것이기도 하지만 저는 각 패턴에 대해 개략적으로만 생각하고 있는 것 같습니다.보통 코딩을 하다 문제가 생기면 어떤 식으로 해결해볼까 접근할 때 관련된 내용을 읽어보고선택을 하는데요.정처기 시험을 준비하면서 한번 외운 경험이 있긴 한데 몇 주 지나니 또 기억이 안나더 라구요 ㅋㅋ어쨋든 외우려고 하는 것보다는 아 이럴때 이런거 있었는데 라고 생각하는 수준으로 알아두시면좀 더 도움이 되지 않을까 싶습니다.다음포스트다음 포스트에서는 생성 패턴에 대해 코드로 알아보려고 합니다.외우지는 않아도 유사한 패턴을 봤을 때 파악은 할 수 있어야 된다고 생각하기 때문입니다."
  },
  
  {
    "title": "JAVA - SOLID에 대하여",
    "url": "/posts/JAVA%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B0%9C%EB%85%90/",
    "categories": "java",
    "tags": "java, antition, 주석",
    "date": "2024-01-19 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 어노테이션에 대해서 이야기 합니다.Spring 프레임워크를 쓰다보면 정말 많이 어노테이션을 쓰게 되는데요이때 어노테이션이 무엇인지 잘 이해하고 쓰기보다는 단순히 붙여야 돌아가던데라는 생각으로 처음에 접근하였습니다.이전 포스트에서 OverLiding 에대한 이야기를 하며 @Override에 대해 이야기를 잠깐 했는데 이번 포스트...",
    "content": "들어가며이번 포스트에서는 어노테이션에 대해서 이야기 합니다.Spring 프레임워크를 쓰다보면 정말 많이 어노테이션을 쓰게 되는데요이때 어노테이션이 무엇인지 잘 이해하고 쓰기보다는 단순히 붙여야 돌아가던데라는 생각으로 처음에 접근하였습니다.이전 포스트에서 OverLiding 에대한 이야기를 하며 @Override에 대해 이야기를 잠깐 했는데 이번 포스트에서 잘 알아보십니다.어노테이션이 뭔데?Anotation 은 주석 이라는 의미입니다.보통 우리가 쓰는 주석은 이런식으로 쓰죠?//여기서 이렇게 돌아가서 이렇게 설정됩니다!우리가 쓰는 @도 같은 의미라고 볼 수 있습니다. 그러면 누가 보느냐?컴파일러 지시자어노테이션을 사용하여 컴파일러에게 특정 작업을 수행하도록 지시할 수 있습니다.예를 들어, @Override 어노테이션은 메서드가 부모 클래스의 메서드를 재정의한다는 것을 나타냅니다.런타임 처리어노테이션을 사용하여 런타임에 동작을 변경하거나 프로그램의 흐름을 제어할 수 있습니다.예를 들어, 스프링 프레임워크에서 @Transactional 어노테이션은 트랜잭션 처리를 지정한 메서드 또는 클래스에 적용합니다.컴포넌트 스캐닝 및 DI(Dependency Injection)스프링 프레임워크와 같은 프레임워크는 어노테이션을 사용하여 클래스를 식별하고 구성할 수 있습니다.예를 들어, @Component, @Service, @Repository 어노테이션은 스프링의 컴포넌트 스캐닝 기능에 의해 스프링 빈으로 등록됩니다.이렇게 어느 시점에서 정보를 제공할 것 인지를 처리할 수 있습니다.당연히 코드를 다른 사람이 볼떄 @Service 가 **있다면 “이거는 비지니스 로직을 처리하는 서비스코드”라고 코드를 읽는 사람들이 알 수 있겠죠용도가 뭘까?  컴파일 시 사용하는 정보  빌드 툴이 코드를 자동으로 생성할 때 사용하는 정보  실행 시 특정 시점에서 기능을 실행시키라는 정보"
  },
  
  {
    "title": "JAVA - SOLID에 대하여",
    "url": "/posts/JAVA%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-SOLID/",
    "categories": "java",
    "tags": "java, OOP, SOLID",
    "date": "2024-01-18 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 SOLID 에 대하여 정리합니다.SOLID?SOLID는 객체 지향 설계에서 중요한 5가지 원칙을 의미합니다각 글자는 이름의 첫글자를 따와서 지은 이름입니다.이것을 잘 지키면 결합도는 낮추고 응집도는 올릴 수 있습니다.결국 모듈, 클래스간의 상호 의존성은 낮춰 재사용성 , 수정 , 유지보수의 용의해집니다.또한, 구성요소들의 기능...",
    "content": "들어가며이번 포스트에서는 SOLID 에 대하여 정리합니다.SOLID?SOLID는 객체 지향 설계에서 중요한 5가지 원칙을 의미합니다각 글자는 이름의 첫글자를 따와서 지은 이름입니다.이것을 잘 지키면 결합도는 낮추고 응집도는 올릴 수 있습니다.결국 모듈, 클래스간의 상호 의존성은 낮춰 재사용성 , 수정 , 유지보수의 용의해집니다.또한, 구성요소들의 기능적 관련성이 높아짐으로 책임이 집중되고 , 독립성이 높아져재사용성 , 수정 , 유지보수가 용의해집니다.SRP - Single Responsibility Principle  - 단일 책임 원칙클래스는 하나의 변경 이유만 가져야 합니다.클래스는 단일 기능에 집중해야 하며 여러 가지 책임을 갖지 않도록 해야 합니다.다양한 경우가 있지만사람과 주식을 예로 들어보겠습니다.class 사람 {\tfinal static Boolean 한국인 = true;\tfinal static Boolean 미국인 = false;\tBoolean 인종;}public void 주식(){\tif(this.인종 == 한국인){\t\t\tSystem.out.print(\"쌀\");\t}else{\t\t\tSystem.out.print(\"빵\");\t}}이런 경우 주식() 이라는 메서드가 인종에 대한 모든 행위를 구현하려고 합니다.이런 경우가 SRP - 단일 책임 원칙을 위배한 경우를 말합니다.만약 옥수수를 주식으로 먹는 멕시코인을 추가하려면 어떻게 될까요?public class 사람 {    final static 인종 한국인 = 인종.한국인;    final static 인종 미국인 = 인종.미국인;    final static 인종 멕시코인 = 인종.멕시코인;    enum 인종 {        한국인,        미국인,        멕시코인    }    private 인종 인종;    public 사람(인종 인종) {        this.인종 = 인종;    }    public void 주식() {        switch (인종) {            case 한국인:                System.out.print(\"쌀\");                break;            case 미국인:                System.out.print(\"빵\");                break;            case 멕시코인:                System.out.print(\"옥수수\");                break;        }    }}예를 들어 이런식으로 구현할 수 있을 것입니다.생각보다 정말 많은 부분을 수정해야 합니다. 이런 경우가 결합도가 높아 생기는 문제로SRP는 이런 결합도를 줄이기 위해 사용됩니다.단일 책임 원칙을 잘 지키는 방법 중 추상화를 활용하는 방법이 대표적인데요추상화를 통해 결합도를 줄일 수 있기 때문입니다.다음 코드처럼 만들었다면 어떨까요?public abstract class 사람 {    // 추상 메서드 주식() 선언    public abstract void 주식();}Class 한국인 extends 사람{\t\t@Override\t\tpublic void 주식(){\t\t\t\tSystem.out.print(\"쌀\");\t\t}}Class 미국인 extends 사람{\t\t@Override\t\tpublic void 주식(){\t\t\t\tSystem.out.print(\"빵\");\t\t}}만약 여기에 옥수수를 먹는 멕시코인을 추가한다면public abstract class 사람 {    // 추상 메서드 주식() 선언    public abstract void 주식();}Class 한국인 extends 사람{\t\t@Override\t\tpublic void 주식(){\t\t\t\tSystem.out.print(\"쌀\");\t\t}}Class 미국인 extends 사람{\t\t@Override\t\tpublic void 주식(){\t\t\t\tSystem.out.print(\"빵\");\t\t}}Class 멕시코인 extends 사람{\t\t@Override\t\tpublic void 주식(){\t\t\t\tSystem.out.print(\"옥수수\");\t\t}}재사용성도 높아지고 , 코드의 변경도 적은걸 볼 수 있습니다.이런식으로 코드의 유지보수 , 수정 등의 이유를 들어 SRP 를 잘 지켜야 된다고 말할 수 있습니다.OCP - Open/Closed Principle- 개방-폐쇄 원칙소프트웨어 엔터티(클래스, 모듈, 함수)는 확장에는 개방되어 있지만, 수정에는 닫혀 있어야 한다라는 의미인데 사실 이해가 어렵습니다.extends 나 implements 를 통해 확장은 가능하지만주의의 변경이 일어난 경우에는 수정사항이 발생하면 안된다.라는 의미로 받아들일 수 있는데 결국기존 코드는 변화 No BUT 새로운 기능 추가 Yes이렇게 정리해 볼 수 있습니다.코드를 통해 예시를 들어보며 이해해 보겠습니다.public class 사람 {    private final String 국적;    public 사람(String 국적) {        this.국적 = 국적;    }    public void 주식() {        if (국적.equals(\"한국\")) {            System.out.print(\"쌀\");        } else if (국적.equals(\"미국\")) {            System.out.print(\"빵\");        } else {            throw new IllegalArgumentException(\"지원하지 않는 국적입니다: \" + 국적);        }    }}예를 들어 이런 코드를 하나 작성했다고 가정하겠습니다.그럼 옥수수를 먹는 멕시코인을 추가해보겠습니다.public class 사람 {    private final String 국적;    public 사람(String 국적) {        this.국적 = 국적;    }    public void 주식() {        if (국적.equals(\"한국\")) {            System.out.print(\"쌀\");        } else if (국적.equals(\"미국\")) {            System.out.print(\"빵\");        } else if (국적.equals(\"멕시코\")) {            System.out.print(\"옥수수\");        }else {            throw new IllegalArgumentException(\"지원하지 않는 국적입니다: \" + 국적);        }    }}else문이 중첩되며 코드의 가독성도 떨어지고 만약 이 메서드를 다른 곳에서 사용하기 어려워 집니다.결국 확장성이 줄며 재 사용성이 낮아집니다. 이는 유지 관리 , 버그 발생의 원인이 됩니다.그래서 OCP를 활용하는 좋은 방법 중 InterFace를 활용해 보겠습니다.public interface 주식 {    void 출력();}public class 사람 {    private final 주식 주식;    public 사람(주식 주식) {        this.주식 = 주식;    }    public void 먹는다() {        주식.출력();    }}public class 한국인 implements 주식 {    @Override    public void 출력() {        System.out.print(\"쌀\");    }}public class 미국인 implements 주식 {    @Override    public void 출력() {        System.out.print(\"빵\");    }}public class Main {    public static void main(String[] args) {        사람 한국인 = new 사람(new 한국인());        한국인.먹는다(); // 쌀 출력        사람 미국인 = new 사람(new 미국인());        미국인.먹는다(); // 빵 출력    }}이렇게 주식이라는 인터페이스를 미리 만들어두고, 필요에 따라 구현한다면 어떨까요똑같이 추가한다면 이런 식으로 할 수 있습니다.public interface 주식 {    void 출력();}public class 사람 {    private final 주식 주식;    public 사람(주식 주식) {        this.주식 = 주식;    }    public void 먹는다() {        주식.출력();    } }public class 한국인 implements 주식 {    @Override    public void 출력() {        System.out.print(\"쌀\");    }}public class 미국인 implements 주식 {    @Override    public void 출력() {        System.out.print(\"빵\");    }}public class 멕시코인 implements 주식 {    @Override    public void 출력() {        System.out.print(\"옥수수\");    }}public class Main {    public static void main(String[] args) {        사람 한국인 = new 사람(new 한국인());        한국인.먹는다(); // 쌀 출력        사람 미국인 = new 사람(new 미국인());        미국인.먹는다(); // 빵 출력                사람 멕시코인 = new 사람(new 멕시코인());        멕시코인.먹는다(); // 옥수수    }}코드가 지금은 더 길어 보일 수는 있어도 메서드의 내용이 복잡하고 어려울 수록 기존 코드를 변경하지 않고 내가 필요한 부분만 고쳐서 사용할 수 있다는 장점이 부각되게 됩니다.이전 포스트에서도 spring에서 예시를 들어 설명했던 부분이 있는데요Overriding에 대한 포스트를 한번 읽어보시는걸 추천드리겠습니다.  코드의 확장성을 향상시킵니다.  코드의 유지 관리성을 향상시킵니다.  코드의 변경 가능성을 줄여 버그 발생 가능성을 감소시킵니다.  코드의 재사용성을 향상시킵니다.정리하면 이런 장점을 OCP를 잘 사용하면 얻을 수 있습니다.특히, 스프링 프레임워크에서는 정말 많은 부분에서 활용해 둔 것도 알아둘 수 있습니다.LSP - Liskov Substitution Principle  - 리스코프 치환 원칙“하위 유형은 기본유형으로 대체가 가능해야한다.”상위클래스의 객체를 하위 클래스의 객체로 치환하여도 프로그램이 정상적으로 작동해야한다는 의미입니다.따라서하위형에서는 선행 조건을 강화 될 수 없고, 하위행에서 선행 조건을 약화 될 수 도없다.하위형에서는 상위형의 불변조건을 반드시 유지해야한다. 라는 내용도 포함되어 있습니다.코드를 통해 이해해 보겠습니다.public class 사각형 {    protected int 가로;    protected int 세로;    public 사각형(int 가로, int 세로) {        this.가로 = 가로;        this.세로 = 세로;    }    public int 넓이() {        return 가로 * 세로;    }}public class 정사각형 extends 사각형 {    public 정사각형(int 변) {        super(변, 변);    }    @Override    public void set가로(int 가로) {        this.가로 = 세로 = 가로;    }    @Override    public void set세로(int 세로) {        this.가로 = 세로 = 세로;    }}public class Main {    public static void main(String[] args) {        사각형 사각형 = new 사각형(4, 5);        System.out.println(\"사각형 넓이: \" + 사각형.넓이()); // 20 출력        사각형 = new 정사각형(4);        System.out.println(\"정사각형 넓이: \" + 사각형.넓이()); // 16 출력        ((정사각형) 사각형).set가로(5);        System.out.println(\"변경 후 사각형 넓이: \" + 사각형.넓이()); // 25 출력    }}만약 해당 클래스에서 사각형을 정사각형으로 변경하면 어떤 문제가 발생할까요?set가로를 부른 경우 세로의 값도 변경되게 되고, 그렇다면 원래 넓이를 구하는 방법과 달라져의도한 결과와 다른 문제를 가지고 올 수 있습니다.public interface 도형 {    int 넓이();}public class 사각형 implements 도형 {    protected int 가로;    protected int 세로;    public 사각형(int 가로, int 세로) {        this.가로 = 가로;        this.세로 = 세로;    }    @Override    public int 넓이() {        return 가로 * 세로;    }}public class 정사각형 implements 도형 {    private int 변;    public 정사각형(int 변) {        this.변 = 변;    }    @Override    public int 넓이() {        return 변 * 변;    }}public class Main {    public static void main(String[] args) {        도형 도형 = new 사각형(4, 5);        System.out.println(\"사각형 넓이: \" + 도형.넓이()); // 20 출력        도형 = new 정사각형(4);        System.out.println(\"정사각형 넓이: \" + 도형.넓이()); // 16 출력    }}그래서 이런식으로 인터페이스를 선언하고 상속 시켜 구현해 추상화시키면 각 클래스가 각 도형에 맞는 넓이의 계산공식을 도출하게 됩니다.그래면 사각형 클래스를 정사각형으로 변경하여도 정상적으로 작동할 수 있게 되겠죠.이런 원칙을 준수하면 확장성, 유지보수의 도움이 됩니다.ISP -  Interface Segregation Principle- 인터페이스 분리 원칙하나의 인터페이스는 너무 많은 기능을 포함하지 않고, 클라이언트가 실제로 사용하는 기능만을 포함해야 한다클라이언트가 사용하지 않는 기능을 포함하는 큰 인터페이스 대신에 작고 특정한 기능을 제공하는 여러 인터페이스를 사용하는 것을 의도하라는 원칙입니다.public interface 데이터처리 {    void 읽기();    void 쓰기();    void 업데이트();    void 삭제();}public class 파일처리 implements 데이터처리 {    @Override    public void 읽기() {        // 파일 읽기 기능 구현    }    @Override    public void 쓰기() {        // 파일 쓰기 기능 구현    }    @Override    public void 업데이트() {        // 파일 업데이트 기능 구현    }    @Override    public void 삭제() {        // 파일 삭제 기능 구현    }}public class 데이터베이스처리 implements 데이터처리 {    @Override    public void 읽기() {        // 데이터베이스 읽기 기능 구현    }    @Override    public void 쓰기() {        // 데이터베이스 쓰기 기능 구현    }    @Override    public void 업데이트() {        // 데이터베이스 업데이트 기능 구현    }    @Override    public void 삭제() {        // 데이터베이스 삭제 기능 구현    }}public class 프로그램 {    public void 데이터가져오기(데이터처리 데이터처리) {        데이터처리.읽기();    }    public void 데이터저장(데이터처리 데이터처리) {        데이터처리.쓰기();    }}이런식으로 작성을 하면 사용하는 부분은 읽기,쓰기 만 사용함으로 처리 class부분의 코드가 사용할 이유없이 길어지게 되면서 굳이 부르지 않아도 되는 메서드까지 불러서 사용을 하게 될 것입니다.만약 저 기능이 100줄짜리 코드라면 시스템 성능에 악영향을 미칠 가능성이 높게 되죠그래서public interface 읽기 {    void 읽기();}public interface 쓰기 {    void 쓰기();}public interface 업데이트 {    void 업데이트();}public interface 삭제 {    void 삭제();}public class 파일읽기 implements 읽기 {    @Override    public void 읽기() {        // 파일 읽기 기능 구현    }}public class 파일쓰기 implements 쓰기 {    @Override    public void 쓰기() {        // 파일 쓰기 기능 구현    }}public class 데이터베이스읽기 implements 읽기 {    @Override    public void 읽기() {        // 데이터베이스 읽기 기능 구현    }}public class 데이터베이스쓰기 implements 쓰기 {    @Override    public void 쓰기() {        // 데이터베이스 쓰기 기능 구현    }}// 업데이트, 삭제 인터페이스 및 구현 클래스도 추가 가능public class 프로그램 {    public void 데이터가져오기(읽기 읽기) {        읽기.읽기();    }    public void 데이터저장(쓰기 쓰기) {        쓰기.쓰기();    }}각각의 인터페이스를 분리해서 코드를 구현하게 되면클라이언트에서 사용하는 부분만 추려서 구현이 가능하게됩니다.만약 여기에 삭제 기능을 넣는다고 해도 다른 수정없이 바로 추가할 수 도 있어코드변경에 유동적이게 되고, 재사용성도 높아진다고 이야기 할 수 있습니다.DIP - Dependency Inversion Principle - 의존 역전 원칙고수준 모듈은 저수준 모듈에 의존해서는 안 되고, 둘 다 추상화에 의존해야 한다.추상화는 구체적인 구현에 의존해서는 안 되고, 구체적인 구현은 추상화에 의존해야 한다즉, 코드는 구체적인 구현보다는 추상화에 의존해야지 결합도가 낮아지고, 유연성과 유지 관리성이 높아진다는 의미입니다.,예를 들어 이런식으로 코드를 짜보겠습니다.public class 파일처리 {    public void 읽기(String filename) {        // 파일 읽기 로직 (파일 시스템 API 사용)    }    public void 쓰기(String filename, String data) {        // 파일 쓰기 로직 (파일 시스템 API 사용)    }}public class 프로그램 {    private 파일처리 파일처리 = new 파일처리();    public void 데이터가져오기(String filename) {        파일처리.읽기(filename);    }    public void 데이터저장(String filename, String data) {        파일처리.쓰기(filename, data);    }}직접 코드를 구현하기 때문에 테스트환경을 구축한다면 여러 문제가 발생할 수 있습니다.예를 들어 외부에서 받아온 경우에는 내부코드를 수정할 수 없거나 어렵기 때문에 테스트의 불 확실한 결과를 가져 올 것입니다.그러면 제품에 대한 신뢰도가 떨어지게 되겠죠public interface 데이터소스 {    String 읽기(String filename);    void 쓰기(String filename, String data);}public class 파일시스템데이터소스 implements 데이터소스 {    @Override    public String 읽기(String filename) {        // 파일 읽기 로직 (파일 시스템 API 사용)        return \"파일 내용\";    }    @Override    public void 쓰기(String filename, String data) {        // 파일 쓰기 로직 (파일 시스템 API 사용)    }}// 네트워크 데이터 소스, 데이터베이스 데이터 소스 등 추가 가능public class 프로그램 {    private 데이터소스 데이터소스;    public 프로그램(데이터소스 데이터소스) {        this.데이터소스 = 데이터소스;    }    public void 데이터가져오기(String filename) {        String data = 데이터소스.읽기(filename);        // 데이터 처리 로직    }    public void 데이터저장(String filename, String data) {        데이터소스.쓰기(filename, data);    }}이런식으로 인터페이스를 구축하여 추상화하고 구체적인 구현은 하위 클래스에서 처리하면 문제가 발생할 가능성이 없어지고, 외부라이브러리를 가져다 쓴다고 해도 테스트를 하는데 문제가 없어질 것입니다.spring에서 service코드를 구현할때 serviceImpl를 만들어 구체적인 구현을 해당 클래스에서 처리하는 것이 대표적인 예로 볼 수있습니다.정리하며이번 포스트에서는 SOLID 라고하는 자바 객체지향의 원칙을 알아보았습니다.결국 결합도는 낮추고 응집도는 높이기 위한 방법인데요각 원칙이 반드시 적용시킨다고해서 결합도와 응집도에 영향을 주는 것보다는각 원칙이 의도하는 방법대로 구현을 하기 위해 노력하다보면 자연스럽게연관되어 영향을 준다고 이해하면 좋을 것 같습니다."
  },
  
  {
    "title": "CS - 세션과 토큰 쿠키",
    "url": "/posts/CS-%EC%84%B8%EC%85%98%EA%B3%BC-%ED%86%A0%ED%81%B0-%EC%BF%A0%ED%82%A4/",
    "categories": "cs",
    "tags": "cs, session, cookie",
    "date": "2024-01-17 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 세션과 토큰 쿠키의 대하여 알아봅니다.웹서비스를 구축하다보면 세션과 쿠키 , 어플리케이션과 통신할 때는 토큰을 사용할 때 가 있습니다.최근에 vue.js로 작업을 해보며 State management 라이브러리 를 사용하면서세션과 쿠키를 활용한 정보전달 방식 뿐 아니라 다른 방법으로도 구현할 수 있다는 것도알게 되었는데 일단,...",
    "content": "들어가며이번 포스트에서는 세션과 토큰 쿠키의 대하여 알아봅니다.웹서비스를 구축하다보면 세션과 쿠키 , 어플리케이션과 통신할 때는 토큰을 사용할 때 가 있습니다.최근에 vue.js로 작업을 해보며 State management 라이브러리 를 사용하면서세션과 쿠키를 활용한 정보전달 방식 뿐 아니라 다른 방법으로도 구현할 수 있다는 것도알게 되었는데 일단, 이번 포스트에서는 백엔드 기준에서 어떤 식으로 구현해 볼 지에 대한 개념적인설명을 할 것 입니다.Cookie쿠키는 웹사이트가 사용자의 컴퓨터나 모바일 기기에 저장하는 작은 텍스트 파일입니다.쿠키는 사용자의 로그인 정보, 선호도, 설정 등을 저장하여 사용자 경험을 향상 시키는 데 사용됩니다.크게 3가지 분류로 쿠키의 종류를 파악하는데필수 쿠키웹사이트가 제대로 작동하기 위해 필요한 쿠키입니다. 예를 들어, 로그인 정보를 저장하거나 사용자의 장바구니 내용을 기억하는 데 사용됩니다.기능 쿠키웹사이트의 기능을 향상 시키는 데 사용되는 쿠키입니다. 예를 들어, 사용자의 선호하는 언어를 설정하거나 사용자의 위치를 기반으로 날씨 정보를 제공하는 데 사용됩니다.추적 쿠키사용자의 웹 활동을 추적하는 데 사용되는 쿠키입니다. 이 정보는 사용자에게 맞춤 광고를 제공하는 데 사용될 수 있습니다. 이런 방법을 트래킹 이라고 하는데 사용자를 분석하고 광고를 타켓팅하는 용도로 사용됩니다.고대 쿠키아주 예전 개발자들은 이 쿠키를 사용해서 클라이언트 측에 정보를 저장할 때 사용하곤 했는데요사실 쿠키라는 것은 파일이기 때문에 사용자가 열어볼 수 도 있고, 만약 암호화를 했다고 해도악의적인 사용자가 그런 쿠키 정보를 수집해서 해독하면 보안 상 큰 문제가 발생할 수 도 있습니다.따라서 최근에는 storage APIs 를 사용해 정보를 저장하는 것을 권장하는데이것은 web Storage 라고 부릅니다.web storage이런 web storage 는 크게 2가지가 있습니다.SessionStorage세션에 한정해 , 즉 브라우저가 닫히기 전까지만 데이터를 저장합니다.이런 데이터는 서버로 전송하지 않습니다.localStorage유효기간 없이 데이터를 저장합니다. js 또는 브라우저캐시 , 로컬 파일을 지워야 사라집니다.당연히 이런 데이터는 보안상 민감하지 않은 데이터들 , 예를 들어 어떤 페이지에 들어온 것, 로그인하지 않고 장바구니에 어떤 데이터를 담는 이런 데이터만을 취급해야합니다.어찌 되었든 쿠키는 보안상 문제를 발생시킬 가능성이 있어서 , 사용자가 특정 쿠키만 허용, 혹은 차단하도록 유도하는 기능이 대부분에 사이트에 있습니다.그리고 이런 방법을 극복하기 위해 Session이라는 방법을 알아봐야 합니다.Session세션은 웹 서버와 클라이언트 (사용자 컴퓨터) 간의 일련의 상호 작용을 의미합니다.사용자가 웹 사이트를 방문하면 서버는 사용자를 식별하고 이전 요청과 현재 요청을 연결하기 위해 세션을 생성합니다.세션은 사용자의 로그인 정보, 쇼핑 장바구니 내용, 방문 페이지 기록 등을 저장하는 데 사용됩니다.즉, 사용자의 개인정보를 보호 하는데는 더욱 효과적입니다.저도 햇갈렸습니다.여기서 간혹 햇갈리시는 분이 있는데 세션이라는 의미는 ‘기간’,’시간’ 이라는 의미입니다.결국 세션은 통신 과정 중 어느 시간 동안 통신을 하는 상호작용을 의미하는 것이지쿠키 처럼 어느 공간에 저장한다는 의미는 아닙니다.즉, 세션은 세션을 저장해둘 세션 저장소를 필요로 하고 보통 DB 를 기반으로 만듭니다.이것도 알아보자아주 러프하게 서버 파일로 관리를 할 수도 있는데요, 서버가 하나인 경우에는 가능합니다.그런데 최근 개발자들은 MSA - macrio service architecture 방식으로 서비스를 설계하는데요어려운 의미는 아니고 원래 하나의 큰서비스를 구축한다면 각각의 컴포넌트를 작게 나누어 각각 관리를 한다는 의미입니다.그래서 docker , kubernetes 같은 컨테이너 - 컨테이너 관리 서비스들도 각광받고 있는 것 이구요.따라서 db 서버를 운영하는 것이 최근 트렌드에서는 맞는 선택이라고 생각합니다.예전에는 서비스가 크지 않았기 때문에 하나의 서버로도 감당이 가능해서 상남자 스타일로 구현하시는 분들도 있다고 수업시간에 들어본적은 있긴 한데 제가 생각 했을 때는 좋은 방법은 아닙니다.session의 동작 방식      사용자가 웹 사이트를 방문하면 서버는 사용자를 식별하기 위해 고유한 세션 ID를 생성합니다.        세션 ID는 쿠키 또는 URL에 포함되어 사용자 컴퓨터에 저장됩니다.    사용자가 웹 사이트를 계속 방문하면 서버는 쿠키 또는 URL에서 세션 ID를 읽어 사용자를 식별합니다.  서버는 세션 ID를 사용하여 사용자의 세션 데이터를 찾아 사용자에게 맞춤화된 응답을 제공합니다.  사용자가 브라우저를 닫거나 웹 사이트에서 로그아웃하면 세션이 종료됩니다.저장 방식 비교그래서 세션을 쿠키에 저장하거나 아니면 url에 함께 보내는 방식이 있습니다.뭐 페이지 수가 많지 않은 서비스 혹은, 상남자 개발자 라면 url에 사용하는 방법도 가능합니다.제가 생각 했던 것을 정리해보면쿠키를 사용하면 정보를 사용자 , 클라이언트 측에 저장해서 서버 부하가 줄고, 맞춤화된 서비스를 제공하는 data수집에 용의 합니다.대신에 쿠키를 사용하지 않도록 거부하거나  저장된 데이터의 문제가 생길 가능성도 존재합니다.반대로 url을 사용하면 서버부하가 늘고, 데이터 수집이 어려우며 보안의 문제점이 생길 가능성이 발생하지만 장점으로는 쿠키를 사용하지 않는 사용자도 이용할 수 있다는 점입니다.그리고 쿠키는 자동으로 서버에 실어서 보내지기 때문에 따로 구축을 하지 않아도 된다는 점도 있습니다.따라서 선택은 각 개발자의 몫이지만 , 제가 생각했을 때는 쿠키를 활용하는 방식이 더 좋아 보입니다.쿠키 vs 세션위 글을 읽고 정리해보면 다음과 같습니다.쿠키는 사용자 컴퓨터 혹은 기기의 저장하고 이런 정보는 보안상 문제가 되자않는 정보를 위주로 저장한다.세션은 서버 컴퓨터의 저장하고 보안상 문제가 있을 데이터를 안전하게 제공한다.하지만 세션은 서버를 사용하기 때문에 서버의 부하가 발생할 가능성 + 비용 증가를 유도한다.이렇게 정리해보면 됩니다. 그리고 최근에는 토큰이라는 방법도 있는데요 이것도 한번 알아보겠습니다.토큰토큰은 어떤 이상하고 긴 문자열 입니다.암호환된 문자열을 만들어서 길고 무작위로 적힌 것 같은 문자열로 보여집니다.이렇게 쓸 수 있는 이유는 쿠키는 사실 저장하는 공간의 제한이 있습니다.브라우저마다 다르지만 최대 10MB를 넘는 일은 없습니다.따라서 토큰을 사용해서 이런 문제를 해결할 수 있습니다.그리고 가장 큰 목적은 어플리케이션 환경에서도 이런 쿠키를 사용하는 방법을 활용하기 위해서 입니다.어플리케이션의 경우 쿠키를 사용할 수 없습니다. 이런 쿠키는 브라우저 기반으로 동작하게 되니까요위에서 설명했던 모바일 기기는 말 그대로 모바일 기기로 브라우저에 접속한 경우를 말합니다.따라서 토큰을 사용해서 서버와 통신하게 됩니다.종류      JWT (JSON Web Token)    사용자 인증 및 정보 전송에 사용되는 표준 토큰        OAuth 토큰    API 액세스 권한 부여에 사용되는 토큰        암호화폐 토큰    블록체인 기반 암호화폐 또는 가상화폐  저는 JWT 방식을 로그인 기능과 API Access 기능을 구현하기 위해 사용해봤는데요https://github.com/Team-LifeTales/상당히 유용한 방식으로 구현이 가능합니다.JWT에 대해서는 다음 포스트에서 다루어보겠습니다.정리하며이번 포스트에서는 세션과쿠키 , 토큰에 대해서 알아봤습니다.사실 저는 프론트와 백엔드에 관심이 있어서 토큰을 사용해본 경험은 JWT 정도 입니다.따라서 개념적인 이해는 있어도 실제로 사용해본 경험이 적어서 다른 블로그 글도 참고해서 이해해 보시는 게 좋을 것 같습니다."
  },
  
  {
    "title": "redis에 대하여 - strings",
    "url": "/posts/redis%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-strings/",
    "categories": "redis",
    "tags": "redis, colletions, strings",
    "date": "2024-01-16 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 colletions 중 하나인 Lists 에 대하여 알아보겠습니다.개념Lists는 순서가 있는 문자열 요소들의 컬렉션을 저장하는 데 사용됩니다. 각 요소는 인덱스로 식별되며, 리스트의 시작 또는 끝에 요소를 추가하거나 제거하는 등의 작업을 수행할 수 있습니다.자바로 치면 ArrayList나 LinkedList와 유사한 데이터 ...",
    "content": "들어가며이번 포스트에서는 colletions 중 하나인 Lists 에 대하여 알아보겠습니다.개념Lists는 순서가 있는 문자열 요소들의 컬렉션을 저장하는 데 사용됩니다. 각 요소는 인덱스로 식별되며, 리스트의 시작 또는 끝에 요소를 추가하거나 제거하는 등의 작업을 수행할 수 있습니다.자바로 치면 ArrayList나 LinkedList와 유사한 데이터 구조 라고 알고 있습니다.쉽게 생각해 각 요소에 인덱스로 접근한다. 시작과 마지막을 통해 요소를 추가 , 삭제하는 작업을 할 수 있는 자료 구조입니다.사실 알고리즘을 공부하면 배열과 리스트는 다르게 구현합니다.배열은 인덱스를 통해 빠르게 조회가 가능한 대신 처음과 끝이 아닌 경우 다소 복잡한 방법을 거쳐 데이터를 추가해야 합니다.리스트는 인덱스 대신 노드와 이걸 연결하는 링크를 가지고 있습니다. 따라서 중간에 값을 연산해도 배열보다 빠르게 처리가 가능합니다.그래서 저는 보통 값을 쌓는 형태의 구조가 필요하면 배열을 잦은 연산이 필요한 경우 리스트를 사용한다고 알고 있었는데요이런 문제점을 개발자들이 이미 좋은 방식으로 바꿔서ArrayList나 LinkedList 를 사용할 수 있도록 해두었습니다.따라서 Redis에서 Lists를 사용할때는 처음과 끝만 연산이 가능한 큐처럼 사용할 수 있고Stack으로도 구현할 수 있다는 것도 같은 의미입니다.만약 중간에 값을 연산해야 한다면 다른 자료구조를 사용하거나삽입 부 전까지 삭제를 하고 넣은 다음 삭제한 부분을 다시 채워 넣는 방식으로 구현해야 합니다.사용법LPUSH/RPUSH리스트의 왼쪽/오른쪽에 요소를 추가합니다.LPUSH key value1 [value2 ...] / RPUSH key value1 [value2 ...]exLPUSH mylist \"1\"RPUSH mylist \"2\"LPUSH mylist \"3\"LPOP/RPOP리스트의 왼쪽/오른쪽에서 요소를 가져오고 제거합니다.흔히 큐에서 사용하는 pop이라고 생각해도 동일합니다.Lpop mylistRpop mylistLRANGE리스트에서 지정된 범위의 요소를 가져옵니다.LRANGE key start stopLrange mylist 0 -1이렇게 범위를 볼 수도 있습니다.여기서 L은 List의 Range 라고 생각하시면 됩니다.위 push와 pop 의 L 은 Left라고 생각하시면 이해하기 더욱 좋습니다.LLEN리스트의 길이(요소의 수)를 반환합니다.LLEN keyLlen mylistLINDEX리스트에서 지정된 인덱스의 요소를 가져옵니다.LINDEX key indexLREM리스트에서 지정된 값을 삭제합니다.LREM key count valueLREM mylist 2 \"2\"mylist 에서 “2” 값을 가진 것을 최대 2개까지 삭제한다는 의미입니다.ex일단 Rpush로 두개의 “2”를 삽입하겠습니다.이렇게 삭제가 되었습니다.참고로 Rrem이라고 하면 오른쪽부터 삭제될지 궁금해서 넣어봤는데안되는걸 보니 List rem 이라는 뜻으로 사용되는 것 같습니다.LTRIM리스트의 특정 범위의 요소만 유지하고 나머지 요소를 삭제합니다.LTRIM key start stop이렇게 값을 일단 추가해주겠습니다.Ltrim mylist 0 1이렇게 하면 0 ~1 을 제외한 나머지 요소를 삭제합니다.그래서 이런식으로 남게 됩니다.정리하며이번 포스트는 Redis 의 collections 중 Strings 타입에 대해 알아보았습니다.redis를 쓸 떄 가장 기초적으로 사용할 수 있는 부분입니다.추가로 redis 공식문서를 참고하면 더욱 많은 정보를 찾을 수 있습니다.이번 포스트에서는 제가 사용할법한 , 사용한 내용만 정리했습니다."
  },
  
  {
    "title": "redis에 대하여 - colletions",
    "url": "/posts/redis%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-colletions/",
    "categories": "redis",
    "tags": "redis, colletions, data",
    "date": "2024-01-15 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 Colletions에 대하여 이야기해보겠습니다.Colletions컬렉션은 레디스에서 제공하는 다양한 데이터 구조를 말합니다.  Strings: 가장 간단한 형태의 데이터 구조로 문자열을 저장합니다. 키와 값을 하나의 문자열로 저장하고, 여러 가지 연산을 수행할 수 있습니다.  Lists: 순서가 있는 문자열 목록을 저장합니다....",
    "content": "들어가며이번 포스트에서는 Colletions에 대하여 이야기해보겠습니다.Colletions컬렉션은 레디스에서 제공하는 다양한 데이터 구조를 말합니다.  Strings: 가장 간단한 형태의 데이터 구조로 문자열을 저장합니다. 키와 값을 하나의 문자열로 저장하고, 여러 가지 연산을 수행할 수 있습니다.  Lists: 순서가 있는 문자열 목록을 저장합니다. 리스트에 요소를 추가하거나 제거하고, 인덱스로 요소를 조회하거나 수정할 수 있습니다.  Sets: 중복이 허용되지 않는 문자열의 집합을 저장합니다. 집합에 요소를 추가하거나 제거하고, 합집합, 교집합, 차집합 등의 연산을 수행할 수 있습니다.  Sorted Sets: Sets와 유사하지만 각 요소에 순서가 지정되어 있습니다. 순서는 점수(score)로 지정되며, 요소는 이 점수에 따라 정렬됩니다.  Hashes: 키-값 쌍의 집합을 저장합니다. 각 키는 하나의 값과 연관되며, 여러 가지 연산을 통해 키의 값을 조회하거나 수정할 수 있습니다.코드 예시를 보며 실제로 해보겠습니다.Strings&gt; SET mykey \"Hello\"OK&gt; GET mykey\"Hello\"Redis에서 “Hello”라는 문자열을 “mykey”라는 키에 저장하는 명령어입니다.SET은 Redis의 문자열 데이터 타입을 설정하는 명령어이며, mykey는 키(key)이고 “Hello”는 해당 키에 대응하는 값(value)입니다.이렇게 저장된 값은 나중에 GET 명령어를 사용하여 다시 검색할 수 있습니다.Lists&gt; LPUSH mylist \"world\"(integer) 1&gt; LPUSH mylist \"hello\"(integer) 2&gt; LRANGE mylist 0 -11) \"hello\"2) \"world\"Redis에서 Lists는 순서가 있는 문자열 요소의 컬렉션을 나타냅니다. 이 리스트는 중복을 허용하며, 요소의 순서는 삽입 순서를 따릅니다.Lists는 연결 목록(linked list) 형태로 구현되어 있어서 삽입과 삭제가 O(1)의 시간 복잡도를 갖습니다.Lists의 주요 특징  순서 유지: 요소들은 삽입된 순서대로 저장되며, 인덱스를 통해 접근할 수 있습니다.  중복 허용: 동일한 요소를 여러 번 삽입할 수 있습니다.  삽입/삭제 효율: 연결 목록의 형태로 구현되어 있어서 삽입과 삭제가 효율적입니다.  리스트의 길이 제한 없음: Redis의 Lists는 동적으로 크기가 조정되므로 길이에 제한이 없습니다.길이를 주는 List + range → Lrange 를 통해 검색할 수 있고 0 -1 은 전체 조회를 의미합니다.Sets&gt; SADD myset \"apple\"(integer) 1&gt; SADD myset \"orange\"(integer) 1&gt; SADD myset \"banana\"(integer) 1&gt; SMEMBERS myset1) \"apple\"2) \"banana\"3) \"orange\"Redis에서 Sets(집합)은 중복되지 않는 고유한 요소들을 저장하는 데이터 구조입니다.Sets는 각 요소가 키와 연관된 정렬되지 않은 데이터 구조로, 각 요소는 중복되지 않습니다.특징  중복 요소가 없음: 각 요소는 집합 내에서 고유합니다.  정렬되지 않음: 요소들은 특정 순서로 저장되지 않으며, 요소의 순서는 무작위입니다.  집합 연산 지원: Redis Sets는 여러 집합 연산을 지원하며, 이를 통해 교집합, 합집합, 차집합 등을 쉽게 수행할 수 있습니다.  추가, 삭제, 존재 여부 확인 등 다양한 작업 지원: 요소를 집합에 추가하거나 삭제하고, 특정 요소의 존재 여부를 확인하는 등의 작업을 지원합니다.Sets는 주로 고유한 값의 컬렉션을 저장하고 관리하는 데 사용됩니다.Sorted Sets&gt; ZADD myzset 1 \"one\"(integer) 1&gt; ZADD myzset 2 \"two\"(integer) 1&gt; ZADD myzset 3 \"three\"(integer) 1&gt; ZRANGE myzset 0 -1 WITHSCORES1) \"one\"2) \"1\"3) \"two\"4) \"1\"5) \"three\"6) \"1\"Sorted Sets는 Set과 유사하지만 각 멤버에 대해 연결된 점수를 가지고 있습니다.이로써 멤버들은 정렬되어 있으며, 멤버 간의 관계를 표현할 수 있습니다.Sorted Sets는 멤버의 추가, 제거 및 갱신을 허용하며, 멤버에 대한 순위 및 범위 기반의 쿼리를 지원합니다.Hashes&gt; HSET myhash field1 \"value1\"(integer) 1&gt; HSET myhash field2 \"value2\"(integer) 1&gt; HGETALL myhash1) \"field1\"2) \"value1\"3) \"field2\"4) \"value2\"여러 필드와 값의 쌍을 저장하는 데이터 구조입니다. 각 필드는 문자열이며, 각 값은 문자열이거나 숫자일 수 있습니다.Hashes는 사용자가 쉽게 필드를 식별하고 해당 필드에 대한 값을 검색할 수 있도록 해줍니다.Hashes는 주로 관련 데이터를 하나의 키 아래에 그룹화하고 싶을 때 사용됩니다. 예를 들어, 사용자 프로필, 제품 정보, 설정 등과 같이 연관된 데이터를 저장하고 검색하는 데 유용합니다."
  },
  
  {
    "title": "redis에 대하여 - 들어가며",
    "url": "/posts/redis%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B5%AC%EC%A1%B0/",
    "categories": "redis",
    "tags": "redis, 구조, 캐시",
    "date": "2024-01-14 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 Redis에 대하여 공부해보겠습니다.Redis 란Remote Dictionary Server - 원격 사전 서버메모리 내에서 데이터 구조를 저장하고 관리하기 위한 키-값 저장소 입니다.오픈 소스의 인 메모리 데이터 저장소 라고 이야기 할 수 있습니다.여기서 키-값 저장소는 여러 언어들에서 지원하는 Dictionary 타입의 자료구조...",
    "content": "들어가며이번 포스트 Redis에 대하여 공부해보겠습니다.Redis 란Remote Dictionary Server - 원격 사전 서버메모리 내에서 데이터 구조를 저장하고 관리하기 위한 키-값 저장소 입니다.오픈 소스의 인 메모리 데이터 저장소 라고 이야기 할 수 있습니다.여기서 키-값 저장소는 여러 언어들에서 지원하는 Dictionary 타입의 자료구조들혹은 , NoSQL , Json 같은 데이터 구조를 의미합니다.//** 예를 들어{\t\"사람\" : \"세진\"}이런식으로 구조를 가지고 있습니다.인메모리?주 기억장치인 RAM(Random Access Memory)에 저장하는 것을 말합니다.Redis에서는 Cache에 저장한다 라고 표현하는데요Cache데이터나 값을 임시로 저장하는 메모리나 저장장치를 가리킵니다. 캐시는 주로 빠른 데이터 접근을 위해 사용되며, 이전에 액세스한 데이터에 대한 재 액세스 속도를 높이는 데 도움이 됩니다.“나중에 요청 올 결과를 미리 저장해두었다가 빠르게 서비스해주는 것”이라고 표현하면 됩니다.예를 들어 이런 식으로 설명해보겠습니다.미국에 있는 어떤 서비스를 받아오기 위해 한국에 있는 사용자가 요청을 주고 받고 있다고 가정해보겠습니다. 광 랜을 통해 빠르게 통신한다고 해도 많은 과정을 거쳐 소요가 발생하겠죠.최근 이슈였던 트위치 코리아 철수도 이런 문제들 때문 이였습니다. 한국의 ISP사들 - 통신사들이 깔아 놓은 망을 사용하고 트위치에 경우 본국의 ISP사에 지불하는 사용료 + 한국의 ISP사의 지불하는 사용료가 높아지며 철수 요인중 하나로 뽑히며 화제를 가지고 왔습니다.예를 들어 구글,유튜브 , 넷플릭스같이 더많은 사람들이 사용하는 사업체들은 그런 망을 사용하는데 비용은 물론 서비스 품질에도 악영향을 미치게 될 것입니다,그래서 나온게 캐시서버를 활용하는 방법입니다.이런식으로 사람들이 자주 사용하는 컨텐츠를 캐시서버를 설치에 두고 해당 서버에 저장해두면꼭 미국까지 갈필요없이 한국 내에서도 빠르게 서비스를 할 수 있게됩니다.제가 생각했을때는 이게 캐시를 사용하는 이유입니다.실제로 개발할 때 쓴다면 이런 식으로 쓸 수 있죠사람들이 자주 쓰는데이터 (Ex : 메인 페이지 , 인증토큰 등)는 Cache 서버에자주 쓰이지는 않는 데이터는 메인서버에 두면 서비스 품질도 향상되고 처리하기 위해대기하고 있는 서버도 좀 더 빠르고 유동적으로 서비스를 제공할 수 있게 됩니다.(물론 캐시에 저장했다고 RDB에 저장하지 않는 것은 아닙니다.)그래서 나온게 ReDis입니다.캐시의 구조(https://www.youtube.com/watch?v=mPB2CZiAkKM)우아한 테크 세미나에서 공부한 내용을 참고했습니다.Look-Aside Cache위에서 예로 설명한 구조와 같이 특정 자주 사용되는 데이터를 캐시에 저장해 두고 사용하는 구조를 말합니다.write BackDB에 쓰기 작업이 많은 경우에는 캐시에 저장할 데이터를 모아두었다가특정 시점에 Bacth툴을 사용하여 올려주면 훨씬 빠른 속도로 처리할 수 있습니다.예를 들어 , 1개의 데이터를 100번보내는 것과 100개의 데이터를 1번 보내는 것과의 차이는아주 크겠죠.제가 했던 저번 프로젝트 때 다양한 테이블의 저장되어있는 값들을 조회해서영수증으로 만들어 저장하고 이를 여러 API에서 불러지는 경우가 있었는데요이때, 저는 반정규화 - 즉, 데이터를 필요한 데이터만 따로 모아서 중복하게 만드는 방법을 사용해 처리했습니다.5개의 테이블에서 값을 뽑아서 한번 MongoDB에 저장해두면 이후에 조회 할때는 MongoDB를 통해 5회 테이블 조회를 스킵하는 구조로 데이터를 제공할 수 있었습니다.Spring에서도 SpringBacth가 있는데 이것도 나중에 한번 공부해보고 다루겠습니다.다음 포스트레디스의 Collections - 자료를 저장하는 구조에 대해서 이야기하겠습니다."
  },
  
  {
    "title": "redis에 대하여 - 설치",
    "url": "/posts/redis%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%A4%EC%B9%98/",
    "categories": "redis",
    "tags": "redis, 설치",
    "date": "2024-01-13 06:44:00 +0900",
    





    
    "snippet": "레디스의 대하여 설명하기 전 레디스 설치법을 알아보고 시작하겠습니다.윈도우 기준으로 설명하겠습니다.다운로드https://github.com/microsoftarchive/redis/releases여기서 msi 버전을 다운로드 해줍니다.설치간단하게 체크 하면서 필요 사항 있다면 수정해서 다운로드해줍니다.이렇게 폴더에 들어가면 redis-cli.exe 가...",
    "content": "레디스의 대하여 설명하기 전 레디스 설치법을 알아보고 시작하겠습니다.윈도우 기준으로 설명하겠습니다.다운로드https://github.com/microsoftarchive/redis/releases여기서 msi 버전을 다운로드 해줍니다.설치간단하게 체크 하면서 필요 사항 있다면 수정해서 다운로드해줍니다.이렇게 폴더에 들어가면 redis-cli.exe 가 있습니다.잘 작동하면 핑퐁합니다."
  },
  
  {
    "title": "자바에 대하여 - OOP 결합도",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B2%B0%ED%95%A9%EB%8F%84/",
    "categories": "java",
    "tags": "java, OOP, 결합도, Coupling",
    "date": "2024-01-12 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 결합도에 대하여 이야기 해보겠습니다.결합도?정보처리기사의 단골 문제이자 개념인 결합도 입니다.결합도(Coupling)는 소프트웨어의 구성 요소들 간에 서로 얼마나 의존적인지를 나타내는 개념입니다. 높은 결합도는 코드를 변경하기 어렵게 만들고 유지보수를 어렵게 할 수 있으며, 재사용성과 유연성을 저하시킬 수 있습니다. 반면에 낮...",
    "content": "들어가며이번 포스트에서는 결합도에 대하여 이야기 해보겠습니다.결합도?정보처리기사의 단골 문제이자 개념인 결합도 입니다.결합도(Coupling)는 소프트웨어의 구성 요소들 간에 서로 얼마나 의존적인지를 나타내는 개념입니다. 높은 결합도는 코드를 변경하기 어렵게 만들고 유지보수를 어렵게 할 수 있으며, 재사용성과 유연성을 저하시킬 수 있습니다. 반면에 낮은 결합도는 코드를 이해하기 쉽고 변경하기 쉽게 만들며, 구성 요소 간의 독립성을 높여 재사용성과 유연성을 향상시킵니다.출처 (wmasterj and Fabrice TIERCELIN - wikipedia:en:File:Coupling sketches cropped 1.jpg)이전 포스트에서 언급 하였듯이 객체지향 프로그래밍 OOP는 이전 세대인 절차적 프로그래밍의 업그레이드 버전입니다.절차적 프로그래밍에서 중요한 개념으로  종류는 다음과 같습니다.내용 결합도(높음)내용 결합도(Content coupling 또는 Pathological coupling)는 하나의 모듈이 다른 모듈의 내부 동작을 수정하거나 내부 동작에 의존하는 상태이다.(예: 다른 모듈의 로컬 데이터에 접근하는 경우)따라서 한 모듈이 데이터를 생성하는 방법(위치, 타입, 타이밍)을 변경하면, 다른 모듈의 변경이 필요하다.공통 결합도공통 결합도(Common coupling 또는 Global coupling)는 두 개의 모듈이 같은 글로벌 데이터를 공유하는 상태이다.(예: 전역 변수)공유 자원(변수)를 변경하면, 그 자원(변수)를 사용하는 모든 모듈의 변경이 필요하다.외부 결합도외부 결합도(External coupling)는 두 개의의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유할 때 발생한다. 이는 기본적으로 외부 툴이나 디바이스와의 통신과 관련이 있다.제어 결합도제어 결합도(Control coupling)은 하나의 모듈이 다른 모듈으로 무엇을 해야하는지에 대한 정보를 넘겨줌으로써 다른 모듈의 흐름을 제어하는 경우이다.스탬프 결합도스탬프 결합도(Stamp coupling 또는 Control coupling)는 모듈들이 데이터 구조를 공유하고, 그 서로 다른 일부만을 사용하는 경우이다.접근할 필요가 없는 필드만 수정되는 경우에도 (데이터의 배치가 변경되므로), 레코드(필드)를 읽는 방법을 변경해야 한다.자료 결합도자료 결합도(Data coupling)는 모듈들이 파라메터 등을 통해 데이터를 공유하는 경우이다. 각 데이터가 기본적인 것(elementary piece)이고, 그 데이터들이 공유되는 유일한 데이터이여야 한다. (예, 제곱근을 계산하는 함수로 하나의 정수를 전달하는 경우)메시지 결합도(Message coupling)(낮음)가장 낮은 결합도이다. 이는 state decentralization을 통해 이룰 수 있고, 컴포넌트 간의 통신은 파라메터나 메시지 패싱을 통해 이루어져 한다.결합도 없음(No coupling)모듈이 어떠한 다른 모듈과도 통신하지 않는 경우이다.Java에서 결합도 줄이기읽어보면 결합도는 줄이고 응집성은 높이는 것을 생각하라는 의미입니다.결국 결합도는 구성 요소 간의 상호 의존성을 줄여야 된다는 의미이고응집성은 구성 요소 내부의 상호 의존성을 높여야 한다는 의미입니다.여기서 구성 요소는 모듈 , 클래스 , 객체 등을 의미합니다.위 언급한 추상 클래스 - 추상 메서드를 사용하여 인터페이스화 시키는 방법을 코드를 통해 이해해 보겠습니다.강한 결합도의 예시public class ShoppingCart {    private Item item;    public void addItem(Item item) {        this.item = item;        // 장바구니에 상품을 추가하는 로직    }    public void checkout() {        // 결제 처리하는 로직        PaymentProcessor paymentProcessor = new PaymentProcessor();        paymentProcessor.processPayment(item.getPrice());    }}public class PaymentProcessor {    public void processPayment(double amount) {        // 결제 처리하는 로직    }}위의 코드에서 ShoppingCart 클래스는 결제 처리를 위해 PaymentProcessor 클래스를 직접 생성하고 호출합니다. 이는 ShoppingCart가 PaymentProcessor에 강하게 결합되어 있음을 보여줍니다. 만약 결제 처리 방식을 변경하려면 ShoppingCart 클래스의 코드를 수정해야 합니다.낮은 결합도의 예시public class ShoppingCart {    private PaymentProcessor paymentProcessor;    public ShoppingCart(PaymentProcessor paymentProcessor) {        this.paymentProcessor = paymentProcessor;    }    public void checkout() {        // 결제 처리하는 로직        paymentProcessor.processPayment();    }}public interface PaymentProcessor {    void processPayment();}public class CreditCardProcessor implements PaymentProcessor {    @Override    public void processPayment() {        // 신용카드 결제 처리하는 로직    }}public class PayPalProcessor implements PaymentProcessor {    @Override    public void processPayment() {        // PayPal 결제 처리하는 로직    }}위의 코드에서 ShoppingCart 클래스는 결제 처리에 대한 인터페이스인 PaymentProcessor를 사용합니다. 이렇게 하면 ShoppingCart 클래스가 특정 결제 처리 방식에 의존하지 않고, 다양한 결제 처리 방식을 지원할 수 있습니다. 이것이 낮은 결합도를 보여주는 예시입니다.개인적인 생각공부해보며 지금까지 작성했던 코드들에 대한 생각을 하였습니다.분명 공부하며 개념적인 이해를 하였다고 생각하였는데 막상 코드를 작성할 때는이런 원리를 적용하지 않고 기능 구현에만 너무 초점을 두었다는 생각을 하게 되었습니다.특히, 결합도에 대해 생각해보면 구현에 집중해 수정 사항 반영이 상당히 힘들었던 점들이생각 났습니다.보통 작성을 할때 1번 코드처럼 작성하지 다중 상속이 필요한 경우가 아니면interface를 사용하지 않았던 것으로 생각합니다.최근 프로젝트에서 칵테일을 만드는 로직에서 좌표계 값을 선언해두고 관련된 위치를 찾아 Gcode로 변환하는 코드를 작성한 경험이 있는데이때 추상 메서드와 인터페이스를 활용해서 작성했다면 훨씬 좋은 코드를 작성할 수 있었을 것이라는 생각이 듭니다.의존성을 줄이는 방법들위 이야기한 결합도에 대한 이야기는 결국 의존성에 대한 이야기 입니다.내부요소 - 클래스 , 객체 간의 의존성이 높아지면 한쪽이 문제가 생겼을 때 도미노처럼문제가 발생하기 때문입니다.그리고 그중에서 interFace를 활용하는 방법 즉, 추상화를 사용하는 방법에 대해서 이야기하였는데요이외에 여러 방법이 있습니다.      의존성 주입(Dependency Injection)    객체 간의 의존성을 외부에서 주입하여 결합도를 낮춥니다.        의존성 역전 원칙(Dependency Inversion Principle, DIP)    고수준 모듈이 저수준 모듈에 의존하도록 하는 것이 아니라, 둘 다 추상화된 인터페이스에 의존하도록 설계합니다.        캡슐화(Encapsulation)    클래스의 내부 상태를 외부에서 직접 접근하지 못하도록 하여 결합도를 낮춥니다.  캡슐화는 이전에도 이야기하였듯이 접근을 제어하는 것이고, 즉 정보를 은닉할 수 있다는 이야기 입니다.의존성 주입 - DI의존성 주입 - DI는 스프링 포스트를 작성하면서 추가로 해볼 생각입니다.따라서 간단하게 이야기 하면 의존 관계를 외부에서 설정하는 방법으로 하나의 디자인 패턴입니다.디자인 패턴이란 많은 개발자들이 개발을 할 떄 큰 범위에서는 유사한 기능,세부적인 디테일에서 차이가 발생하는데 이때 큰 범위에서의 스터디 셀러를 정리한 방식을 의미합니다. 보통 이런 문제는 이런식으로 하면 되더라 - 라는 개발 지침서? 정도로 생각하면 됩니다.이것도 이후 포스트에서 이야기 해 볼 것 입니다.스프링에서는 주로 xml , 어노테이션 , 자바를 통해 의존성을 주입하는데xml 방식은 교수님이 현직에 있으실 때 쓰던 방식이고, 최근에는 레거시를 하는 것이 아니라면 굳이 사용하지는 않는다고 알고 있습니다.어노테이션은 Component , Autowied 등이 있는데 자세한 내용은 해당 포스트를 적으며 설명하고자바는 자바코드를 통해 선언하는 것으로 @Configuration 을 통해 @Bean을 선언하여 만듭니다.정리하면 DI는 외부에서 관계를 설정해서 의존성을 줄이는 방법을 말합니다. 즉, 결합도를 줄이는 방법입니다.의존성 역전 원칙의존성 역전 원칙(Dependency Inversion Principle, DIP)은 객체 지향 설계 원칙 중 하나로고수준 모듈이 저수준 모듈에 의존하면 안 되며, 둘 다 추상화에 의존해야 한다는 원칙을 말합니다.이는 추상화된 인터페이스나 추상 클래스를 통해 상위 수준의 모듈이 하위 수준의 모듈과 상호작용하게 함으로써 의존성을 역전시키는 것을 의미합니다.이건 SOLID 라고 불리는 OOP 설계 5원칙을 말 할때 쓰는데 이 것도 추상화와 관련된 개념입니다.자세한 내용은 이후 포스트에서 다루겠습니다.이번 포스트에서는 결합도에 대한 이야기를 하는 것이니 상세한 내용은 다른 포스트들을 참조해주세요정리하며이번 포스트에서는 결합도를 어떻게 줄 일 수 있을지에 대해 이야기해봤습니다.자바에서는 어떻게 결합도를 줄일 수 있는지 방법에 대해 이야기 해봤습니다.작성하면서 새로운 개념들이 나오는데 모두 정리하면 너무 길어져서간단하게만 정리해봤습니다.개인적인 생각사실 이번 공부를 하며 약간 충격이였던게, 최근 프로젝트에서 대부분의 기능을 구현하며 정말 짧은시간에 많은 기능구현을 해야한 경험 탓에 그래도 이정도 시간에 이렇게 많이 구현해 낼 수 있으면좀 잘하는거 아닌가 생각했었던 제 자신을 돌아보게 되었습니다.코드는 양보다 퀄리티가 중요하다고 늘 듣던 말인데 이런 기본적인 것을 놓치고 하였던 것이더 성장할 수 있는 계기가 된다고 생각합니다.다음포스트결합도를 공부해봤으니 응집도에 대해서 공부해봐야겠죠응집도에 대하여 입니다."
  },
  
  {
    "title": "자바에 대하여 - OOP 실사용2",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-OOP%EC%9D%98-%EC%8B%A4%ED%99%9C%EC%9A%A92/",
    "categories": "java",
    "tags": "java, OOP, 추상화, Interface, extends, implements",
    "date": "2024-01-11 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 Interface에 대하여 정리합니다.Interface?기존의 인터페이스가 가르키는 말은 다음과 같습니다.서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면즉, 사용자가 기기를 쉽게 동작 시키는데 도움을 주는 시스템을 의미합니다.이런 화면들도 인터페이스 화면입니다.Java에서 Interfa...",
    "content": "들어가며이번 포스트에서는 Interface에 대하여 정리합니다.Interface?기존의 인터페이스가 가르키는 말은 다음과 같습니다.서로 다른 두 개의 시스템, 장치 사이에서 정보나 신호를 주고받는 경우의 접점이나 경계면즉, 사용자가 기기를 쉽게 동작 시키는데 도움을 주는 시스템을 의미합니다.이런 화면들도 인터페이스 화면입니다.Java에서 Interface클래스가 가져야 하는 메서드의 명세(specification)를 정의합니다.즉, 인터페이스는 어떤 클래스가 특정한 메서드를 반드시 구현해야 한다는 것을 보장합니다. 인터페이스는 클래스가 아닌, 구현되지 않은 메서드의 집합을 나타냅니다.// 동물의 소리를 나타내는 인터페이스interface Animal {    void makeSound();}// 각각의 동물 클래스들이 해당 인터페이스를 구현class Dog implements Animal {    @Override    public void makeSound() {        System.out.println(\"멍멍\");    }}class Cat implements Animal {    @Override    public void makeSound() {        System.out.println(\"야옹\");    }}class Cow implements Animal {    @Override    public void makeSound() {        System.out.println(\"음메\");    }}public class Main {    public static void main(String[] args) {        Animal dog = new Dog();        Animal cat = new Cat();        Animal cow = new Cow();        dog.makeSound(); // 멍멍        cat.makeSound(); // 야옹        cow.makeSound(); // 음메    }}예시 코드처럼 인터페이스로 선언하고 내부에 메서드는 구현되지 않은 상태입니다.이전 추상메서드 포스트에서 이야기 한 것과 동일합니다.즉, 인터페이스는 추상메서드를 통해서만 구현이 가능하다는 것을 말합니다.특징이 여러가지 있는데      상수 정의 : 자바에서 상수를 정의할 때는 public static final을 붙여 정의합니다.    자동으로 선언하여 관리됩니다.    다중상속 = 다형성을 구현할 수 있습니다. - implements  객체의 역할을 지정합니다. 따라서 특정 객체가 어떤 행위를 해야하는지를 정의 해둘 수 있습니다.이렇게 인터페이스를 쓰게 되면 하나의 메서드의 종속되는 결합도를 줄일 수 있습니다.따라서 재사용성이 높아지고 , 코드의 효율성이 높아집니다.implements?implements란 구현하다. implement는 도구 라는 의미입니다.추상 클래스에서 추상 메서드를 통해 명세한 - 선언한 메서드를implements - 구현하겠다 라는 의미로 생각됩니다.자바에서 상속을 구현하는 두가지 방법중 하나입니다.다중 상속을 구현할 수 있는 방법인데사실 자바에서는 다중 상속을 지원하지 않습니다.? 방금 지원한다매다중 상속을 java가 금지한 이유그 이유는 여러가지 있지만 가장 대표적으로다이아몬드 문제 방지다중 상속을 허용하면 다이아몬드 문제가 발생할 수 있습니다.이는 하위 클래스가 여러 상위 클래스로부터 상속 받을 때, 상위 클래스 간의 충돌이 발생할 수 있는 문제입니다. 이로 인해 코드의 복잡성이 증가하고, 가독성이 떨어지며 디버깅이 어려워집니다.즉, 여러개의 클래스를 상속 받으면 충돌이 발생하였을 때 어디서 문제가 발생하였는지 찾기 힘들어집니다.그래서 Spring을 사용할 때시험 문제였던걸로 기억합니다.1번 클래스 , 2번 클래스의 상속을 받아 3번 클래스를 구현 해야 하는 일이 있었습니다.그래서 저는 2번을 1번으로 부터 자식 클래스로 두고 다시 2번 클래스를 3번 클래스의 부모로 만들어 해결했던 경험이 있습니다.코드가 돌아가서 맞은 걸로 채점이 되었던 것 같은데지금 공부해보며 생각이든게 인터페이스를 구현해서 문제를 해결하라는 의도였던 것 같습니다.어쨌든 다이아몬드 문제방지 이외에도  명확성과 복잡성: 다중 상속은 클래스 간의 관계를 복잡하게 만들 수 있습니다. 특히 다중 상속을 사용할 때 클래스의 메서드 충돌을 해결하는 방법이 명확하지 않을 수 있습니다. 이는 코드의 이해와 유지보수를 어렵게 만듭니다.  디자인의 목적: Java의 설계 목표 중 하나는 간결하고 명확한 객체 지향 디자인을 제공하는 것입니다. 다중 상속은 이 목표를 방해할 수 있습니다. 대신 인터페이스와 추상 클래스를 통해 다중 상속과 유사한 기능을 제공하면서도 이러한 문제를 방지할 수 있습니다.  자바의 단순성: Java는 간결하고 단순한 언어로 유명합니다. 다중 상속을 지원하면 언어의 복잡성이 증가할 수 있으며, 개발자들이 언어를 이해하고 사용하는 데 어려움을 겪을 수 있습니다.위와 같은 이유로 다중 상속을 지원하지 않습니다.public interface PaymentProcessor {    void processPayment();}public class CreditCardProcessor implements PaymentProcessor {    @Override    public void processPayment() {        // 신용카드 결제 처리하는 로직    }}이런식으로 사용하는데extends 와 가장 큰 차이점은 @Override 즉, 오버라이딩에 대한 명시를 해야 하느냐의 차이입니다.아래 포스트의 관련 내용을 정리해 놨습니다.중요한 것은 그럼 exteds는 @Override 안쓰냐 - 아니요 씁니다.이전 포스트에서도 말하였지만 해당 어노테이션은 자바 컴파일러에게 여기 상속받아요라고 알려주는 겁니다.없어도 알아서 찾아보지만 명시해두면 문제가 생길 가능성을 먼저 제거합니다.따라서 사용을 하는 것이 좋지만 exteds는 @Override를 안쓴다고 컴파일러가 오류로 처리하지 않는다는 의미입니다.왜 오류로 안잡냐클래스가 다른 클래스를 확장할 때, 해당 클래스가 이미 컴파일된 바이트 코드에 포함되어 있기 때문입니다.따라서 컴파일러는 자식 클래스가 부모 클래스의 메서드를 오버라이드하고 있는지를 정확히 알 수 있습니다.즉, 부모 클래스에서 이미 정의를 한 내용을 자식 클래스에서 그대로 받아 쓸 수 도 있기 때문입니다.즉, extends는 class - class 간의 상속을 정의하고 자바에서는 기본적으로 class간의 상속은 1회로 규정하는 것입니다.그런데 interface는 추상 메서드를 선언하고 implements로 선언된 실제 클래스에서 구현됩니다.이전 포스트에서 추상클래스의 메서드인 추상 메서드는 전부 구현하지 않고 불안정한 상태에서 구현을 상속받은 클래스에서 구현한다고 이야기 하였습니다.이런이유로 implements의 경우 반드시 @Overrid를 붙여야 컴파일러가 알 수 있기 때문에오류를 발생 시키는 것 입니다.다중 상속의 구현 implements즉, 다중 상속은 안됩니다. - 그런데 implements를 통해서 라면유사하게 기능을 구현할 수 있습니다.// 인터페이스 1interface Animal {    void sound();}// 인터페이스 2interface Movable {    void move();}// Animal과 Movable 인터페이스를 모두 구현하는 클래스class Dog implements Animal, Movable {    @Override    public void sound() {        System.out.println(\"멍멍\");    }    @Override    public void move() {        System.out.println(\"걷기\");    }}// 사용 예시public class Main {    public static void main(String[] args) {        Dog dog = new Dog();        dog.sound(); // 멍멍        dog.move(); // 걷기    }}이런 방법으로 구현해 볼 수 있습니다.이것이 왜 필요하냐면 만약 extends만 사용해? 구현하려면class가 더 많이 필요하고 , 더 많은 쓸데없이 선언하는 코드가 증가하게 되고 서로 간의 종속이 생기게 됩니다.당연히 코드 읽기 복잡해지고, 유지 보수가 어려워 진다는 점이 생깁니다.따라서 해당 방법을 통해 특정 메서드를 복수개 처리할 때 사용해 볼 수 있습니다.개인적인 생각근데 구현한다 는 의미가 상속과 같은 선상에서의 의미인지는 잘 모르겠습니다.상속한다는 것은 받아와서 사용한다는 의미이고, 이것을 그대로 사용하던 바꿔서 사용하던의 문제인데구현한다는 것은 말 그대로 구현하는 건데 음.. 관련된 정보를 보게 되면 공유하겠습니다!정리하며이번 포스트에서는 interface에 대해 이야기 해봤습니다.interface는 추상메서드를 선언하고 이런 추상메서드는 implements를 통해 구현한다.implements를 사용하면 다중 상속과 유사한 기능을 구현할 수 있고,extends와의 차이점에 대해서도 이야기 해봤습니다.사실 implements vs extends는 정말 자료가 많습니다.다음포스트결합도의 대하여"
  },
  
  {
    "title": "자바에 대하여 - OOP 실사용",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-OOP%EC%9D%98-%EC%8B%A4%ED%99%9C%EC%9A%A9/",
    "categories": "java",
    "tags": "java, OOP, 추상화, Abstract, new, final",
    "date": "2024-01-10 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 OOP와 자바에서 활용하는 방법을 정리합니다.원래 어노테이션에 대해 정리해보려고 했는데 해당 개념을 먼저 공부해보는 것이 이해하기 더좋다고 생각이 들어 먼저 정리했습니다.JAVA , C++ , Python 등의 많은 소프트웨어에서 지원하는 프로그래밍 방법입니다.이번 포스트에서는 자바에서 어떤식으로 OOP 즉, 객체 지향을 사용...",
    "content": "들어가며이번 포스트에서는 OOP와 자바에서 활용하는 방법을 정리합니다.원래 어노테이션에 대해 정리해보려고 했는데 해당 개념을 먼저 공부해보는 것이 이해하기 더좋다고 생각이 들어 먼저 정리했습니다.JAVA , C++ , Python 등의 많은 소프트웨어에서 지원하는 프로그래밍 방법입니다.이번 포스트에서는 자바에서 어떤식으로 OOP 즉, 객체 지향을 사용하고확장하여 개발자들이 사용하게 하였는지에 대한 정리를 하며 공부한 내용을 공유합니다.OOP는 이전 포스트에서 정리하여서 관련 링크를 함께 첨부합니다.OOP?OOP는 Object-Oriented Programming(객체 지향 프로그래밍)자세한 설명은 아래 링크를 통해 확인해보세요Abstract이전 포스트에서도 언급하였듯이 추상에 대한 개념입니다.추상은 간단히 말하여 특정 부분을 부각 - 즉, 공통된 특징을 부각하여 강조하기 위한 방법입니다.JAVA에서는 Abstract Method (추상 메서드)를 지원합니다.특징은 추상 메서드가 없어도 추상 클래스를 선언할 수 있다는 점입니다.abstract class Shape {    // 추상 메서드가 없는 추상 클래스    // 추상 클래스 내에는 추상 메서드가 없어도 됩니다.    // 필드    protected String color;    // 생성자    public Shape(String color) {        this.color = color;    }    // 일반 메서드    public void setColor(String color) {        this.color = color;    }    public String getColor() {        return color;    }    // 추상 메서드가 없지만, 이 클래스는 추상 클래스로 선언되어 있습니다.}이런식으로 추상 메서드없이 선언하여 사용할 수 있습니다.만약 추상메서드가 있다면 이런 식으로 만들어볼 수 있습니다.abstract class Shape {    // 추상 메서드    abstract double getArea();    // 필드    protected String color;    // 생성자    public Shape(String color) {        this.color = color;    }    // 일반 메서드    public void setColor(String color) {        this.color = color;    }    public String getColor() {        return color;    }} 그럼 추상 메서드가 없는 추상 메서드는 동작은 어떻게 구현할 수 있을까요?public class Main {    public static void main(String[] args) {        // 추상 클래스는 직접 객체를 생성할 수 없습니다.        // Shape shape = new Shape(); // 컴파일 에러        // 하지만 추상 클래스의 하위 클래스를 통해 객체를 생성할 수 있습니다.        Circle circle = new Circle(\"red\", 5.0);        System.out.println(\"Color of circle: \" + circle.getColor());        System.out.println(\"Area of circle: \" + circle.getArea());    }}class Circle extends Shape {    private double radius;    // 생성자    public Circle(String color, double radius) {        super(color);        this.radius = radius;    }    // 원의 넓이를 계산하는 메서드    public double getArea() {        return Math.PI * radius * radius;    }}이런식으로 extends -확장하여 상속받아 자식 클래스에서 메서드를 구현하면 됩니다.그렇다면 부모 추상 클래스에 메서드를 선언했다면 어떻게 구현할 수 있을까요?public class Main {    public static void main(String[] args) {        // 추상 클래스는 직접 객체를 생성할 수 없습니다.        // Shape shape = new Shape(); // 컴파일 에러        // 하지만 추상 클래스의 하위 클래스를 통해 객체를 생성할 수 있습니다.        Circle circle = new Circle(\"red\", 5.0);        System.out.println(\"Color of circle: \" + circle.getColor());        System.out.println(\"Area of circle: \" + circle.getArea());    }}class Circle extends Shape {    private double radius;    // 생성자    public Circle(String color, double radius) {        super(color);        this.radius = radius;    }    // 원의 넓이를 계산하는 메서드    @Override    double getArea() {        return Math.PI * radius * radius;    }}이전 포스트에서 이야기한 Overriding - 덮어쓰기를 통해 Circle 자식클래스에서 메서드를 구현하면 됩니다.이렇게 구현하는 경우에는 부모 클래스에서 접근제어자를 선택한다는 점이 있습니다.저는 이런식으로 사용합니다.만약, 추상 클래스를 통해 메서드를 구현하고 싶다.자식 메서드를 통해 구현 - 부모 클래스에서 선언X메서드 중 접근제어를 따로 관리해야 하는 경우, 특정 부분만 해당 메서드를 사용하는 경우부모 메서드를 통해 구현메서드 중 접근제어가 모두 동일하고, 기능이 대부분의 경우 사용하는 경우제가 지금까지 해봤던 범위에서는 Abstract 가 필요한 경우 부모 메서드를 통해 구현하는 것이 유리한 경우가 많았습니다. (코드 가독성, 재사용성)근데 추상 클래스는 new가 안되네 왜?new는 말 그래도 새로 생성한다는 의미입니다.자바에서 클래스의 인스턴스를 새로 생성한다는 의미인데 이것은 곧, 객체를 새로 만드는 다는 의미입니다.그런데 추상 클래스의 장점이 추상 메서드를 여러 방향으로 구현할 수 있어 유연한 코드를 만드는 것입니다.즉, 부모 클래스의 해당하는 추상 클래스의 경우 불안정한 메서드 상태 , 구현이 다 되지 않은 메서드를 가지고 있습니다.그렇기 때문에 자바에서 추상 클래스가 새로운 객체를 만들지 못하도록 한것 입니다. (불안정하기 때문에)따라서 자식 클래스의 해당 하는 부분에서 완벽하게 객체에 대한 정의를 하고 나서 해당하는 실체화 (concrete)된 클래스를 new 를 통해 생성할 수 있도록 유도한 것입니다.New - 생성자에 대하여위 소개한 new 키워드는 생성자를 의미합니다. - 객체를 새로 만든다.사람 양세진 = new 사람();() 이거는 메서드에서 사용하는 인자를 받기 위한방법인데?즉, 클래스명() = 메서드 → 객체를 생성하는 메서드 = 객체 생성자 메서드 = 생성자자바가 자동으로 기본 생성자를 만들어 준다는 것을 알 수 있는 방법입니다.이런 방법이 저번 포스트에서 언급한 오버로딩을 활용한 방법이라고 알 수 있는 것입니다.따라서 이런식으로 하면 에러가 나옵니다.사람 양세진 = new 사람(\"Java\");사람 손흥민 = new 사람();위에서 객체를 생성하며 인자가 한개 이상있는 생성자를 만들면이후 부터는 자바가 자동으로 기본생성자를 만들어 주지 않는다는 것을 알 수 있습니다.Final - 최종final 키워드는 최종 이라는 의미입니다.클래서 , 변수 , 메서드 에 붙여 사용하는데이 의미는 더이상 상속을 허용하지 않겠다. 즉, 오버라이딩을 할 수 없게 하겠다 라는 의마가 됩니다.예로,js에서 변수를 불변하게 선언할 때 const를 쓰는것과 같은 의미로 받아드리면 됩니다.public final class 사람();public class 양세진 extends 사람 (){}이런식으로 사용하면 에러가 나겠죠. 왜냐하면 class 가 최종적으로 선언되어있고 이후에는 상속을 허용하지 않았기 때문입니다.스프링에서는 주로 가져온 Package를 필요에 맞게 오버라이딩하고 해당 클래스를 final로 선언하여 이후에는 수정이 불가능하게 만들어 둡니다.이런식으로 만들어 두면 상속을 통해 충돌하거나 중복되는 경우를 예방할 수 있게 돼서 사용하는 것으로 알고 있습니다. (정확한 내용은 아니라 다른 이유가 있다면 댓글 부탁 드립니다.)정리오늘은 OOP를 실제 자바에서 어떻게 구현할 수 있는지에 대해 이야기 해봤습니다.추상화에 대한 Abstract에 대해 이야기 해보며 어떤 식으로 사용하는지관련된 new와 final 키워드에 대한 내용도 정리해보며 이야기를 나누었습니다.인터페이스에 대한 이야기도 추상화와 관련이 있어 함께 정리하려 했는데내용이 길어져 다음포스트에서 이어 진행하겠습니다.다음 포스트Interface 에 대하여"
  },
  
  {
    "title": "자바에 대하여 - OverLoding & OverRiding",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-OverLoding-&-OverRiding/",
    "categories": "java",
    "tags": "java, OOP, 다형성, OverLoding, OverRiding",
    "date": "2024-01-09 06:44:00 +0900",
    





    
    "snippet": "6.JAVA-OverLoding &amp; OverRiding들어가며이번 포스트에서는 overLoding 과 OverRiding에 대한 이야기를 해보려고 합니다.OOP 에서 다형성을 구현하는 두 가지의 중요한 개념입니다.OOP - 다형성 Polymorphism다형성 (Polymorphism)은 이전 포스트에서 간단하게 정리하여서 개념만 집고 넘어가면같...",
    "content": "6.JAVA-OverLoding &amp; OverRiding들어가며이번 포스트에서는 overLoding 과 OverRiding에 대한 이야기를 해보려고 합니다.OOP 에서 다형성을 구현하는 두 가지의 중요한 개념입니다.OOP - 다형성 Polymorphism다형성 (Polymorphism)은 이전 포스트에서 간단하게 정리하여서 개념만 집고 넘어가면같은 이름의 메서드 or 연산자를 다양한 객체에 대해 서로 다른 방식으로 동작하도록 하는 원리를 말합니다. 당연히 재사용성과 유연성이 높아지는 결과를 가지고 옵니다.OverLoding오버로딩은 같은 이름의 연산자나 메서드를 여러개 정의하는 것을 말합니다.보통 이름은 같지만 매개변수의 타입, 갯수, 순서가 다른 경우를 파악해 구현합니다.이것을 파악하는 것은 정적 바인딩 (정적 다형성)에 의해 결정됩니다.특징으로는 컴파일 하는 시간, 즉 프로그램이 올라가기 전에 동작하게 됩니다.예시를 하나 들어보면public class Calculator {    public int add(int a, int b) {        return a + b;    }    public double add(double a, double b) {        return a + b;    }    public int add(int a, int b, int c) {        return a + b + c;    }}이렇게 구현해볼 수 있습니다.  2개의 int타입  2개의 실수형 double 타입  3개의 int타입다형성은 생각보다 자주 사용합니다.개인적인 경험으로 프로젝트 중 칵테일 머신의 종류를 구분하는 코드를 작성한 경험이 있는데이때 각 칵테일은 2~4개 사이의 base가 되는 술의 정보를 가지고 있었습니다. (이 base들을 섞어 cocktail로 제조하는 방법을 만드는 로직을 구현하였습니다.)이때 각 매개변수의 개수를 파악해 활용해봤던 경험이 있습니다.그런데 정적 다형성? 이라는 단어는 처음 들어보네요 찾아보면 다음과 같습니다.정적 다형성 과 동적 다형성정적 다형성(Static Polymorphism) 또는 컴파일 시 다형성(Compile-time Polymorphism)동적 다형성(Dynamic Polymorphism) 또는 실행 시 다형성(Runtime Polymorphism)이렇게 구분해볼 수 있습니다. 즉, 컴파일이 되는 시간동안 동작하는Overloading때 사용하면정적다형성프로그램이 실행되는 동안 동작하는 즉, Overriding 때 사용하면동적다형성이렇게 구분할 수 있습니다.특징에 대한 정리를 해보면  정적 다형성(Static Polymorphism) 또는 컴파일 시 다형성(Compile-time Polymorphism):          정적 다형성은 컴파일 시간에 발생합니다.      메서드 오버로딩(Overloading)을 통해 구현됩니다.      컴파일러가 코드를 분석하여 어떤 메서드가 호출될지 결정합니다.      오버로딩된 메서드 중에서 컴파일 시에 적절한 메서드가 선택되어 실행됩니다.        동적 다형성(Dynamic Polymorphism) 또는 실행 시 다형성(Runtime Polymorphism):          동적 다형성은 실행 시간에 발생합니다.      메서드 오버라이딩(Overriding)을 통해 구현됩니다.      상속 관계에 있는 클래스들 간에 발생합니다.      부모 클래스의 참조 변수로 자식 클래스의 객체를 참조할 때 발생합니다.      메서드 호출은 실제 객체의 타입에 따라 동적으로 결정됩니다.      가상 메서드 테이블(Virtual Method Table, VMT)을 사용하여 메서드 호출을 동적으로 연결합니다.      Overriding?오버라이딩은 말 그대로 덮어쓰다 라는 의미로 받아들이면 됩니다.부모 클래스의 메서드를 자식 클래스의 메서드에서 재정의하여 사용한다는 개념입니다.오버라이딩은 런타임 시에 동적 바인딩(동적 다형성)에 의해 결정됩니다.여기서 상속시킨 클래스가 확장의 개념을 가지고 오게 됩니다. 예를 하나 들어보며 어떤 식으로 사용하는지 보이겠습니다.만약 Spring을 위주로 공부해본 사람이라면 Extends라는 용어를 자주 클래스 옆에 붙이게 됩니다.예로 인증구조를 만들기 위해public class SecurityConfig extends WebSecurityConfigurerAdapter이런 식의 클래스를 정의 하여 시스템 요구 사항에 맞게 고치게 되는데이때 개념이 바로 확장의 개념이 됩니다.즉, WebSecurityConfigurerAdapter라는 부모클래스를 SecurityConfig에서 재정의 하게 되는 것입니다.그리고 자세한 메서드를 구현하게 되면@Configuration@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter {    @Override    protected void configure(HttpSecurity http) throws Exception {        http.authorizeRequests()            .antMatchers(\"/public/**\").permitAll() // 특정 URL은 인증 없이 접근 허용            .anyRequest().authenticated() // 그 외의 요청은 인증이 필요함            .and()            .formLogin(); // 기본 로그인 폼 사용    }}이런식으로 Override 해서 메서드를 재정의하는 것을 알 수 있습니다.원래 인증을 만들기 위해서는 아주 어려운 코드를 작성해야 하는데 spring-boot-starter-security 패키지를 받아와 내가 원하는 부분만 빠르게 만들 수 있는 즉, 생산성이 높아지는 결과를 보여줍니다.좀 더 간단한 코드로 직관적으로 이해해 보면class Animal {    public void makeSound() {        System.out.println(\"Animal makes a sound\");    }}class Cat extends Animal {    @Override    public void makeSound() {        System.out.println(\"Meow\");    }}Animal 부모 클래스를 Cat 자식클래스가 받아와 메서드를 재 정의하여 사용하고 있습니다.즉, 클래스 간에 동일한 이름의 메서드를 사용하여 부모 클래스의 메서드를 자식 클래스에서 수정하거나 확장할 수 있습니다.@Override자주 쓰는 어노테이션인데 따로 찾아본 경험은 없는 것 같아 정리했습니다.상위 클래스나 인터페이스에서 이미 정의된 메서드를 하위 클래스에서 다시 정의할때자바 컴파일러에게 명시적으로 여기  OverRiding 할꺼임 이라고 알려줍니다.그래서 특징으로  컴파일 타임 체크: @Override 어노테이션을 사용하면 컴파일러가 해당 메서드가 오버라이드되었는지를 검사합니다. 만약 오버라이드되지 않은 메서드를 @Override로 표시하면 컴파일러가 오류를 발생시킵니다.  코드 가독성 향상: @Override 어노테이션을 사용하면 메서드가 오버라이드되었음을 명시적으로 표시할 수 있습니다. 이는 코드를 읽는 사람이 해당 메서드가 어떤 용도로 사용되는지를 쉽게 이해할 수 있도록 도와줍니다정리하며이번 포스트 에서는 다형성의 중요개념인 OverLoding 과 OverRiding에 대해 알아봤습니다.정말 간단하게 정리해보면OverLoding : 컴파일 실행  ,  정적 바인딩 , 매개변수를 통해 구분OverRiding :  프로그램 실행 , 동적 바인딩 , @Override 어노테이션을 통해 구분또한, @ 어노테이션에 대한 언급을 했는데요다음 포스트에서는 @ 어노테이션에 대해 이야기 해보겠습니다.다음 포스트@ 어노테이션에 대하여"
  },
  
  {
    "title": "자바에 대하여 - 스레드",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%8A%A4%EB%A0%88%EB%93%9C/",
    "categories": "java",
    "tags": "java, thread, register",
    "date": "2024-01-08 06:44:00 +0900",
    





    
    "snippet": "5.JAVA-스레드들어가며이번 포스트에서는 스레드에 대한 포스트 입니다.사실 한번쯤은 모두 공부해본 내용이지만 , 정리도하고 java에서는 어떻게 활용할 수 있는지에 대한 이야기도 함께 하겠습니다.스레드?프로세스 내에서 실행되는 독립적인 작업 단위이며 여러 스레드가 하나의 프로세스에서 동작할 수 있습니다.그리고 스레드는 자체적인 흐름제어,스택,레지스터...",
    "content": "5.JAVA-스레드들어가며이번 포스트에서는 스레드에 대한 포스트 입니다.사실 한번쯤은 모두 공부해본 내용이지만 , 정리도하고 java에서는 어떻게 활용할 수 있는지에 대한 이야기도 함께 하겠습니다.스레드?프로세스 내에서 실행되는 독립적인 작업 단위이며 여러 스레드가 하나의 프로세스에서 동작할 수 있습니다.그리고 스레드는 자체적인 흐름제어,스택,레지스터를 가지고 있습니다.사용하는 가장 큰 이유는 여러 작업을 동시에 수행하여 효율성을 높이기 위해 사용합니다.자바에서 스레드 쓰기  Thread 클래스 상속: Thread 클래스를 상속받고 run() 메서드를 오버라이딩하여 스레드의 실행 코드를 구현합니다.  Runnable 인터페이스 구현: Runnable 인터페이스를 구현하고 run() 메서드를 오버라이딩하여 스레드의 실행 코드를 구현합니다.개발자가 스레드를 쓸 수 있는 방법은 크게 두 가지 입니다.public class ThreadExample {    public static void main(String[] args) {        // Thread 클래스 상속        Thread thread1 = new Thread() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    System.out.println(\"Thread 1: \" + i);                }            }        };        // Runnable 인터페이스 구현        Thread thread2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i &lt; 10; i++) {                    System.out.println(\"Thread 2: \" + i);                }            }        });        thread1.start();        thread2.start();    }}코드를 보면 위 언급한 두가지 방법을 통해 구현했습니다.단순히 0 ~ 9 까지 출력하는 예제 입니다.실행 해보면 결과가 다음과 같습니다.순서대로 나오지 않고 , 섞여 있는 모습을 볼 수 있는데 스레드를 생성해 동시에 작업을 진행하였기 때문입니다.그럼 현실 , 즉 메모리에서는 어떻게 동작 하는지에 대해서도 궁금한데요스레드가 사용하는 메모리            영역      내용      공유 여부                  스택      스레드 실행 흐름, 로컬 변수, 메서드 호출 정보      X (각 스레드마다 독립적)              힙      스레드가 사용하는 객체      O (모든 스레드가 공유)              프로그램 카운터      현재 실행 중인 명령어      X (각 스레드마다 독립적)              레지스터      CPU 임시 저장 공간      X (각 스레드마다 독립적)      각 스레드는 독립된 개체로써 사용하기 때문에 각각의 제어,스택,레지스터를 가지고 있습니다.저는 이렇게 이해했는데요공간(레지스터)에 실행 중인 명령(프로그램 카운터)과  스레드 마다 가진 데이터(스택) 스레드가 공유하는 데이터-객체(힙)궁금증이 생긴 것은 static 영역은 그럼 스레드를 사용할 때는 사용하지 않는지에 대해 알아보고 싶어졌습니다. 그래서 찾아보니 다음과 같습니다.static은 안쓰니?일반적으로는 static 영역을 쓰지 않는다.왜? static 영역을 사용하면 모든 스레드가 공유되고 , 이는 독립성의 문제를 발생시킵니다.또한, 동기화 기술을 자체적으로 사용해야만 하며( 데이터 손상에 대한 고려) static영역은 전 포스트에서 이야기했던것처럼프로그램이 시작되고 종료될때까지 유지되기 때문에 메모리의 누수 즉, 굳이 안쓰는 공간을 비효율적으로 차지할 수 있습니다.정리하면 다음과 같습니다.  독립적인 실행 흐름: 스레드는 각자의 실행 흐름을 가지고 있어야 하며, static 영역은 모든 스레드가 공유하기 때문에 스레드 간의 독립성을 유지하기 어렵습니다.  변수의 동기화 문제: static 변수는 모든 스레드가 공유하기 때문에 동기화 기술을 사용하지 않으면 데이터 손상이 발생할 수 있습니다.  메모리 누수 가능성: static 영역은 프로그램 종료 시까지 메모리에 존재하기 때문에 스레드에서 사용하지 않는 static 변수가 메모리 누수를 유발할 수 있습니다.물론 무조건 쓰지 못하게 막은 것은 아닙니다.예를 들어 모든 스레드가 공유하는 상수값, 클래스 변수를 저장 할 때는 static영역을 활용할 수 있다고 합니다.다만 이 경우에도 동기화 기술을 사용해야 한다고 합니다.레지스터는 뭔데?레지스터는 CPU 내부에 있는 작고 빠른 메모리 공간입니다. CPU는 레지스터를 사용하여 계산, 데이터 비교, 논리 연산 등을 수행하는데 필요한 데이터와 명령어를 임시적으로 저장합니다.레지스터의 특징:  빠른 속도: 레지스터는 CPU 내부에 위치하기 때문에 메모리보다 훨씬 빠른 속도로 접근할 수 있습니다.  작은 크기: 레지스터는 메모리보다 훨씬 작은 크기입니다.  다양한 종류: 레지스터는 다양한 종류가 있으며, 각각 다른 용도로 사용됩니다.레지스터의 용도:  계산: 레지스터는 덧셈, 뺄셈, 곱셈, 나눗셈 등의 계산에 필요한 데이터를 저장합니다.  논리 연산: 레지스터는 AND, OR, NOT 등의 논리 연산에 필요한 데이터를 저장합니다.  명령어 저장: 레지스터는 다음에 실행할 명령어를 저장합니다.레지스터의 종류:  일반 레지스터: 일반적인 계산 및 데이터 저장에 사용됩니다.  특수 레지스터: 프로그램 카운터, 스택 포인터 등 특정 용도로 사용됩니다.레지스터의 중요성:레지스터는 CPU의 성능에 중요한 영향을 미칩니다. 레지스터의 크기와 속도가 클수록 CPU는 더 빠르게 프로그램을 실행할 수 있습니다.정리이번 포스트는 자바에서 스레드를 어떻게 쓰고 , 동작하는지에 대해 알아봤습니다.스레드 라는 개념은 자주 들어서 인지하고 있었는데 정리해보며 알아봤습니다.이번 포스트를 쓰며 @overriding 이라는 어노테이션을 사용하였는데오버로드와 오버 라이딩에 대해서도 정리해보자고 생각이 들어 다음은관련된 내용을 포스트하겠습니다.다음 포스트자바 에서의 오버로드와 오버 라이딩"
  },
  
  {
    "title": "알고리즘 - search - dfs&bfs",
    "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-search/",
    "categories": "algorithm",
    "tags": "java, algorithm, dfs, bfs",
    "date": "2024-01-07 06:44:00 +0900",
    





    
    "snippet": "문제는 자바를 이용해 풀어보겠습니다!들어가며이번 포스트에서는 탐색 기법에 대한 이야기를 해보려고 합니다.알고리즘은 공부를 하면 할 수록 더욱 깊고 , 다양한 조합을 만들 수 있기 때문에 기본적이며 핵심적인 이야기들을 위주로 공부해본 내용을 정리하겠습니다.DFS - 깊이 우선 탐색DFS : depth first search 는 완전 탐색 기법 중 하나 ...",
    "content": "문제는 자바를 이용해 풀어보겠습니다!들어가며이번 포스트에서는 탐색 기법에 대한 이야기를 해보려고 합니다.알고리즘은 공부를 하면 할 수록 더욱 깊고 , 다양한 조합을 만들 수 있기 때문에 기본적이며 핵심적인 이야기들을 위주로 공부해본 내용을 정리하겠습니다.DFS - 깊이 우선 탐색DFS : depth first search 는 완전 탐색 기법 중 하나 입니다.완전 탐색 기법 (Exhaustive Search) 은 모든 경우의 수를 탐색해 해를 찾는 기법입니다.특징은 일관되고 , 간단하고 직관적입니다.당연히 모든 경우의 수를 탐색하는 만큼 경우의 수가 많아질 수 록 효율이 낮아집니다.            기능      특징      시간 복잡도                  그래프 완전 탐색      재귀 함수를 사용      O(V+E)                     스택 자료구조 이용      V : node의 수 , E : 에지 수      재귀 함수를 사용한다. (구현 할때  재귀함수 사용함)결국  자기 자신을 부르는 구조로 구현이 되기 때문에 스택 오버 플로우가 발생할 가능성이 존재합니다. 이점을 유의 하면서 코딩 해야 합니다.구현 하는 원리는 다음과 같습니다.처음 초기화를 하며 시작점을 선택합니다.또한, 방문한 기록을 저장하기 위한 배열을 생성 &amp; 그래프 데이터를 저장할 인접 리스트를 생성Stack의 시작점에 대한 노드를 삽입합니다.이후 노드를 꺼내고 해당 노드와 연결된 노드를 Stack에 삽입합니다.그리고 이것을 반복하면 DFS의 탐색 순서를 얻을 수 있고 , 구현이 가능합니다.BFS - 너비 우선 탐색BFS: breadth-frist-search 너비 우선 탐색시작 노드 기준으로 가까운 노드를 먼저 방문한다.BFS는 큐를 이용해 구현합니다.            기능      특징      시간 복잡도                  그래프 완전 탐색      FIFO를 사용      O(V+E)                     Queue 자료구조 이용      V : node의 수 , E : 에지 수      구현원리는 다음과 같습니다.  시작점을 선택하고 초기화 합니다. 여기서 데이터를 저장해둡니다.      큐에 삽입한 노드를 pull 하고 관련된 노드 즉,인접한 노드를 큐에삽입합니다    -여기서 유의할 점은 큐에 삽입했다고 아직 방문한 상태는아닙니다.    모든 경우의 수를 만족할때까지반복합니다.구현해보자잘 생각하면 dfs와 bfs 둘다 인접리스트와 방문배열을 사용합니다.그리고 구분점은 Stack의 LIFO , Queue의 FIFO를 활용하는지에 따라 두 방법의 구분이 가능합니다.그럼 자바로 예시코드를 보면서 이야기해보겠습니다.백준 -1260 문제입니다.위 언급하였듯이 두 search 알고리즘은 인접리스트와 방문배열을 사용합니다.static ArrayList&lt;Integer&gt;[] dataArr;static boolean[] visted;자바에서는 이런식으로 구현할 수 있습니다.ArrayList로 이루어진 배열을 선언함으로써 인접리스트를 구현할 수 있습니다.방문배열은 boolean형 배열을 선언함으로써 구현할 수 있습니다.ArrayList?자주 사용하는데 굳이 의미를 두고 쓰지 않아 설명해보려니 햇갈려서 정리하였습니다.ArrayList는 자바에서 제공하는 동적 배열(dynamic array)로, 크기가 가변적으로 자동으로 조절되는 배열입니다. 기존의 배열과는 달리, 요소를 추가하거나 삭제할 때 크기 조절이 자동으로 이루어져 편리하게 사용할 수 있습니다.특징  가변 크기: 배열의 크기를 동적으로 조절할 수 있습니다. 요소를 추가하면 자동으로 크기가 증가하고, 요소를 삭제하면 자동으로 크기가 감소합니다.  인덱스 기반 접근: 각 요소는 인덱스를 사용하여 접근할 수 있습니다. ArrayList는 내부적으로 배열을 사용하기 때문에 인덱스를 통한 접근이 빠릅니다.  제네릭 타입 지원: 제네릭 타입을 사용하여 저장될 요소의 타입을 명시할 수 있습니다. 이를 통해 타입 안정성을 보장하고 형 변환을 줄일 수 있습니다.  배열과 유사한 성능: 요소의 추가나 삭제 시 배열을 복사하는 과정이 필요하지만, ArrayList는 배열을 사용하기 때문에 배열과 유사한 성능을 보입니다.초기화하기dataArr = new ArrayList[n+1];visted = new boolean[n+1];for(int i=1; i&lt;n+1; i++){    dataArr[i] = new ArrayList&lt;&gt;();}공부하면서 +1이 왜필요할지에 대해서 생각을 해봤습니다.그래프에서 정점을 0을 안쓰니까 즉, 보통 정점을 1부터 시작하는 정수로 사용하기 때문에 0을 비워두고 쓰기 때문이다. 라고 생각 해봤는데 일단 bard도 이런식으로 답변해서 맞는 이유라고 생각합니다.방향에 대하여        for(int i =0; i&lt;m; i++){            st = new StringTokenizer(br.readLine());            int a = Integer.parseInt(st.nextToken());            int b = Integer.parseInt(st.nextToken());            dataArr[a].add(b);            dataArr[b].add(a);        }만약 양뱡향 , 무뱡향인 경우에는 양쪽 모두를 넣어줘야합니다.하지만 한쪽방향이 지정 된 경우에는 한쪽만 넣어주면 됩니다.DFS - 재귀함수를 이용해 구현하기    private static void _dfs(int node){        System.out.print(node + \" \");        visted[node] =true;        for(int i : dataArr[node]){            if(! visted[i]) bfs_01_dfs(i);        }    }위에 선언해 뒀던 인접리스트 배열에서 값을 뽑은다음방문 기록을 확인해 방문하지 않은 부분을 재귀 하면 됩니다.DFS - Stack으로 구현하기Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); // 스택 생성        stack.push(start); // 시작 정점을 스택에 넣음        visited[start] = true; // 시작 정점 방문 표시        System.out.println(\"DFS 결과:\");        while (!stack.isEmpty()) {            int current = stack.pop(); // 스택에서 정점을 꺼냄            System.out.print(current + \" \"); // 현재 정점 출력            // 현재 정점과 연결된 정점들 중 방문하지 않은 정점을 스택에 넣음            for (int next : dataArr[current]) {                if (!visited[next]) {                    stack.push(next);                    visited[next] = true;                }            }        }stack을 선언한 뒤  시작점을 push하고stack의 값이 없을때까지 pop하여 해당 값이  방문하지 않은경우 push 해주면 됩니다.BFS - Queue를 이용해 구현하기    private static void _bfs(int node){        visted[node] =true;        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();        queue.add(node);        while (!queue.isEmpty()){            int now = queue.poll();            System.out.print(now + \" \");            for(int i : dataArr[now]){                if(! visted[i]){                    visted[i] =true;                    queue.add(i);                }            }        }    }Queue를 선언하고 들어온 큐를 삽입합니다 .(시작점)Queue가 빌때까지 반복하며 현재 값을 poll합니다. 그리고 이 값이 방문하지 않은 경우에는Queue에 추가하면 됩니다.정리하며이번 포스트 에서는 DFS와 BFS에 대해 정리해봤습니다."
  },
  
  {
    "title": "JAVA에 대하여 - 메모리 & 가비지 컬렉션",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%A9%94%EB%AA%A8%EB%A6%AC/",
    "categories": "java",
    "tags": "java, 메모리, Heap, 메소드",
    "date": "2024-01-06 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트에서는 Java가 메모리를 어떤식으로 활용하는지에 대한 이야기를 정리해보려고 합니다.자세하게 생각하면 끝도 없는 영역이기 때문에 아 이런식으로 동작하는 구나 정도의 수준의 정리 내용입니다.언어들은 메모리를 어떻게 쓸가?Java와 같이 컴파일러를 통해 기계어를 만들어 사용하는 언어들은 아래 그림처럼코드를 실행하는 영역과 데이터를 저장하...",
    "content": "들어가며이번 포스트에서는 Java가 메모리를 어떤식으로 활용하는지에 대한 이야기를 정리해보려고 합니다.자세하게 생각하면 끝도 없는 영역이기 때문에 아 이런식으로 동작하는 구나 정도의 수준의 정리 내용입니다.언어들은 메모리를 어떻게 쓸가?Java와 같이 컴파일러를 통해 기계어를 만들어 사용하는 언어들은 아래 그림처럼코드를 실행하는 영역과 데이터를 저장하는 영역으로 나누어 메모리를 할당해 사용합니다.자바의 경우에 데이터를 저장하는 방법은 크게 3가지로 나누어 이야기할 수 있습니다.Java가 최초 저장할때는 해당영역을 사용합니다.더 정확히 구분하면Method Area 와 Static Area로 나눌 수 있습니다.Method Area vs Static Area?메서드 영역(Method Area):  모든 스레드가 공유하는 영역으로, 클래스 파일의 바이트 코드, 정적 변수(static variable), 상수(Constant), 메서드 코드 등이 저장됩니다.  클래스 로더(Class Loader)에 의해 클래스 파일이 로드되면 해당 클래스의 정보가 메서드 영역에 저장됩니다.스태틱 영역(static Area):  객체가 생성되기 전에 이미 메모리에 할당되는 영역으로, 모든 인스턴스가 공유하는 데이터를 저장합니다. 클래스 변수(static variable)가 static 영역에 저장됩니다결국 이전 포스트에서 이야기했던 .class를 저장하는 영역으로 보는지 혹은 객체 이전에 생성된 모든 인스턴스가 공유하는 저장 공간을 의미 하는지의 차이로 생각합니다.또한, 여기서 클래스변수 와 정적변수가 같은 영단어를 쓰는 걸 볼 수 있는데공부해본 바로는 다음과 같습니다.  클래스 변수(Class Variable): 클래스 변수는 객체 간에 공유되는 변수를 의미하며, 객체를 생성하지 않고도 클래스 이름을 통해 접근할 수 있습니다. 클래스 변수는 일반적으로 static 키워드로 선언됩니다.  정적 변수(Static Variable): 정적 변수는 객체에 속하지 않는 변수를 의미하며, 클래스 내부에서만 사용되는 변수를 일컫습니다. 따라서 객체를 생성하지 않고도 클래스 내부에서 직접 접근할 수 있습니다. 클래스 변수와 유사하지만, 클래스 변수가 반드시 static 키워드로 선언되어야 하는 반면, 정적 변수는 그렇지 않을 수 있습니다.정리하면 결국 같은 의미입니다. 특정 클래스의 변수다 라는 의미를 강조하기 위해 클래스 변수라는 개념을 사용하는 것인데 같은 의미로 두고 봐도 무방하다고 생각합니다.Stack Area &amp;&amp; Heap Area  힙 영역(Heap Area):          동적으로 생성된 객체와 배열이 저장되는 영역입니다.      힙 영역은 가비지 컬렉션(Garbage Collection)에 의해 관리되며, 더 이상 사용되지 않는 객체는 메모리에서 해제됩니다.        스택 영역(Stack Area):          각 스레드마다 별도로 할당되는 영역으로, 메서드 호출 시 생성되는 지역 변수(local variable), 매개변수(parameter), 메서드 호출 스택(method call stack) 등이 저장됩니다.      메서드 호출 시 해당 메서드의 스택 프레임이 스택 영역에 생성되며, 메서드 실행이 완료되면 스택 프레임이 제거됩니다.      정리하면 힙은 객체를 저장하는 공간 , 스택은 로컬 변수와 매개 변수 , 메서드를 호출하는 스택이 저장됩니다.정리해보면 이런식으로 볼 수 있습니다.변수나 메서드 조건문 등이 하나의 Stack의 들어와 작동하게 됩니다.하지만 항상 존재하는 것은 아니고 사용 후 에는 해당 메모리를 비워줍니다.이렇게 해서 메모리의 효율성을 보장할 수 있게 됩니다.그리고 계산된 결과 중 이후 사용이 있는 데이터들에 대해서는 캐시에 저장하여 더욱 높은 효율성을 볼 수 있게 합니다.이외에도 Pc레지스터와 네이티브 메서드 스택이 존재합니다.Pc레지스터 &amp;&amp; 네이티브 메서드  PC 레지스터(Program Counter Register):          스레드마다 별도로 할당되는 영역으로, 현재 실행 중인 명령어의 주소를 가리키는 포인터입니다.      JVM이 다음에 실행할 명령어의 주소를 가리키며, 스레드가 실행 중인 동안에만 유효합니다.        네이티브 메서드 스택(Native Method Stack):          자바 언어가 아닌 다른 언어로 작성된 네이티브 코드(native code)를 실행하기 위한 스택 영역입니다.      JNI(Java Native Interface)를 통해 자바 언어와 네이티브 언어 간의 상호 작용을 지원합니다.      이런 방법을 통해 자바가 메모리를 관리하고 있다는 것을 알 수 있습니다.Heap Area 에 대한 고찰힙 공간(Heap Space)은 동적으로 생성된 객체와 배열이 저장되는 메모리 영역입니다.자바에서는 new 키워드를 사용하여 객체를 생성할 때 힙 영역에 메모리를 할당하고,이 객체는 가비지 컬렉션(Garbage Collection)에 의해 관리됩니다.힙 영역은 JVM(Java Virtual Machine)이 시작될 때 생성되며, 프로그램이 종료될 때까지 유지됩니다만약 C로 동적 프로그래밍을 했다면? 포인터연산을 통해 지정하며 코딩해야 합니다.예시코드를 보며 설명해보자면public class Person {    private String name;    private int age;    public Person(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public int getAge() {        return age;    }}public class Main {    public static void main(String[] args) {        // 힙 영역에 Person 객체를 생성하여 메모리를 할당합니다.        Person person1 = new Person(\"Alice\", 25);        Person person2 = new Person(\"Bob\", 30);                // 생성된 객체의 메서드를 호출하여 정보를 출력합니다.        System.out.println(\"Person 1: \" + person1.getName() + \", \" + person1.getAge() + \" years old\");        System.out.println(\"Person 2: \" + person2.getName() + \", \" + person2.getAge() + \" years old\");    }}이런 식으로 힙 영역에 메모리를 할당해 새로운 객체 (동적으로 생성한 객체)를 저장하고 사용할 수 있습니다. 그런데 궁금한점이 생겼습니다. 자료구조들은 어떻게 저장할까?기본적으로 String 이라는 것 ,  문자열(String)은 불변(immutable) 객체로 취급되며, 메모리 상에 생성된 문자열은 변경할 수 없습니다.다른 자료구조들인 정수(int, long, short, byte), 부동 소수점(float, double), 문자(char), 논리(boolean) 등과는 차이점이 분명히 존재합니다.String에 대하여위 언급한 String은 문자”열” 입니다. 문자를 나열한 정보를 저장해두는 자료구조입니다.자바는 이전에 말씀드린 데이터를 객체로 만드는 것을 지향합니다.따라서 기본 데이터 유형(primitive data types)들 과 String(Object)은 분명한 차이점이 존재하게 됩니다.따라서 문자열을 생성하면 해당 문자열은 힙 영역에 저장되고, 이후에 변경되지 않습니다.public class StringExample {    public static void main(String[] args) {        // 문자열 리터럴을 사용하여 String 객체 생성        String str1 = \"Hello\";        // 새로운 String 객체 생성        String str2 = new String(\"World\");        // 문자열 연결 연산으로 새로운 String 객체 생성        String str3 = str1 + str2;        // 문자열 상수를 직접 가리키는 경우 동일한 문자열 리터럴은 동일한 메모리 주소를 참조        String str4 = \"Hello\";        // 문자열 내용이 같더라도 새로운 객체가 생성됨        String str5 = new String(\"Hello\");        // String 객체가 힙 영역에 저장되고 있는지 확인하기 위해 hashCode() 메서드 호출        System.out.println(\"str1 hashCode: \" + str1.hashCode());        System.out.println(\"str2 hashCode: \" + str2.hashCode());        System.out.println(\"str3 hashCode: \" + str3.hashCode());        System.out.println(\"str4 hashCode: \" + str4.hashCode());        System.out.println(\"str5 hashCode: \" + str5.hashCode());    }}실행시켜보면 모두 다른 주소를 사용하고 있다는 것을 확인할 수 있습니다.primitive data types 는 어디에 저장될까?기본 데이터 유형(primitive data types)은 일반적으로 스택(stack) 영역에 저장됩니다.기본 데이터 유형은 정수(int, long, short, byte), 부동 소수점(float, double), 문자(char), 논리(boolean) 등이 있습니다.스택 영역은 지역 변수(local variable) 및 메서드 호출 시 생성되는 프레임(frame)을 저장하는 영역으로, 메모리의 상대적으로 빠른 공간을 활용합니다.public class PrimitiveExample {    public static void main(String[] args) {        // 정수형 변수 선언 및 초기화        int intValue = 10;        // 부동 소수점 변수 선언 및 초기화        double doubleValue = 3.14;        // 문자 변수 선언 및 초기화        char charValue = 'A';        // 논리형 변수 선언 및 초기화        boolean booleanValue = true;        // 스택 영역에 저장된 변수 값 출력        System.out.println(\"intValue: \" + intValue);        System.out.println(\"doubleValue: \" + doubleValue);        System.out.println(\"charValue: \" + charValue);        System.out.println(\"booleanValue: \" + booleanValue);    }}위의 코드에서 intValue, doubleValue, charValue, booleanValue는 모두 스택 영역에 저장되는 변수입니다.이들 변수는 메서드 내에서 사용되는 지역 변수로써, 메모리가 할당된 스택 프레임에 저장됩니다.따라서 이들 변수는 해당 프레임이 소멸될 때 함께 소멸되며, 스택 프레임이 소멸되면 해당 변수가 사용되는 메모리 공간도 함께 해제됩니다.정리해보면Object 는 Heap Area 에서 관리한다. 그리고 이걸 관리하는 Garbage Collection이 있다.Garbage CollectionGarbage Collection(가비지 컬렉션)은 프로그램 실행 중에 더 이상 사용되지 않는 메모리를 자동으로 해제하는 자바의 기능입니다.이는 프로그래머가 명시적으로 메모리 관리를 수행할 필요가 없게 해줍니다.수행 방식에 대해 정리해보면  객체 생성: 프로그램에서 객체가 생성되면 힙(heap) 영역에 메모리가 할당됩니다. 객체는 생성될 때마다 힙 영역의 어딘가에 저장되고, 해당 객체를 참조하는 변수가 있다면 그 변수에 객체의 참조(주소)가 저장됩니다.  객체 사용: 프로그램이 실행되는 동안 객체는 사용되며, 해당 객체에 대한 참조가 계속 유지됩니다.  참조 해제: 객체를 참조하는 변수가 더 이상 존재하지 않으면 해당 객체에 대한 참조는 끊어지며, 이 때 객체는 가비지(garbage)로 간주됩니다.  가비지 컬렉션 실행: JVM은 주기적으로 또는 필요할 때마다 가비지 컬렉션을 실행하여 힙 영역에서 더 이상 사용되지 않는 객체를 탐지하고 제거합니다.  메모리 해제: 가비지 컬렉션에 의해 탐지된 가비지 객체들은 메모리에서 해제되고, 해당 메모리 공간은 다시 사용 가능한 상태가 됩니다.객체를 생성 , 사용 → 참조 해제 → 가비지 컬렉션이 돌아다니며 객체를 탐지 제거 → 메모리 해제이렇게 순서대로 이해할 수 있습니다.장점은 당연히 해야할 일이 적어지고 이전 포스트에서도 이야기 하였듯이사람이 메모리를 명시적으로 할당하다 발생하는 사고에 대해 미연의 방지하는메모리 누수를 막을 수 있습니다.단점은 가비지 컬렉션이 일단 실행되려면 프로그램을 일시적으로 일시정지해야합니다.왜냐면 아직 사용 중 인데 해제시키면 안되니까요즉, 프로그램이 동작하는데 소요되는 시간이 증가하게 됩니다.따라서 성능을 개선하기 위해 여러 기법들이 고려되어야 합니다.  메모리 할당 최적화: 객체를 생성할 때 메모리를 적게 사용하도록 최적화하는 것이 중요합니다. 이는 객체의 크기를 최소화하거나, 불필요한 객체 생성을 피하고, 객체 풀링(Object Pooling)과 같은 기술을 사용하여 객체의 재사용을 촉진하는 것을 의미합니다.  GC 튜닝: JVM에서 Garbage Collection 알고리즘 및 설정을 조정하여 성능을 최적화할 수 있습니다. 이는 Young Generation과 Old Generation의 비율 조정, GC 알고리즘 선택, GC 동작 주기 조절 등을 포함합니다. 예를 들어, GC 알고리즘을 G1GC로 변경하거나, GC 동작 주기를 조정하여 응용 프로그램의 요구에 맞게 설정할 수 있습니다.  메모리 누수 감지: 메모리 누수를 방지하고 탐지하는 것이 중요합니다. 메모리 누수는 가비지 컬렉션의 성능을 저하시킬 수 있습니다. 따라서 메모리 프로파일러(memory profiler) 및 메모리 분석 도구를 사용하여 메모리 누수를 식별하고 해결해야 합니다.  간접적인 참조 제거: 불필요한 객체에 대한 간접적인 참조를 제거하는 것이 중요합니다. 예를 들어, 캐시를 사용할 때 캐시에 저장된 객체에 대한 간접적인 참조를 정리하는 것이 필요합니다.  멀티 스레딩 및 병렬 처리: 가비지 컬렉션 작업을 멀티 스레드로 실행하거나 병렬로 처리하여 성능을 향상시킬 수 있습니다. 예를 들어, Parallel GC(병렬 GC) 또는 G1GC(Garbage First GC)와 같은 병렬 가비지 컬렉션 알고리즘을 사용하여 가비지 컬렉션 작업을 여러 CPU 코어에서 동시에 처리할 수 있습니다.보기만 해도 어려운 이야기가 많습니다만정리하면 그렇게 어렵지 않습니다.그냥 메모리 최적화를 위한 Polling , GC라는 알고리즘 , 누수 감지 , 간접참조 제거 , 멀티스레딩입니다. (알고리즘은 알고리즘 관련 포스트를 올릴 예정이라 거기서 다루어 보겠습니다.)Object Pooling여기서 객체 풀링(Object Pooling) 이란 컴퓨터관련 전공을 한사람들은 한번 쯤 어디선가 들어봤을법한  풀(pool)에 저장하고 필요할 때마다 풀에서 가져와서 쓰는 방법입니다.필자가 기억하기로는 SQL , Network에서 연결관리 할때 사용했던것으로 기억합니다.어쨋든 정말 많이 사용되는 기법인데여기서 객체 풀링이란 ,많은 객체를 반복적으로 생성하고 제거하는 대신, 객체를 미리 생성하여 풀(pool)에 저장하고 필요할 때마다 풀에서 객체를 가져와 사용하는 기법을 말합니다.(자세한 이야기는 다른 포스트에서 하겠습니다.)정리하며이번 포스트에서는 자바가 메모리를 어떻게 관리하는지에 대한 이야기를 정리해봤습니다.항상 느끼는거지만 이런 Low레벨에서 개발하시는 하드웨어나 OS개발자분들이 정말 대단한거 같습니다. 공부할때마다 어렵고 이해가 안되는 부분이 계속 나오는 걸 보면요.간단하게 자바 메모리 사용의 대한 정보를 정리하면서 또 공부해보고 싶은 이야기들도 생겨서 재미있었습니다. (Gc튜닝 같은 부분들..)다음 포스트에서는 자바의 스레드의 대한 이야기를  해보려고합니다.다음 포스트자바 스레드 &amp; 스레드의 대하여"
  },
  
  {
    "title": "JAVA에 대하여 - 동작",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EB%8F%99%EC%9E%91/",
    "categories": "java",
    "tags": "java, JDK, JVM, 인터프리터",
    "date": "2024-01-05 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 에서는 자바가 동작하는 구동 과정의 대해 정리해 보려고 합니다. 자바가 매력적인 이유 중 하나인 구동 과정에 대한 이야기는 매우 흥미롭습니다.자바는 어떻게 보여지나제가 정리하면 이미지를 보시면 크게 3가지의 소프트웨어를 통해 동작한다는 것을 볼 수 있습니다.JDK = 개발도구 , JRE = JVM용 OS , JVM = 자바 전용 가...",
    "content": "들어가며이번 포스트 에서는 자바가 동작하는 구동 과정의 대해 정리해 보려고 합니다. 자바가 매력적인 이유 중 하나인 구동 과정에 대한 이야기는 매우 흥미롭습니다.자바는 어떻게 보여지나제가 정리하면 이미지를 보시면 크게 3가지의 소프트웨어를 통해 동작한다는 것을 볼 수 있습니다.JDK = 개발도구 , JRE = JVM용 OS , JVM = 자바 전용 가상 컴퓨터이전 포스트에서 자바가 나온 이유에 대해 설명하며 다양한 플렛폼에서 사용이 가능하다는 의미가 바로 이런식으로 동작하기 때문에 가능합니다.이런 특성을 Write once Run Anywhere 이라고 하는데 한국어로 “한번 쓰면 계속 쓸 수 있음” 입니다.JVM의 특징을 정리해보면 다음 과 같습니다.  플랫폼 독립성: JVM은 플랫폼 독립적입니다. 즉, Java 프로그램은 한 번 작성되면 어떤 플랫폼에서도 실행될 수 있습니다. 이는 Java 언어가 컴파일된 바이트코드를 JVM이 해석하고 실행하기 때문에 가능합니다.  자동 메모리 관리: JVM은 가비지 컬렉션을 통해 메모리를 자동으로 관리합니다. 이는 프로그래머가 명시적으로 메모리 할당과 해제를 관리할 필요가 없게 해줍니다. 따라서 Java 프로그램에서 메모리 누수 및 다른 메모리 관련 오류를 방지할 수 있습니다.  보안: JVM은 강력한 보안 기능을 제공합니다. Java 애플리케이션은 샌드박스 환경에서 실행되어 악의적인 코드의 실행을 방지합니다. 또한 JVM은 바이트코드 검증과 같은 보안 기능을 내장하고 있어 안전한 실행을 보장합니다.  성능 최적화: JVM은 Just-In-Time (JIT) 컴파일러를 사용하여 프로그램의 성능을 최적화합니다. JIT 컴파일러는 프로그램이 실행될 때 바이트코드를 네이티브 코드로 변환하여 실행 속도를 향상시킵니다.  동적 로딩: JVM은 클래스 파일을 동적으로 로드하여 실행할 수 있습니다. 이는 애플리케이션의 유연성을 높이고, 프로그램의 실행 중에도 새로운 클래스를 동적으로 로드하여 실행할 수 있게 합니다.  멀티스레딩 지원: JVM은 멀티스레드를 지원하여 동시에 여러 작업을 수행할 수 있습니다. 이는 Java 프로그램이 병렬 및 동시성 작업을 수행하는 데 도움이 됩니다.  풍부한 표준 라이브러리: JVM은 Java 표준 라이브러리 (Java API)를 제공하여 다양한 작업을 수행하는 데 필요한 클래스와 메서드를 제공합니다. 이러한 표준 라이브러리는 개발 과정을 단순화하고 생산성을 향상시킵니다.읽다 보면 생각보다 처음보는 단어들도 보입니다.컴파일된 바이트코드우리가 작성한 코드는 고수준 프로그래밍 언어로 작성된 “소스코드” 라고부릅니다.위 사진에서 가장 처음에 시작하는 부분입니다.그리고 이것을 자바 번역기가 중간형태의 이진코드로 변환시킵니다.여기서 자바 번역기는 자바 컴파일러를 의미 합니다.그리고 이런 이진코드의 파일을 .class 라는 바이너리형식으로 저장합니다.이런 class파일을 컴파일된 바이트코드라고 합니다.그리고 이러한 class 파일을 JVM의 인터프리터 or JIT(just in time)컴파일러에 의해 실행됩니다.인터프리터? JIT?인터프리터는 생각보다 가까운 개념입니다.고수준 언어로 작성된 프로그램을 한 줄씩 읽고 해석하여 실행하는 프로그램입니다.이는 컴파일러와 대비되는 개념으로, 컴파일러가 전체 소스 코드를 기계어로 번역한 후 실행하는 것과는 다릅니다.즉, 전체코드를 읽는 컴파일러 보다 빠른 속도로 프로그램을 실행시킬 수 있습니다.대표로 Python , javaScript 가  사용하고 있습니다.그리고 이런 언어들은 스크립트 언어라고 부릅니다.이런 언어들은 컴파일 과정 즉, 기계어를 생성하는 과정을 스킵 하고 바로 메모리에 적재하기 시작합니다. 물론 이런 과정이 불안하기 때문에 각 언어마다 해결법들을 만들었는데 관련 포스트를 적으면 정리해보겠습니다.최근 웹에서도 Flask , Django 가 선호되고 Node js , 혹은 프론트엔드에서도 많이 사용되는 이유입니다.당연히 Java와 같은 언어들에 비해서 성능도 안정성도 떨어집니다.Python을 다루어 보면 실행 시작에서는 오류를 내지 않아도 올라가서 실행하다 보면 오류가 나는 경우가 많은 것처럼 강력한 검사를 하지 않기 때문입니다.최근 트렌드에 대한 생각하지만 개인적인 생각은 최근에는 관련 언어들의 발전이 계속 이루어지고대규모 시스템 구축을 하거나 정부 과제를 수행하지 않는 업체들에서는 이런 가벼운 언어로 빠르게 개발하고 레거시 하는 과정을 더욱 선호 하는 거로 보입니다.취업정보 사이트에 들어가 보면 생각보다 Node.js나 Python 개발자들을 많이 뽑는게 그런 이유여서 라고 생각합니다.특히 , 최근 트랜드인 MSA - 마이크로 서비스 아키텍처에서는 작은 어플리케이션을 여러개 만들어서 논리적으로 이어놓는것을 추구하고 있기 때문이기도 한 것 같습니다.JIT  (Just in Time)  바이트코드 해석: JVM(Java Virtual Machine)은 바이트코드를 인터프리터를 사용하여 한 줄씩 해석하고 실행합니다.  실행 주기 모니터링: JVM은 프로그램의 실행 중에 어떤 부분이 자주 실행되는지 모니터링합니다.  컴파일 결정: JIT 컴파일러는 실행 주기 모니터링을 기반으로 하여 자주 실행되는 부분이나 코드 루프 등을 선택하여 컴파일할지 결정합니다.  컴파일: JIT 컴파일러는 선택된 부분을 기계어로 변환하여 네이티브 코드로 생성합니다.  캐시 및 재사용: 생성된 네이티브 코드는 캐시에 저장되어 이후에 동일한 부분이 실행될 때 재사용됩니다.JIT 는 이런식으로 동작합니다.해석 → 자주 나타나는 부분 분석 → 컴파일 결정 → 기계어 생성 → 기계어를 캐시에 저장해두기여기서 인터프리터를 사용하는 과정이 나옵니다.그리고 이러한 JIT는 장점이 있는데 정리하면 다음과 같습니다.  실행 시간 최적화: JIT 컴파일러는 실행 중에 프로그램의 성능을 분석하고 최적화할 수 있습니다. 이는 실행 시간에 최적화된 코드를 생성하여 프로그램의 실행 속도를 향상시킵니다.  메모리 사용량 최적화: JIT 컴파일러는 프로그램의 실행 중에 필요한 부분만 컴파일하고 메모리에 저장합니다. 따라서 불필요한 코드를 메모리에 로드하지 않아 메모리 사용량을 최적화할 수 있습니다.  플랫폼 독립성 유지: JIT 컴파일러는 바이트코드를 실행 중에 네이티브 코드로 변환하기 때문에, 플랫폼 독립성을 유지하면서도 실행 시간에 최적화된 코드를 생성할 수 있습니다.참 재미있는 방식입니다. 지금 이 순간의 최적의 방법을 찾아 시간과 메모리를 최적화 시키는 방법은 자바를 더욱 매력적인 언어로 만든 장점이라고 보입니다.정리하며이번 포스트에서는 자바의 구동과정에 대해 정리해 봤습니다.“JVM은 가비지 컬렉션을 통해 메모리를 자동으로 관리합니다.”이부분을 보면 가비지 컬렉션이 뭐지? 라고생각해볼 수 있습니다. 그래서 다음 포스트 에서는자바가 메모리를 사용하는 이야기를 하며 가비지 컬렉션에 대한 이야기도 함께 해보겠습니다.다음 포스트자바의 메모리 사용과 가비지 컬렉션"
  },
  
  {
    "title": "JAVA에 대하여 - 객체",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EA%B0%9D%EC%B2%B4/",
    "categories": "java",
    "tags": "java, OOP, 객체, Object",
    "date": "2024-01-04 06:44:00 +0900",
    





    
    "snippet": "객체 와 동작에 대한 이야기이번 포스트에서는 객체에 대해 이야기 해보겠습니다.필자 개인적으로 객체는 이해했다고 생각하면 뭔가 틀리는 경우도 있어서 이번 포스트를 적어보며 정리하는 시간을 가져봅니다.객체?자바에서 객체지향은 매우 중요한 개념입니다.객체 지향 즉, 객체를 만들어서 사용하는것을 지향한다. 인데여기서 객체를 정리해보면 이렇습니다.객체(Obje...",
    "content": "객체 와 동작에 대한 이야기이번 포스트에서는 객체에 대해 이야기 해보겠습니다.필자 개인적으로 객체는 이해했다고 생각하면 뭔가 틀리는 경우도 있어서 이번 포스트를 적어보며 정리하는 시간을 가져봅니다.객체?자바에서 객체지향은 매우 중요한 개념입니다.객체 지향 즉, 객체를 만들어서 사용하는것을 지향한다. 인데여기서 객체를 정리해보면 이렇습니다.객체(Object)는 클래스(Class)의 인스턴스(Instance)클래스란, 객체와 행위가 합쳐진 공간입니다. 템플릿을 의미 합니다. 빗대어 표현하면 ‘틀’ 이라고 표현할 수 있습니다.인스턴스란, 클래스의 속하는 실제하는 객체 즉, 진짜 메모리에 할당 되어있는 객체를 말합니다.즉, 객체라는 것은 실제하는 메모리에 들어있는 데이터 그리고 함수의 집합입니다.자바에서는 함수를 메서드 라고 표현합니다.정리하면객체 = 데이터 + 메서드라고 표현해볼 수 있습니다.붕어빵틀과 붕어빵필자는 컴퓨터공학관련된 전공을 하여 자바를 배울 수 있는 수업이 있었습니다.객체와 Class의 관계를 이해하는 것이 자바를 배우는 첫번째 걸음인데여기서 교수님께서는 이렇게 빗대어 표현하시더군요Class는 붕어빵틀 , Object는 붕어빵그때는 Class가 하나의 틀 이니까 객체를 생성하는 의미로 받아들였습니다.그런데 관련 저서를 읽다 보니 좀 더 구체적인 표현으로는정확히 Class는 붕어빵 틀이 이 아닌 형상틀 이다.인상적인 표현이였습니다. 생각해보면 Class는 여러 방식과 종류로객체를 만들어 낼 수 있고 붕어빵틀과 붕어빵은 클래스와 객체의 개념을 제한한다는 이야기로 받아들여 지기 때문입니다.물론 교수님께서는 학생들에게 쉽게 이해 시키기 위한 표현 이였지만, Java 개발자로써 목표를 삼고 있는 사람에게는 꽤 생각해 볼 이야기였습니다.Class는 청사진 , Object는 결과물이렇게 표현해 보는 것이 더 정확하게 표현할 수 있다고 생각합니다.객체의 특징객체의 특징을 보면 이런 이야기를 하고 있습니다.  속성과 동작: 객체는 데이터를 나타내는 속성(또는 멤버 변수)과 데이터를 처리하는 동작(또는 메서드)을 가집니다. 예를 들어, 자동차 객체는 속성으로는 색상, 속도, 모델 등을 가지고 있고, 동작으로는 주행, 정차, 가속 등을 수행할 수 있습니다.  상태와 행위: 객체는 상태(State)와 행위(Behavior)를 가집니다. 상태는 객체의 속성을 나타내며, 행위는 객체가 수행하는 작업을 나타냅니다. 이를 통해 객체는 자체적으로 데이터를 저장하고 관리하며, 필요한 작업을 수행할 수 있습니다.  캡슐화: 객체는 데이터와 해당 데이터를 처리하는 메서드를 하나의 단위로 묶어 캡슐화(Encapsulation)됩니다. 이를 통해 객체의 내부 구현을 외부에 숨기고, 객체 간의 상호 작용을 쉽게 관리할 수 있습니다.  상속: 객체는 다른 객체로부터 상속을 받아 기능을 확장할 수 있습니다. 상속을 통해 기존 클래스의 속성과 메서드를 재사용하고, 새로운 기능을 추가하여 코드를 확장할 수 있습니다.  다형성: 객체는 같은 이름의 메서드를 호출할 때 다양한 동작을 수행할 수 있습니다. 이를 다형성(Polymorphism)이라고 하며, 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.정리하면, 객체는 속성과 동작 그리고 이것을 다루면서 상태와 행위로써 볼 수 있습니다.객체는 캡슐화하여 데이터를 숨기고 , 동작하며 상속 받고 다형성을 구현할 수 있다. **그리고 이것이 바로 객체 지향 (OOP)의 중요 개념으로써 이야기 됩니다.OOP의 대하여객체 지향 프로그래밍(Object-Oriented Programming, OOP) 는 아래와 같은 특징을 가집니다.잘 읽어보면 결국 객체를 잘 만들고, 활용하기 위해 이런 방식으로 지향해라 , 개발해라 라는 의미인 것을 알 수 있습니다.  캡슐화 (Encapsulation):          캡슐화는 객체의 속성(데이터)과 행위(메서드)를 하나로 묶고, 외부에서의 직접적인 접근을 제한하는 개념입니다.      객체의 내부 구현은 외부로부터 숨겨지고, 오직 공개된 인터페이스를 통해서만 접근할 수 있습니다.      이를 통해 객체의 내부 구현을 보호하고, 안정성과 유지보수성을 높일 수 있습니다.        상속 (Inheritance):          상속은 기존 클래스의 속성과 메서드를 재사용하여 새로운 클래스를 정의하는 개념입니다.      상속을 통해 코드의 재사용성을 높일 수 있으며, 기존 클래스의 기능을 확장하여 새로운 기능을 추가할 수 있습니다.      상속을 통해 코드의 중복을 줄이고, 유지보수성을 높일 수 있습니다.        다형성 (Polymorphism):          다형성은 같은 이름의 메서드나 연산자를 다양한 방식으로 동작하도록 하는 개념입니다.      다형성을 통해 여러 객체를 하나의 타입으로 다룰 수 있으며, 객체의 실제 타입에 따라 다른 동작을 수행할 수 있습니다.      다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.        추상화 (Abstraction):          추상화는 객체에서 공통된 특성을 추출하여 모델링하는 개념입니다.      객체 지향 프로그래밍에서는 추상 클래스나 인터페이스를 사용하여 추상화를 구현합니다.      추상화를 통해 복잡한 시스템을 단순화하고, 핵심적인 부분에 집중할 수 있습니다.      여기서 캡슐화 ,상속, 다형성은 자바를 통해 개발하다 보면 자주 접할 수 있습니다.예를 들어 캡슐화는 접근제어자를 통해 이야기 해볼 수 있습니다.접근제어자? 그게뭔데Publicpublic class MyClass {    public int publicVar;    public void publicMethod() {        // 모든 클래스에서 접근 가능합니다.    }}protectedpublic class MyClass {    protected int protectedVar;    protected void protectedMethod() {        // 동일 패키지 내의 클래스와 해당 클래스를         // 상속받은 외부 패키지의 클래스에서 접근 가능합니다.    }}privatepublic class MyClass {    private int privateVar;    private void privateMethod() {        // 해당 클래스 내에서만 접근 가능합니다.    }}함수 앞에 적거나 변수 앞에 적어서 Scope를 표현하는 자바의 기술 중 하나입니다.즉, 캡슐화라는 것은 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶고, 외부에서의 직접적인 접근을 제한하는 것을 의미합니다.만약 다른 Class에서 private으로 선언한 함수를 부른다면? 찾지 못하고 오류를 낼 것입니다.이런식으로 접근을 제어해 캡슐화 시켰다는 개념을 이해해 볼 수 있습니다.상속과 다형성일단, 상속은  말그대로 받아오는 것 입니다. 코드로 이해하는 것이 훨씬 편한데// 부모 클래스class Vehicle {    String brand;    int year;    void honk() {        System.out.println(\"Tuut, tuut!\");    }}// 자식 클래스class Car extends Vehicle {    int wheels;    void describe() {        System.out.println(\"This car is a \" + brand + \" manufactured in \" + year + \" with \" + wheels + \" wheels.\");    }}// 메인 클래스public class Main {    public static void main(String[] args) {        Car myCar = new Car();        myCar.brand = \"Toyota\";        myCar.year = 2022;        myCar.wheels = 4;        myCar.describe(); // 출력: This car is a Toyota manufactured in 2022 with 4 wheels.        myCar.honk();     // 출력: Tuut, tuut!    }}보시는 것처럼 부모 클래스에는 큰틀이 자식 클래스에서는 자세한 데이터를 담아 두고 표현한 다는 것이죠.사람으로 비유하면? 부모 클래스는 사람 자식 클래스는  양세진, 김연아, 손흥민 등으로 만들어 볼 수 있습니다.다형성(Polymorphism)은 동일한 이름의 메서드나 연산자가 여러 클래스에서 다양한 방식으로 동작하는 것을 의미합니다.자바에서 다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.여기에는 오버로딩은 같은 이름의 메서드가 매개변수의 개수나 타입에 따라 다르게 동작하는 것을 말하며, 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의하여 다양한 동작을 구현하는 것을 말합니다.말은 어려운데 쉽게 이해해서 위 상속의 개념에서 여러 클래스로 나누어 다양한 함수 , 변수를 담는다 라는 의미입니다.// 부모 클래스class Animal {    void makeSound() {        System.out.println(\"Some sound\");    }}// 자식 클래스 1class Dog extends Animal {    @Override    void makeSound() {        System.out.println(\"Bark\");    }}// 자식 클래스 2class Cat extends Animal {    @Override    void makeSound() {        System.out.println(\"Meow\");    }}// 메인 클래스public class Main {    public static void main(String[] args) {        Animal myDog = new Dog(); // 다형성을 활용하여 Dog 객체를 Animal 타입으로 선언        Animal myCat = new Cat(); // 다형성을 활용하여 Cat 객체를 Animal 타입으로 선언                myDog.makeSound(); // 출력: Bark        myCat.makeSound(); // 출력: Meow    }}코드로 보면 훨씬 직관적으로 이해 할 수 있습니다.추상화? 뭐지?추상화 (Abstraction)를 만약 개발자가 아닌 사람들에게 물어보면 어떻게 대답할까요?아마 피카소를 떠올리며 이상하게 생긴 그림? 정도로 생각할 것입니다.사전에서는 • 미술에서 추상화(抽象畫)는 대상의 구체적인 형상을 나타낸 것이 아니라 점, 선, 면, 색과 같은 순수한 조형 요소로 표현한 미술의 한가지 흐름이다.그럼 추상이란?“추상”이라는 용어의 사전적 의미는 “사물이나 표상을 어떤 성질, 공통성, 본질에 착안하여 그것을 추출하여 파악하는 것” 이라 정의한다.라고 이야기합니다. 즉, 어떤 특징을 가져와서 부각 시켜 표현하는 것을 의미합니다.우리가 알아야하는 추상화도 같은 논리입니다.설계를 하며 공통된 특징을 찾아 추출해 이것을 인터페이스 혹은 추상 클래스 로써 만든다.결국  부각시킬 부분을 찾아내 이것을 표현한다 라고 이해 해볼 수 있습니다.정리하며오늘은 자바의 객체에 대해 공부하고 이해한 내용을 정리해봤습니다.특징에 대한 이해를 해보려 노력했는데 제 비유가 잘 이해 되실지 모르겠지만,다양한 블로그나 유튜브에서도 좋은 정보들이 많기 때문에 참고해보시면 도움이 될 거같습니다.다음 포스트자바 환경에 대한 이야기를 해보려고 합니다."
  },
  
  {
    "title": "JAVA에 대하여 - 서론",
    "url": "/posts/Java%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%9C%EB%A1%A0/",
    "categories": "java",
    "tags": "java, OOP, 언어의 역사",
    "date": "2024-01-03 06:44:00 +0900",
    





    
    "snippet": "들어가며JAVA에 대해 공부하며 배운 것들을 정리하고 생각한 것들을 정리하는 포스트 입니다.개발자들이 많이 사용하는 언어가 궁금해 찾아보다 해당 사이트를 확인했습니다.https://www.tiobe.com/tiobe-index/Python , c 계열 , 자바 가 50 퍼센트 가량 비율을 차지하고 있습니다.특히, 대한민국에서는 정부 공식 프레임워크로 ...",
    "content": "들어가며JAVA에 대해 공부하며 배운 것들을 정리하고 생각한 것들을 정리하는 포스트 입니다.개발자들이 많이 사용하는 언어가 궁금해 찾아보다 해당 사이트를 확인했습니다.https://www.tiobe.com/tiobe-index/Python , c 계열 , 자바 가 50 퍼센트 가량 비율을 차지하고 있습니다.특히, 대한민국에서는 정부 공식 프레임워크로 Spring기반을 사용하기 때문에 비중도가 높습니다.Python 의 경우 웹개발자 뿐만 아니라 AI , IOT등 차세대 분야에서도 많이 사용되고 있고 , 처음 언어를 공부할 때 편리하게 접근할 수 있어 높은 Ratings를 보여줍니다. 또한, 컴퓨터 공학을 전공하지는 않았지만 많은 관련업의 종사하시는 분들이 개발 언어로써 사용하고 있고, 그만큼 많은 라이브러리가 있다는점도 장점으로 들 수 있어 1위를 할 수 있는 것 같습니다.미국 정부에서는 C계열언어보다 Rust를 사용하라는 지침이 나오고 있어 Rust의 비중도 50위권 안으로 들어온 점이 인상적 입니다.왜 자바를 사용할까?자바는 C 보다는 늦게 나왔지만 꽤 나 오래된 언어입니다. 그럼에도 현재까지 많은 개발자들이 애용하고 있습니다. 많은 이유가 있겠지만 개인적인 생각을 적어보려고 합니다. 일단 Java가 나온 이유가 상당히 재밌기 때문에 소개하겠습니다.언어의 역사초창기 C 언어는 어셈블리어를 수학적으로 프로그래밍하기 위해 나왔습니다.그리고 JAVA는 C 에서 부족한 부분을 업그레이드 하기 위해 나온 언어입니다.어셈블리어는 실제로 다루어보면 꽤 나 직관적으로 이해할 수 있습니다.section .data    A dd 10       ; A 변수에 10 할당    B dd 20       ; B 변수에 20 할당    C dd 0        ; C 변수 초기화section .textglobal _start_start:    ; A와 B 값을 더하여 C에 저장    mov eax, dword [A]  ; A 변수의 값을 레지스터 eax로 로드    add eax, dword [B]  ; B 변수의 값을 더함    mov dword [C], eax  ; 결과를 C 변수에 저장    ; 프로그램 종료    mov eax, 1          ; 시스템 콜 번호 1 (프로그램 종료)    xor ebx, ebx        ; 종료 코드 0    int 0x80            ; 시스템 콜 호출    흔히 사용하는 고수준 프로그래밍 언어 (자바 , 파이썬등) 만 배워본 사람이라면 엥? 이라는 생각이 듭니다. 하지만 잘 보면 수도 코드를 규칙에 맞게 적어 놨다는 느낌을 받을 수 있습니다.A ,B , C 변수를 선언하고 함수로 저장 하는 과정을 만들어 놓은 것입니다.필자 또한 18학번이기 때문에 굳이? 어셈블리어를 따로 공부해본 경험은 없고 네트워크 수업을 들으며 어떤 식으로 되는지 이해한 정도가 전부입니다.하지만, 이해하기 어려운 이유는 어셈블리어는 저수준 프로그래밍 언어입니다.여기서 수준의 의미는 사람이 더 쉽게 이해할 수 있느냐 즉, 자연어로 이해하기 쉽냐는 의미입니다.메모리 위치나 명령어를 직접 코딩해서 동작 과정을 만들어 내야 하는 일이기 때문에 매우 귀찮지만 천천히 생각해보면 단순히, A를 저장 B를 더함 결과 C에 저장 하는 일을 하고 있습니다.만약 해당 코드를 자바로 코딩하면 어떨까요?public class Main {    public static void main(String[] args) {        int A = 10; // A 변수에 10 할당        int B = 20; // B 변수에 20 할당        int C;      // C 변수 선언        // A와 B를 더하여 C에 저장        C = A + B;        // 결과 출력        System.out.println(\"A + B = \" + C);    }}이렇게나 쉽고 빠르게 이해할 수 있습니다.이것이 수학적 프로그래밍이 필요한 이유라고 생각합니다. 하나하나 글로 설명하는 것보다 수식으로 딱 정리하면 훨씬 간단하니까요C에 대하여컴퓨터가 발명되고 얼마 안된 초창기 개발자들은 기계어 자체를 다루었고 (천공판)이후 개발자들은 어셈블리어로 처리 하였습니다.이때 당시에는 가능했던게 하드웨어의 발전이 아직 부족했기 때문에 큰 메모리를 가지기 어렵고 비쌌기 때문에 지금으로 치면 펌웨어가 동작하는 수준에 코드면 만족스러웠습니다. 즉, 어셈블리어로도 충분히 시간내에 개발이 가능하였습니다.하지만 하드웨어가 발달하고 시장이 커지면서 여러 기능들을 더욱 많이 탑재 해야했고, 어셈블리어로 작업하는 것은 매우 매우 고된 일 이였을 겁니다. (마치 Linux에서 vim 편집기를 쓰는 듯한)그래서 나온게 C 라는 언어입니다.  추상화 수준:          어셈블리어: 어셈블리어는 기계어에 가깝고, 컴퓨터의 하드웨어와 직접적으로 상호작용합니다. 명령어와 레지스터, 메모리 주소 등을 직접 다루기 때문에 하드웨어의 세부 사항을 명확하게 이해해야 합니다.      C: C는 어셈블리어에 비해 더 고수준의 언어입니다. 추상화 수준이 높아서, 개발자가 하드웨어의 세부 사항을 몰라도 프로그래밍할 수 있습니다. 또한, 포인터와 같은 고급 기능을 제공하여 메모리와의 상호작용을 추상화합니다.        가독성 및 이식성:          어셈블리어: 어셈블리어 코드는 기계어에 가까워서 읽기 어렵고 이해하기 어렵습니다. 또한, 어셈블리어 코드는 특정 CPU 아키텍처에 종속적이기 때문에 다른 아키텍처로 이식하기 어렵습니다.      C: C는 읽기 쉽고 이해하기 쉬운 문법을 가지고 있어서 가독성이 뛰어납니다. 또한, C는 플랫폼 독립적이기 때문에 다양한 운영체제와 하드웨어에서 실행될 수 있습니다.        개발 생산성:          어셈블리어: 어셈블리어는 하드웨어의 세부 사항을 직접 다루어야 하므로 개발 생산성이 낮습니다. 또한, 고급 작업을 수행하기 위해서는 많은 코드와 복잡한 로직이 필요합니다.      C: C는 저수준 프로그래밍 언어 중에서는 상당히 높은 개발 생산성을 제공합니다. 고급 작업을 수행하기 위한 라이브러리와 함께 사용되며, 하드웨어와의 상호작용을 추상화하여 개발자가 더 빠르게 프로그램을 작성할 수 있습니다.      정리하면 혁명이 일어났다고 해도 과언이 아닙니다.그럼 자바는 왜 필요한가?  플랫폼의 종속성                  지금은 플랫폼 시장이 많이 정리되었습니다. 큰 회사가 작은회사들을 인수하며 특정 좋은 부분들을 뽑아 자신의 것들과 합쳐 업데이트 했으니까요.        하지만 C 가 나온 시점은 많은 플랫폼들이 춘추 전국시대 처럼 꿈을 안고 도전하고 있었습니다. 하지만 C는 개발했던 플랫폼의 종속되기 때문에 모든 플랫폼에 맞춰 개발해야하는 문제점이 발생하게 됩니다.        예를 들어 윈도우에서 개발한 C 제품은 MAC OS에서는 동작하지 않는 것과 같은 이유입니다.        그래서 자바가 등장한 이유 입니다.        자바는 JVM , JAVA vaulture Machine을 사용합니다. 자바 가상 기계라고 하는데 책을 읽어보면 한세월 걸리지만 간단하게 설명하면 실생활에 있는 하드웨어와 같은 이치입니다.        자바를 위한 , 자바 만을 위한 플랫폼을 가상의 기계에서 만들어 내는 겁니다.              안전성과 보안                  필자는 C언어를 군대를 제대한 후 2학년 때 처음 배웠습니다. 열심히 살아야 된다는 생각때문인지 학점도 열심히 관리하고 공부도 하며 지냈을 때 입니다. 처음 강의를 들을 때는        ‘음 따라갈 만 하네’ 라고 생각하다 포인터라는 놈이 등장하면서 정신이 아늑해졌습니다.        포인터는 말 그대로 가르키는 녀석입니다. 어떤 변수의 값이 저장 되어 있는 메모리의 위치 주소를 가르킨다. 가 핵심인데 문제는 조건도 많고, 포인터 연산이라는 개념 때문에  많은 친구들이 전과를 심각하게 고려하는 시기였기도 합니다.        ### 어려워도 잘 쓰면? 좋은거 아님?        맞습니다. C는 직접 메모리 접근을 허용하기 때문에 수준 높은 개발자가 충분한 이해도를 가지고 개발을 하면 매우 성능 좋은 제품을 개발할 수 있습니다.        다른 이야긴 하지만 슈퍼마리오 개발지를 유튜브에서 본적 있는데 저는 이걸 보고 포인터가 생각이 났습니다.                아주 오래된 게임인 슈퍼마리오를 개발 할 때 매우 적은 메모리에 많은 내용을 담기 위해 개발자들이 고군분투하여 대단한 성능을 구현해 낼 수 있었습니다.        하지만 하드웨어가 매우 빠르게 발전함에 따라 드는 의문이 발생합니다.        “그거 고민할 시간에 좀 더 좋은 사양쓰고 , 코드 한줄 더 적는게 이득아님?”        그래서 JAVA는 포인터와 해당 연산의 개념을 지우고 자동으로 메모리를 관리할 수 있게 하였습니다.        또한, 아주 고급 개발자가 아닌 이상 사람이기 때문에 실수 하고 결국 이는 메모리 누수로 이루어 지기 때문에 JAVA 버전이 올라감에 따라 더욱 이유가 부각되고 있습니다.        즉 정리하면, 하드웨어가 발전함에 따라 예전보다는 치밀한 관리가 필요하지 않기 때문에 기계에게 자동으로 맡겨 두는게 이득이다! 라고 자바 개발자는 생각했던 것 같습니다.              객체 지향 프로그래밍                  자바의 꽃 , 핵심 객체 지향입니다. 약어로 OOP 라고도 부릅니다.        사실 C 도 C++을 쓰거나 지금의 C는 객체 지향적으로 프로그래밍이 충분히 가능합니다.        하지만 자바는 객체 지향적으로  프로그래밍을 할 수 있도록 유도합니다.        가장 대표적으로 자바의 4원칙 (다른 포스팅에서 이야기할 것입니다.)        Class와 객체 입니다.        자바의 모든 것은 객체이고 객체가 아니면 존재할 수 없도록 해놨습니다.        처음 이런 개념을 접했을때 필자는 이렇게 생각했습니다.        “그럼 다른 언어는 왜쓰냐? 업그레이드 버전이있는데?”        그럼 자바는 이전 프로그래밍 방식을 완전히 벗어나 혁명적인 업그레이드 이냐? 아닙니다. 이전 개발 방식은 절차적/구조적 프로그래밍 입니다.        그럼 그게 뭐냐? 개념적으로 설명하려면 한 세월이지만 필자 개인적인 생각으로는        “함.수.써.라”입니다. 왜? 중복코드 관리해야하니까        이것이 절차적/구조적 프로그래밍의 핵심이라고 생각합니다.        그럼 자바는 함수 안쓰냐? 씁니다. 이외에도 정말 많은 개념이 녹아있습니다.        즉, 자바가 강조하는 객체 지향은 기존 방식의 업그레이드 버전입니다.        객체지향에 대한 이야기도 다음 포스트에서 다루고 이런게 있다 정도로 마무리하겠습니다.            다음포스트java가 동작하는 방식에 대해 설명해보겠습니다 !"
  },
  
  {
    "title": "Git 사용법 - 세팅",
    "url": "/posts/Git%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%A4%EC%A0%95/",
    "categories": "Git",
    "tags": "Git, Github, git",
    "date": "2024-01-02 06:44:00 +0900",
    





    
    "snippet": "들어가며이번 포스트 에서는 설정을 할것입니다.레포지토리를 만들어 업로드하는 과정들은 워낙 정보가 많으니 실제로 사용하는 법을 보여드리겠습니다.예를들어 git add -A , git commit -m “first” 이런 코드들을 주는 것은 대체 블로그가 많습니다.저는 이렇게 사용합니다.최근 IDE 가 발달하고 Git을 대부분 지원하기 때문에 딸깍 몇번 ...",
    "content": "들어가며이번 포스트 에서는 설정을 할것입니다.레포지토리를 만들어 업로드하는 과정들은 워낙 정보가 많으니 실제로 사용하는 법을 보여드리겠습니다.예를들어 git add -A , git commit -m “first” 이런 코드들을 주는 것은 대체 블로그가 많습니다.저는 이렇게 사용합니다.최근 IDE 가 발달하고 Git을 대부분 지원하기 때문에 딸깍 몇번 이면 알아서 해줍니다.그래서 굳이? shell명령어를 입력 해야하나? 라고 생각해볼 수도 있습니다.그렇지만 필자는 클라우드 서버환경 예로, AWS ,GCP 에서 서버를 만들고 입력할 때는 알고 있어야 편하게 작업할 수 있어서 공부하였습니다.그래서 로컬말고 클라우드 서버에서 진행해보겠습니다!로컬에서 사용중인(개발자 개인컴퓨터) IDE 와 서버를 연결하는 방법이 다양합니다. 이후에 관련된 포스트를 적어보겠습니다.다음 머릿말 전까지는 GCP 설정에 대한 이야기 입니다.일단 우분투 서버를 하나 준비해보겠습니다.최근에 GCP에 대해 공부하고 있어서 무료 크래딧이 많은 관계로 GCP에서 서버를 하나 가져와보겠습니다.일단 GCP에 들어가서 서버를 하나 무료로 만들어보겠습니다.여러가지 설정을 할 수 있는데  이후에 GCP에 대해 포스트 할때 더 자세히 이야기 해보겠습니다.일단은 우분투로 서버 이미지를 선택해서 하나 만들어보겠습니다.이름을 지정하고 서버 이미지를 선택합니다.실제로 서버에서 사용해보겠습니다.일단 GCP는 브라우저 창에서 SSH로 바로 연결해주는 서비스가 매우 잘되어있어서 클릭후 들어와 보겠습니다. (AWS 도 있습니다.)이런 환경에서는 Git 명령어를 잘 알아야 쓸 수 있겠죠일단 관리자 권한과 업데이트를 진행합니다.sudo su #관리자권한 -&gt; 실제 사용하는 서버는 비밀번호를 설정해둡니다.sudo apt update #업데이트Git 을 다운받아줍니다.apt install git # 인스톨해주고git --version #확인해줍니다.그러면 git 을 연결해 봅시다.먼저 포함된 레포지토리를 하나 작성해줍니다.그다음 https 가 포함된 URL을 복사해줍시다.이제 서버에서 아래처럼 입력하면 됩니다.git clone &lt;레포지토리 주소&gt;잘 들어온 것을 확인할 수 있습니다. 이것을 clone 즉, 복사해오는 방법입니다.전 포스트에서 설명하였는데 , git을 쓰는 목적중 분산저장소 라는 개념이 이런 식으로 사용됩니다.Repository에 아무것도 없는 환경에서 git 사용설정들을 여러가지 해야 하고 , 보통 로컬 환경에서 코딩 및 검수를 끝내고 Demo 정도가 되었을 때 서버에 Setting해서 개인적으로 자주 사용하는 방법은 아닙니다.사실 비용 때문에 최대한 늦게 합니다..zz(서버에 올릴때는 코드가 이미 존재하고 , 개발하면서 서버에 올려두면 서버 비용이 나가서..)하지만 생각보다 어렵지 않습니다. 아래 방법을 설명해보겠습니다.      사용자 정보 설정:Git을 사용하기 위해 사용자 이름과 이메일 주소를 설정해야 합니다. 이 정보는 커밋할 때 사용됩니다.     git config --global user.name \"Your Name\" git config --global user.email \"your_email@example.com\"            Your Name에는 사용자의 실제 이름을, your_email@example.com에는 사용자의 이메일 주소를 넣어주세요.        설정 확인:설정이 올바르게 되었는지 확인하기 위해 설정을 출력할 수 있습니다.     git config --list        이 명령어는 현재 Git의 전역 설정을 모두 보여줍니다.        초기화:Git 저장소를 초기화하려면 해당 디렉토리로 이동한 후 아래 명령어를 실행하세요.     git init        이 명령어는 현재 디렉토리에 새로운 Git 저장소를 만듭니다.  이제 이 명령어들을 사용하여 Git을 설정하고 초기화할 수 있습니다. 설정 후에는 파일을 추적하고 커밋할 수 있습니다. 필요에 따라 Git의 추가적인 설정도 있을 수 있습니다.추가 사항.. 3월 중순에 테스트해본 결과 비밀번호를 지원하지 않습니다.SSH 방법은 추후에 다시 작성 하겠습니다.다음 포스트설정을 완료 하였습니다. 다음 포스트 에서는 개념을 정리해보며 실제 사용법을 익혀보겠습니다."
  },
  
  {
    "title": "Git 사용법 - 서론&설치",
    "url": "/posts/Git%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%84%9C%EB%A1%A0&%EC%84%A4%EC%B9%98/",
    "categories": "Git",
    "tags": "Git, Github, git",
    "date": "2024-01-01 06:44:00 +0900",
    





    
    "snippet": "들어가며깃 , 깃허브는 개발자가 반드시 알아야 되는 필수 기술 중 하나라고 생각합니다.현재 개발자들이 애용하고 있고, 기업에서도 사용하고 있습니다.또한 , 많은 기능이 있어서 한 사이트 , 기술 스택에서 다양한 활동을 진행할 수 도 있습니다.포스트를 하며 여러 기술들에 대해 공부한 내용을 공유해 보려고 합니다.그래서 Git이 뭔데?Git 이란 버전관리...",
    "content": "들어가며깃 , 깃허브는 개발자가 반드시 알아야 되는 필수 기술 중 하나라고 생각합니다.현재 개발자들이 애용하고 있고, 기업에서도 사용하고 있습니다.또한 , 많은 기능이 있어서 한 사이트 , 기술 스택에서 다양한 활동을 진행할 수 도 있습니다.포스트를 하며 여러 기술들에 대해 공부한 내용을 공유해 보려고 합니다.그래서 Git이 뭔데?Git 이란 버전관리 시스템 (VCS,Version Control System) 중 하나입니다.즉 , 버전을 관리하는 시스템 → 변경사항을 저장하고 , 메시지와함께 기록해둘 수 있습니다.왜 쓸까?여러 이유가 있지만 가장 근본적인 이유는 위 설명한 코드를 기록하는데 있습니다.그 외에도 여러 기능이 있는데 필자가 생각했을 때 가장 핵심적인 요소들로 정리해봤습니다.  분산 시스템: Git은 분산 버전 관리 시스템입니다. 이는 모든 개발자가 로컬 저장소를 가지고 있고, 변경 사항을 서버에 반영하는 대신 로컬에서 변경 사항을 커밋할 수 있다는 것을 의미합니다.  브랜치: Git은 브랜치를 사용하여 개발 작업을 분리하고 병합할 수 있습니다. 이를 통해 여러 개발자가 동시에 작업할 수 있고, 기능을 개발하거나 버그를 수정하는 데 사용할 수 있습니다.  원격 저장소: Git은 원격 저장소를 사용하여 여러 사용자가 함께 작업하고 변경 사항을 공유할 수 있습니다. GitHub, GitLab, Bitbucket 등의 호스팅 서비스를 통해 원격 저장소를 만들고 관리할 수 있습니다.  병합: Git은 브랜치에서 작업한 변경 사항을 다른 브랜치로 병합할 수 있습니다. 이를 통해 여러 개발자가 작업한 변경 사항을 통합하고, 충돌을 해결할 수 있습니다.  추적: Git은 파일의 변경 이력을 추적하고, 누가 언제 어떤 변경 사항을 만들었는지 추적할 수 있습니다. 이를 통해 개발자는 변경 사항을 추적하고 필요한 경우 이전 상태로 돌아갈 수 있습니다.정리하면 로컬 , 원격 저장소에 저장 , 여러 가지로 저장 , 저장된 내용을 병합 추적이렇게 정리해볼 수 있습니다. **더 자세한 개념은 이후 포스트에서 사용할 때 함께 설명하겠습니다.진짜 왜 쓸까?위 내용은 개념적인 내용이고 GIT을 쓰기 시작한 이유를 체득한 이야기입니다.대학교 1학년 시절 진정한 코린이로써 과제를 풀기에도 급급할 때 입니다.수업 전까지 완성해야 제출할 수 있는데 술과 친구들이 너무 좋아 벼락 코딩을 하고 있습니다.열심히 코딩을 하며 한단계 두단계 나아가다 어느 순간 코드가 꼬였습니다.다시 찾으려 애를 쓰지만 마구잡이로 써놓은 코드들 덕분에 어디서 부터 문제인지 찾을 수가 없어..30분동안 돌려보며 찾아보지만 어디서 부터 문제인지 못 찾아 처음부터 다시 코딩을 시작합니다.이때 Git을 알고 있었다면 어땠을까요?커밋된 내용들을 쓱 보며 타임라인에서 제대로 된 코드부터 다시 시작해보거나 , 문제점을 바로 찾을 수 있을 겁니다.이게 제가 GIT을 알게된 후 열심히 사용하고 있는 이유입니다.또한, 팀과 일할 때는 여러 코드들이 꼬이고 병합하는 과정에서 코드끼리 기능상 문제가 생기는 경우도 많습니다. 이럴때는 잘 만들어둔 코드를 살리고 문제가 있는부분을 찾아내 고치는게 훨씬 빠르고, 쉽습니다.어떻게 쓸까?일단 깃을 설치해야 합니다. 설치 방법은 다음과 같습니다.필자는 windows 와 mac 환경에서 개발을 합니다.하지만 서버를 구성하는데는 ubuntu , Linux를 자주 사용하기 때문에 4가지 방법을 제시합니다.Windows:  공식 웹사이트에서 설치하기:          Git의 Windows 용 설치 프로그램은 Git 공식 웹사이트(https://git-scm.com/)에서 다운로드할 수 있습니다.      다운로드 및 설치 프로세스를 따라가면 됩니다.        Chocolatey를 사용하여 설치하기:                  Chocolatey를 설치한 후, 명령 프롬프트나 PowerShell에서 다음 명령어를 실행하여 Git을 설치할 수 있습니다:          Copy code  choco install git                    Linux:  패키지 관리자를 사용하여 설치하기:                  대부분의 Linux 배포판은 패키지 관리자를 통해 Git을 설치할 수 있습니다.                    예를 들어, Ubuntu/Debian에서는 다음 명령어를 사용합니다:          sudo apt update  sudo apt install git                    Ubuntu:  패키지 관리자를 사용하여 설치하기:                  Ubuntu에서도 패키지 관리자를 사용하여 Git을 설치할 수 있습니다.                    터미널에서 다음 명령어를 실행합니다:          sudo apt update  sudo apt install git                    macOS:  Homebrew를 사용하여 설치하기:                  Homebrew를 사용하여 macOS에 Git을 설치할 수 있습니다.                    터미널에서 다음 명령어를 실행합니다:          brew install git                    다음 포스팅설치가 완료되었다면 실제로 사용하는 법을 보여드리며 테스트를 진행해보겠습니다."
  }
  
]


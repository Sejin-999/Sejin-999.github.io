---
title: 자바에 대하여 - OOP에서의 디자인패턴
date: 2024-02-01 06:44:00 +09:00
categories:
  - java
tags:
  - [java, OOP , Design 패턴 , Single toon ]
---
## 들어가며

디자인 패턴이란, 클래스들 간의 관계를 어떻게 잘 연결할 것인지에 대해 이야기하는 것입니다.

### **생성 패턴**

이러한 패턴들은 기존 코드의 유연성과 재사용을 증가시키는 다양한 객체 생성 메커니즘들을 제공합니다.

### **구조 패턴**

이러한 패턴들은 객체들과 클래스들을 구조를 유연하고 효율적으로 유지하면서 더 큰 구조로 조립하는 방법을 설명합니다.

### **행동 패턴**

이러한 패턴들은 알고리즘들 및 객체 간의 책임 할당과 관련이 있습니다.

## SingleTone

어떤 클래스가 최대 한 번의 인스턴스만을 갖도록 보장하는 패턴입니다. 이 패턴을 사용하면 특정 클래스의 인스턴스가 오직 하나만 존재하도록 제한할 수 있으므로, 리소스의 낭비를 방지하고 객체 간의 일관성을 유지할 수 있습니다.

1. **Private Constructor(비공개 생성자)**: 클래스 내부에 생성자를 비공개로 만듭니다. 이렇게 하면 외부에서 해당 클래스의 객체를 생성할 수 없습니다.
2. **Static Instance(정적 인스턴스)**: 클래스 내부에 자체적으로 유일한 인스턴스를 가지도록 정적 멤버 변수를 생성합니다.
3. **getInstance() 메서드**: 유일한 인스턴스에 접근할 수 있는 정적 메서드를 제공합니다. 이 메서드는 클래스의 인스턴스를 반환하며, 필요한 경우 인스턴스를 생성하거나 기존에 생성된 인스턴스를 반환합니다.

스프링에서 Bean을 생성해 사용하는 이유와도 동일합니다.

하나의 객체를 생성하고 이 인스턴스를 유지시킴으로써 사용하게 됩니다.

## Strategy Pattern

알고리즘을 캡슐화하고 이를 상호 교체할 수 있도록 하는 패턴입니다. 이 패턴을 사용하면 알고리즘의 변경이나 확장에 유연하게 대처할 수 있으며, 코드 재사용성과 유지보수성을 향상시킬 수 있습니다.

쉽게 생각해 어떤 기능이 다양한 모듈로써 이루어져있을때 이를 분리해서 필요할때마다 갈아끼는 전략 즉, 지정된 모듈에 따라 다르게 실행되도록 하는 것 이라고 생각할 수 있습니다.

구성요소

1. **전략(Strategy)**: 다양한 알고리즘을 캡슐화한 인터페이스나 추상 클래스입니다. 전략을 구현하는 각각의 클래스는 동일한 인터페이스를 가지고 있어야 합니다.
2. **컨텍스트(Context)**: 전략을 사용하는 클라이언트 객체입니다. 컨텍스트는 전략 객체를 유지하고, 필요할 때 해당 전략을 실행합니다.
3. **구체적인 전략(Concrete Strategies)**: 전략 인터페이스를 구현한 실제 알고리즘 클래스들입니다.

인터페이스나 추상 클래스를 통해 전략을 정의하고, 각각의 구체적인 전략 클래스를 만들어 이를 컨텍스트에 주입합니다. 컨텍스트는 실행 시점에 필요한 전략 객체를 선택하여 사용합니다.

예를 들어, 정렬 알고리즘을 사용하는 클래스에서 전략 패턴을 적용하면, 정렬 알고리즘을 전략으로 캡슐화하고, 필요에 따라 다양한 정렬 알고리즘을 선택하여 사용할 수 있습니다. 이를 통해 정렬 알고리즘의 변경이나 추가에 유연하게 대응할 수 있습니다.

## State Pattern

객체의 상태에 따라 객체의 행동이 달라지도록 하는 패턴입니다. 객체의 내부 상태가 바뀜에 따라 객체의 행동을 변경하고, 이를 캡슐화하여 상태 전환을 관리합니다.

구성요소

1. **Context(컨텍스트)**: 상태를 가지고 있는 객체입니다. 컨텍스트는 상태 객체를 갖고 있고, 상태 객체가 정의한 행동을 수행합니다. 또한, 컨텍스트는 상태 전환을 위한 인터페이스를 제공합니다.
2. **State(상태)**: 상태를 나타내는 인터페이스나 추상 클래스입니다. 각각의 상태에 대한 특정 행동을 정의합니다.
3. **ConcreteState(구체적인 상태)**: State 인터페이스를 구현한 클래스들입니다. 각각의 클래스는 특정 상태에서의 행동을 구현합니다.

예를 들어, 자판기의 동작을 State Pattern으로 구현할 수 있습니다. 자판기는 여러 상태를 가지고 있을 수 있으며(예: 동전 투입 대기 상태, 음료 선택 상태, 음료 배출 상태 등), 각 상태에 따라 다른 행동을 수행합니다. State Pattern을 사용하면 자판기의 각 상태를 클래스로 나타내고, 상태 전환을 효율적으로 관리할 수 있습니다.

## Strategy Pattern vs State Pattern

굳이? 분리해둔거 같긴한데 약간의 목적의 차이점이 있습니다. 

- **Strategy Pattern**: 알고리즘을 캡슐화하고 이를 교체 가능하도록 만듭니다. 동일한 문제를 해결하기 위해 여러 알고리즘이 필요한 경우 사용됩니다.
- **State Pattern**: 객체의 상태를 캡슐화하고 상태에 따라 객체의 행동을 변경합니다. 객체의 행동이 상태에 의존하는 경우 사용됩니다.

Strategy Pattern은 다양한 알고리즘을 교체 가능하게 만들어 동일한 문제를 해결하는 다양한 방법을 제공합니다. State Pattern은 객체의 상태에 따라 동작이 달라지는 경우에 사용되며, 객체의 상태를 캡슐화하여 관리합니다.

정리하면 strategy 는 다양한 알고리즘을 활용 해야하는 경우, state 는 분기점이 많은 경우에 사용할 수 있다. 

## Commend Pattern

작업을 객체의 형태로 캡슐화하여 요청을 나타내는 패턴입니다. 이 패턴을 사용하면 요청을 객체로 변환하고 매개 변수화하여 다른 객체에 전달할 수 있으며, 이를 통해 요청을 큐에 저장하거나 로깅하고, 실행 취소 및 다시 실행할 수 있는 기능을 지원할 수 있습니다.

1. **Command(명령)**: 실행될 작업을 나타내는 인터페이스입니다. 보통 execute() 메서드를 정의하고, 해당 작업을 수행합니다.
2. **ConcreteCommand(구체적인 명령)**: Command 인터페이스를 구현하는 클래스입니다. 실제로 실행될 작업을 구체화합니다.
3. **Invoker(호출자)**: 명령 객체를 실행하는 객체입니다. 보통 클라이언트에서 명령을 실행할 때 사용됩니다.
4. **Receiver(수신자)**: 실제 작업을 수행하는 객체입니다. ConcreteCommand에서 정의된 작업을 수행합니다.

명령 패턴은 다양한 상황에서 유용하게 사용될 수 있습니다. 예를 들어, 사용자 인터페이스의 버튼이나 메뉴 항목은 명령 객체로 표현될 수 있으며, 버튼을 클릭하면 해당 명령이 실행됩니다. 또한, 명령 패턴은 작업을 큐에 저장하여 나중에 실행하거나, 실행 취소 및 다시 실행 기능을 구현하는 데 사용될 수 있습니다.